What Readers Are Saying About

Agile Web Development with Rails

When I started learning Ruby on Rails, I read the first edition of this book. Its
holistic view of the Rails framework and community provides any new developer
the kick start they need to a highly successful career. After reading through the
latest edition cover to cover, I can happily say that it continues that trend and
remains the first book I recommend to any new Rails developer.
➤ Mikel Lindsaar
Rails core commit team, creator of the Ruby Mail library, and director, RubyX
Agile Web Development with Rails does an excellent job of making the Rails environment accessible in an enjoyable and memorable way. In addition, this book is
the first I’ve seen that provides a sensible and coherent explanation of the MVC
pattern, and it does so in a natural progression using examples that completely
remove any mystery.
➤ Ken Coar
Author, open software evangelist, and Apache developer

Agile Web Development with Rails successfully straddles a fine line between being
a fun-to-read introduction to Rails (and Ruby) and a straightforward guide to
some advanced features of the platform, nicely supplanting the ever-changing
online documentation.
➤ Glen Daniels
Independent technologist and consultant
I’ve never read a programming book as successful as Agile Web Development with
Rails. Sam made learning Ruby on Rails easy, comprehensive, and fun.
➤ Keith Ballinger
Chairman of WS-I’s first Basic Profile working group; author; and key contributor to the .NET and Visual Studio .NET frameworks

Agile Web Development
with Rails
Fourth Edition

Sam Ruby
Dave Thomas
David Heinemeier Hansson

with Leon Breedt
Mike Clark
James Duncan Davidson
Justin Gehtland
Andreas Schwarz

The Pragmatic Bookshelf
Dallas, Texas • Raleigh, North Carolina

Many of the designations used by manufacturers and sellers to distinguish their products
are claimed as trademarks. Where those designations appear in this book, and The Pragmatic
Programmers, LLC was aware of a trademark claim, the designations have been printed in
initial capital letters or in all capitals. The Pragmatic Starter Kit, The Pragmatic Programmer,
Pragmatic Programming, Pragmatic Bookshelf, PragProg and the linking g device are trademarks of The Pragmatic Programmers, LLC.
Every precaution was taken in the preparation of this book. However, the publisher assumes
no responsibility for errors or omissions, or for damages that may result from the use of
information (including program listings) contained herein.
Our Pragmatic courses, workshops, and other products can help you and your team create
better software and have more fun. For more information, as well as the latest Pragmatic
titles, please visit us at http://pragprog.com.

Copyright © 2011 Pragmatic Programmers, LLC.
All rights reserved.

No part of this publication may be reproduced, stored in a retrieval system, or
transmitted, in any form, or by any means, electronic, mechanical, photocopying,
recording, or otherwise, without the prior consent of the publisher.
Printed in the United States of America.
ISBN-13: 978-1-934356-54-8
Printed on acid-free paper.
Book version: P2.2—January 2012

Contents
Preface to the Fourth Edition

.

.

.

.

Preface to the Rails 3.2 Version of This Book
Acknowledgments .
Introduction .

.

.
.

.
.

.
.

.
.

.
.

.
.

.
.

.

.

.
.

.

.

.
.

.
.

.

xi
xiii

.

.

xv

.

xvii

Part I — Getting Started
1.

Installing Rails .
.
.
.
.
.
.
.
.
1.1 Installing on Windows
1.2 Installing on Mac OS X
1.3 Installing on Linux
1.4 Choosing a Rails Version
1.5 Setting Up Your Development Environment
1.6 Rails and Databases
1.7 What We Just Did

2.

Instant Gratification .
.
.
2.1 Creating a New Application
2.2 Hello, Rails!
2.3 Linking Pages Together
2.4 What We Just Did

3.

The
3.1
3.2
3.3

.

.

.

Architecture of Rails Applications .
.
Models, Views, and Controllers
Rails Model Support
Action Pack: The View and Controller

.

.

.

.

.

.

.

.

.

.

3
4
5
6
8
9
12
14
15
15
17
24
27

.

29
29
32
34

Contents

4.

Introduction to Ruby .
.
.
.
.
.
4.1 Ruby Is an Object-Oriented Language
4.2 Data Types
4.3 Logic
4.4 Organizing Structures
4.5 Marshaling Objects
4.6 Pulling It All Together
4.7 Ruby Idioms

.

•

vii

.

.

.

37
37
39
43
46
49
49
50

.

.

.

55
55
56
60

Part II — Building an Application
5.

The
5.1
5.2
5.3

Depot Application .
.
.
Incremental Development
What Depot Does
Let’s Code

.

.

.

.

6.

Task A: Creating the Application .
.
.
.
6.1 Iteration A1: Creating the Products
Application
6.2 Iteration A2: Making Prettier Listings
.

.
.
.
Maintenance

61
61
68

7.

Task B: Validation and Unit Testing
.
7.1 Iteration B1: Validating!
7.2 Iteration B2: Unit Testing of Models

.

8.

Task
8.1
8.2
8.3
8.4

C: Catalog Display
.
.
.
.
.
.
.
Iteration C1: Creating the Catalog Listing
Iteration C2: Adding a Page Layout
Iteration C3: Using a Helper to Format the Price
Iteration C4: Functional Testing of Controllers

9.

Task
9.1
9.2
9.3

D: Cart Creation
.
.
.
.
.
.
.
Iteration D1: Finding a Cart
Iteration D2: Connecting Products to Carts
Iteration D3: Adding a Button

.

.

105
105
106
108

10.

Task
10.1
10.2
10.3

E: A Smarter Cart .
.
.
.
.
Iteration E1: Creating a Smarter Cart
Iteration E2: Handling Errors
Iteration E3: Finishing the Cart

.

.

115
115
119
123

.

.

.

.

.

77
77
82

.

.

91
91
96
99
100

Contents

•

viii

11.

Task
11.1
11.2
11.3
11.4
11.5
11.6

F: Add a Dash of Ajax
.
.
.
.
.
Iteration F1: Moving the Cart
Iteration F2: Creating an Ajax-Based Cart
Iteration F3: Highlighting Changes
Iteration F4: Hiding an Empty Cart
Iteration F5: Making Images Clickable
Testing Ajax Changes

.

.

.

129
130
136
140
143
146
148

12.

Task
12.1
12.2
12.3

G: Check Out! .
.
.
.
.
Iteration G1: Capturing an Order
Iteration G2: Atom Feeds
Iteration G3: Pagination

.

.

.

153
153
166
170

13.

Task H: Sending Mail .
.
.
.
.
.
.
.
13.1 Iteration H1: Sending Confirmation Emails
13.2 Iteration H2: Integration Testing of Applications

.

.

175
175
182

14.

Task
14.1
14.2
14.3
14.4

I: Logging In
.
.
.
.
.
.
.
.
.
.
Iteration I1: Adding Users
Iteration I2: Authenticating Users
Iteration I3: Limiting Access
Iteration I4: Adding a Sidebar, More Administration

15.

Task
15.1
15.2
15.3
15.4

J: Internationalization .
.
.
.
Iteration J1: Selecting the Locale
Iteration J2: Translating the Storefront
Iteration J3: Translating Checkout
Iteration J4: Add a Locale Switcher

16.

Task K: Deployment and Production .
.
.
.
.
.
16.1 Iteration K1: Deploying with Phusion Passenger and
MySQL
16.2 Iteration K2: Deploying Remotely with Capistrano
16.3 Iteration K3: Checking Up on a Deployed Application

230
237
243

Depot Retrospective .
.
.
.
.
17.1 Rails Concepts
17.2 Documenting What We Have Done

247
247
250

17.

.

.

.

.

.

.

.

.

.

189
189
194
200
203
.

.

209
209
213
219
225
229

Contents

•

ix

Part III — Rails in Depth
18.

Finding Your Way Around Rails
18.1 Where Things Go
18.2 Naming Conventions

.

.

.

.

.

255
255
264

19.

Active Record
.
.
.
.
.
.
.
.
.
.
19.1 Defining Your Data
19.2 Locating and Traversing Records
19.3 Creating, Reading, Updating, and Deleting (CRUD)
19.4 Participating in the Monitoring Process
19.5 Transactions

.

269
269
274
278
294
301

20.

Action Dispatch and Action Controller
.
.
.
20.1 Dispatching Requests to Controllers
20.2 Processing of Requests
20.3 Objects and Operations That Span Requests

.

.

307
307
319
330

21.

Action View .
.
.
.
.
.
.
.
.
.
.
21.1 Using Templates
21.2 Generating Forms
21.3 Processing Forms
21.4 Uploading Files to Rails Applications
21.5 Using Helpers
21.6 Reducing Maintenance with Layouts and Partials

.

341
341
343
346
348
351
358

22.

Caching .
.
.
.
.
.
.
.
22.1 Playing Nice with Client Caches
22.2 Page Caching
22.3 Expiring Pages
22.4 Fragment Caching

.

.

.

.

369
370
374
376
381

23.

Migrations
.
.
.
.
.
.
.
.
.
23.1 Creating and Running Migrations
23.2 Anatomy of a Migration
23.3 Managing Tables
23.4 Advanced Migrations
23.5 When Migrations Go Bad
23.6 Schema Manipulation Outside Migrations

.

.

.

387
387
390
394
399
402
403

.

.

.

x

•

Contents

24.

Nonbrowser Applications .
.
.
.
.
.
.
24.1 A Stand-Alone Application Using Active Record
24.2 A Library Function Using Active Support
24.3 A Remote Application Using Active Resource

.

.

405
405
406
411

25.

Rails’ Dependencies .
.
.
.
.
.
.
25.1 Generating XML with Builder
25.2 Generating HTML with ERb
25.3 Managing Dependencies with Bundler
25.4 Interfacing with the Web Server with Rack
25.5 Automating Tasks with Rake
25.6 Survey of Rails’ Dependencies

.

.

.

419
419
421
423
426
429
431

26.

Rails
26.1
26.2
26.3

Plugins .
.
.
.
.
.
.
.
.
.
Credit Card Processing with Active Merchant
Beautifying Our Markup with Haml
Finding More at RailsPlugins.org

.

.

437
437
439
441

27.

Where to Go from Here

A1. Bibliography .
Index

.

.

.
.

.

.

.

.

.

.

.

.

.

445

.

.

.

.

.

.

.

.

.

447

.
.

.

.

.

.

.

.

.

.

.

449

Preface to the Fourth Edition
When Dave asked me to join as a coauthor of the third edition of this book,
I was thrilled. After all, it was from the first printing of the first edition of this
book that I had learned Rails. Dave and I also have much in common.
Although he prefers Emacs and Mac OS X and my preferences tend toward
Vim and Ubuntu, we both share a love for the command line and getting our
fingers dirty with code—starting with tangible examples before diving into
heavy theory.
Since the time the third edition was published (and, in fact, since the first,
second, and third editions), much has changed. Rails is in the process of being
significantly refactored, mostly internally. A number of features that were
used in previous examples have been initially deprecated and subsequently
removed. New features have been added, and much experience has been
obtained as to what the best practices are for using Rails. Rails now also
works on Ruby 1.9, and each of the examples has been tested with Ruby
1.8.7, 1.9.2, and 1.9.3.
Additionally, Rails has exploded from being a popular framework to an active
and vibrant ecosystem, complete with many popular plugins and deep integration into third-party tools. In the process, Rails has become mainstream,
attracting a more diverse set of developers to the framework.
This has led to a reorganization of the book. Many newcomers to Rails have
not had the pleasure of being introduced to Ruby, so this section has been
promoted from an appendix to a chapter in Part I. We follow Part I with a
step-by-step walk-through of building a real application, which has been
updated and streamlined to focus on current best practices.
But the biggest change is in the final part: because it is no longer practical
to cover the entire ecosystem of Rails given both its breadth and rate of change,
this part is now focused on providing an overall perspective of the landscape,
enabling you, the reader, to know what to look for and where to find plugins

report erratum • discuss

xii

•

Preface to the Fourth Edition

and related tools to address common needs that go far beyond what the
framework itself contains.
In short, this book needed to adapt. Once again.
Sam Ruby
March 2011

report erratum • discuss

Preface to the Rails 3.2 Version of This Book
This book is written for Rails 3.2.
Unlike Rails 3.1, Rails 3.2 is truly only a minor release and includes few major
changes. This book has been updated to reflect these changes.
Here’s an overview of some of the changes:
• The turn gem, which was introduced in 3.1, was removed in 3.2
• bcrypt-ruby now needs to be explicitly added to your Gemfile in order to use
has_secure_password()

• Ruby 1.9.3 was released, and is supported
• Ubuntu 11.10 was released, and is supported
• rvm notes moved to rvm requirements
• Automatic Query Explains
For further details, see the release notes.1
To run the examples provided in this book, it is important that you install
the correct version of Rails, as described in Chapter 1, Installing Rails, on
page 3. If you chose to download the examples, as described in Section 4,
How To Read This Book, on page xxi, make sure that you select files from the
rails32 directory.
To determine the version of Rails that you are running, you can issue rails -v
at a command prompt.
Additional information on changes to Rails that affect this book can be found
at http://www.pragprog.com/wikis/wiki/ChangesToRails.

1.

http://guides.rubyonrails.org/3_2_release_notes.html

report erratum • discuss

Acknowledgments
You’d think that producing a new edition of a book would be easy. After all,
you already have all the text. It’s just a tweak to some code here and a minor
wording change there, and you’re done. You’d think….
It’s difficult to tell exactly, but our impression is that creating each edition of
Agile Web Development with Rails took about as much effort as the first edition.
Rails is constantly evolving and, as it does, so has this book. Parts of the
Depot application were rewritten several times, and all of the narrative was
updated. The emphasis on REST and the avoidance of features as they become
deprecated have repeatedly changed the structure of the book as what was
once hot became just lukewarm.
So, this book would not exist without a massive amount of help from the
Ruby and Rails communities. To start with, we had a number of incredibly
helpful formal reviewers of drafts of this book:
Jeremy Anderson, Ken Coar, Jeff Cohen, Joel Clermont, Geoff Drake, Pavan
Gorakavi, Michael Jurewitz, Mikel Lindsaar, Paul Rayner, Martijn Reuvers,
Doug Rhoten, Gary Sherman, Davanum Srinivas, Stefan Turalski, and José Valim

Additionally, each edition of this book has been released as a beta book:
early versions were posted as PDFs, and people made comments online. And
comment they did: more than 800 suggestions and bug reports were posted
for this edition alone. The vast majority ended up being incorporated, making
this book immeasurably more useful than it would have been. While thanks
go out to all for supporting the beta book program and for contributing so
much valuable feedback, a number of contributors went well beyond the call
of duty:
Manuel E. Vidaurre Arenas, Seth Arnold, Will Bowlin, Andy Brice, Jason Catena,
Victor Marius Costan, David Hadley, Jason Holloway, David Kapp, Trung LE,
Kristian Riiber Mandrup, mltsy, Steve Nicholson, Jim Puls, Johnathan Ritzi,
Leonel S, Kim Shrier, Don Smith, Joe Straitiff, and Martin Zoller

report erratum • discuss

xvi

•

Acknowledgments

Finally, the Rails core team has been incredibly helpful, answering questions,
checking out code fragments, and fixing bugs. A big “thank you” to the
following:
Scott Barron (htonl), Jamis Buck (minam), Thomas Fuchs (madrobby), Jeremy
Kemper (bitsweat), Yehuda Katz (wycats), Michael Koziarski (nzkoz), Marcel Molina Jr, (noradio), Rick Olson (technoweenie), Nicholas Seckar (Ulysses),
Sam Stephenson (sam), Tobias Lütke (xal), José Valim (josevalim), and Florian
Weber (csshsh)

Sam Ruby
mailto:rubys@intertwingly.net
March 2011

report erratum • discuss

Introduction
Ruby on Rails is a framework that makes it easier to develop, deploy, and
maintain web applications. During the months that followed its initial release,
Rails went from being an unknown toy to being a worldwide phenomenon,
and more important, it has become the framework of choice for the implementation of a wide range of so-called Web 2.0 applications.
Why is that?

Rails Simply Feels Right
First, a large number of developers were frustrated with the technologies they
were using to create web applications. It didn’t seem to matter whether they
were using Java, PHP, or .NET—there was a growing sense that their job was
just too damn hard. And then, suddenly, along came Rails, and Rails was
easier.
But easy on its own doesn’t cut it. We’re talking about professional developers
writing real-world websites. They wanted to feel that the applications they
were developing would stand the test of time—that they were designed and
implemented using modern, professional techniques. So, these developers
dug into Rails and discovered it wasn’t just a tool for hacking out sites.
For example, all Rails applications are implemented using the Model-ViewController (MVC) architecture. Java developers are used to frameworks such
as Tapestry and Struts, which are based on MVC. But Rails takes MVC further:
when you develop in Rails, you start with a working application, there’s a
place for each piece of code, and all the pieces of your application interact in
a standard way.
Professional programmers write tests. And again, Rails delivers. All Rails
applications have testing support baked right in. As you add functionality to
the code, Rails automatically creates test stubs for that functionality. The
framework makes it easy to test applications, and as a result, Rails applications tend to get tested.

report erratum • discuss

xviii

•

Introduction

Rails applications are written in Ruby, a modern, object-oriented scripting
language. Ruby is concise without being unintelligibly terse—you can express
ideas naturally and cleanly in Ruby code. This leads to programs that are
easy to write and (just as important) are easy to read months later.
Rails takes Ruby to the limit, extending it in novel ways that make a programmer’s life easier. This makes our programs shorter and more readable. It also
allows us to perform tasks that would normally be done in external configuration files inside the codebase instead. This makes it far easier to see what’s
happening. The following code defines the model class for a project. Don’t
worry about the details for now. Instead, just think about how much information is being expressed in a few lines of code.
class Project < ActiveRecord::Base
belongs_to :portfolio
has_one
:project_manager
has_many
:milestones
has_many
:deliverables, through: milestones
validates
validates
validates
end

:name, :description, presence: true
:non_disclosure_agreement, acceptance: true
:short_name, uniqueness: true

Two other philosophical underpinnings keep Rails code short and readable:
DRY and convention over configuration. DRY stands for don’t repeat yourself:
every piece of knowledge in a system should be expressed in just one place.
Rails uses the power of Ruby to bring that to life. You’ll find very little duplication in a Rails application; you say what you need to say in one place—a
place often suggested by the conventions of the MVC architecture—and then
move on. For programmers used to other web frameworks, where a simple
change to the schema could involve them in half a dozen or more code
changes, this was a revelation.
Convention over configuration is crucial, too. It means that Rails has sensible
defaults for just about every aspect of knitting together your application.
Follow the conventions, and you can write a Rails application using less code
than a typical Java web application uses in XML configuration. If you need
to override the conventions, Rails makes that easy, too.
Developers coming to Rails found something else, too. Rails isn’t playing
catch-up with the new de facto web standards; it’s helping define them. And
Rails makes it easy for developers to integrate features such as Ajax and
RESTful interfaces into their code, because support is built in. (And if you’re

report erratum • discuss

Introduction

•

xix

not familiar with Ajax and REST interfaces, never fear—we’ll explain them
later in the book.)
Developers are worried about deployment too. They found that with Rails you
can deploy successive releases of your application to any number of servers
with a single command (and roll them back equally easily should the release
prove to be somewhat less than perfect).
Rails was extracted from a real-world, commercial application. It turns out
that the best way to create a framework is to find the central themes in a
specific application and then bottle them up in a generic foundation of code.
When you’re developing your Rails application, you’re starting with half of a
really good application already in place.
But there’s something else to Rails—something that’s hard to describe.
Somehow, it just feels right. Of course, you’ll have to take our word for that
until you write some Rails applications for yourself (which should be in the
next forty-five minutes or so…). That’s what this book is all about.

Rails Is Agile
The title of this book is Agile Web Development with Rails. You may be surprised to discover that we don’t have explicit sections on applying agile
practices X, Y, and Z to Rails coding.
The reason is both simple and subtle. Agility is part of the fabric of Rails.
Let’s look at the values expressed in the Agile Manifesto as a set of four
preferences: 1
•
•
•
•

Individuals and interactions over processes and tools
Working software over comprehensive documentation
Customer collaboration over contract negotiation
Responding to change over following a plan

Rails is all about individuals and interactions. There are no heavy toolsets,
no complex configurations, and no elaborate processes. There are just small
groups of developers, their favorite editors, and chunks of Ruby code. This
leads to transparency; what the developers do is reflected immediately in
what the customer sees. It’s an intrinsically interactive process.
Rails doesn’t denounce documentation. Rails makes it trivially easy to create
HTML documentation for your entire codebase. But the Rails development
1.

http://agilemanifesto.org/. Dave Thomas was one of the seventeen authors of this
document.

report erratum • discuss

xx

•

Introduction

process isn’t driven by documents. You won’t find 500-page specifications at
the heart of a Rails project. Instead, you’ll find a group of users and developers
jointly exploring their need and the possible ways of answering that need.
You’ll find solutions that change as both the developers and the users become
more experienced with the problems they’re trying to solve. You’ll find a
framework that delivers working software early in the development cycle. This
software may be rough around the edges, but it lets the users start to get a
glimpse of what you’ll be delivering.
In this way, Rails encourages customer collaboration. When customers see
just how quickly a Rails project can respond to change, they start to trust
that the team can deliver what’s required, not just what has been requested.
Confrontations are replaced by “What if?” sessions.
That’s all tied to the idea of being able to respond to change. The strong, almost
obsessive, way that Rails honors the DRY principle means that changes to
Rails applications impact a lot less code than the same changes would in
other frameworks. And since Rails applications are written in Ruby, where
concepts can be expressed accurately and concisely, changes tend to be localized and easy to write. The deep emphasis on both unit and functional testing,
along with support for test fixtures and stubs during testing, gives developers
the safety net they need when making those changes. With a good set of tests
in place, changes are less nerve-racking.
Rather than constantly trying to tie Rails processes to the agile principles,
we’ve decided to let the framework speak for itself. As you read through the
tutorial chapters, try to imagine yourself developing web applications this
way: working alongside your customers and jointly determining priorities and
solutions to problems. Then, as you read the more advanced concepts that
follow in Part III, see how the underlying structure of Rails can enable you to
meet your customers’ needs faster and with less ceremony.
One last point about agility and Rails: although it’s probably unprofessional
to mention this, think how much fun the coding will be.

Who This Book Is For
This book is for programmers looking to build and deploy web-based applications. This includes application programmers who are new to Rails (and
perhaps even new to Ruby) and ones who are familiar with the basics but
want a more in-depth understanding of Rails.
We presume some familiarity with HTML, Cascading Style Sheets (CSS), and
JavaScript, in other words, the ability to view source on web pages. You need

report erratum • discuss

Introduction

•

xxi

not be an expert on these subjects; the most you will be expected to do is to
copy and paste material from the book, all of which can be downloaded.

How To Read This Book
The first part of this book makes sure you are ready. By the time you are
done with it, you will have been introduced to Ruby (the language), you will
have been exposed to an overview of Rails itself, you will have Ruby and Rails
installed, and you will have verified the installation with a simple example.
The next part takes you through the concepts behind Rails via an extended
example; we build a simple online store. It doesn’t take you one by one through
each component of Rails (“here is a chapter on models, here is a chapter on
views,” and so forth). These components are designed to work together, and
each chapter in this section tackles a specific set of related tasks that involve
a number of these components working together.
Most folks seem to enjoy building the application along with the book. If you
don’t want to do all that typing, you can cheat and download the source code
(a compressed tar archive or a zip file).2 This download contains separate sets
of source code for Rails 3.0 Rails 3.1, and Rails 3.2. The files you will want
will be in a rails32 directory. See the README-FIRST file for more details.
Part III, Rails in Depth, on page 253 surveys the entire Rails ecosystem. This
starts with the functions and facilities of Rails that you will now be familiar
with. It then covers a number of key dependencies that the Rails framework
makes use of that contribute directly to the overall functionality that the Rails
framework delivers. Finally, there is a survey of a number of popular plugins
that augment the Rails framework and make Rails an open ecosystem rather
than merely a framework.
Along the way, you’ll see various conventions we’ve adopted.
Ruby Tips
Although you need to know Ruby to write Rails applications, we realize
that many folks reading this book will be learning both Ruby and Rails
at the same time. You will find a (very) brief introduction to the Ruby
language in Chapter 4, Introduction to Ruby, on page 37. When we use a
Ruby-specific construct for the first time, we’ll cross-reference it to that
chapter. For example, this paragraph contains a gratuitous use of :name,
a Ruby symbol. In formats that support margins, you’ll see a reference
to where symbols are explained.

2.

:name
↪ on page 38

http://pragprog.com/titles/rails4/source_code has the links for the downloads.

report erratum • discuss

xxii

•

Introduction

Live Code
Most of the code snippets we show come from full-length, running examples that you can download.
To help you find your way, if a code listing can be found in the download,
there’ll be a bar before the snippet (just like the one here).
Download rails32/demo1/app/controllers/say_controller.rb
class SayController < ApplicationController
➤
def hello
➤
end
def goodbye
end
end

This contains the path to the code within the download. If you’re reading
the ebook version of this book and your ebook viewer supports hyperlinks,
you can click the bar, and the code should appear in a browser window.
Some browsers (such as Safari) will mistakenly try to interpret some of
the templates as HTML. If this happens, view the source of the page to
see the real source code.
And in some cases involving the modification of an existing file where the
lines to be changed may not be immediately obvious, you will also see
some helpful little triangles on the left of the lines that you will need to
change. Two such lines are indicated in the previous code.
David Says…
Every now and then you’ll come across a David Says… sidebar. Here’s
where David Heinemeier Hansson gives you the real scoop on some particular aspect of Rails—rationales, tricks, recommendations, and more.
Because he’s the fellow who invented Rails, these are the sections to read
if you want to become a Rails pro.
Joe Asks…
Joe, the mythical developer, sometimes pops up to ask questions about
stuff we talk about in the text. We answer these questions as we go along.
This book isn’t meant to be a reference manual for Rails. Our experience is
that reference manuals are not the way most people learn. Instead, we show
most of the modules and many of their methods, either by example or narratively in the text, in the context of how these components are used and how
they fit together.

report erratum • discuss

Introduction

•

xxiii

Nor do we have hundreds of pages of API listings. There’s a good reason for
this—you get that documentation whenever you install Rails, and it’s guaranteed to be more up-to-date than the material in this book. If you install Rails
using RubyGems (which we recommend), simply start the gem documentation
server (using the command gem server), and you can access all the Rails APIs
by pointing your browser at http://localhost:8808. You will find out in A Place for
Documentation, on page 259 how to build even more documentation and guides.
In addition, you will see that Rails itself helps you by producing responses
that clearly identify any error found, as well as traces that tell you not only
what point the error was found but how you got there. You can see an example
in Figure 17, Our application spills its guts., on page 121. If you need additional
information, peek ahead to Section 10.2, Iteration E2: Handling Errors, on
page 119 to see how to insert logging statements.
Should you get really stuck, there are plenty of online resources to help. In
addition to the code listings mentioned, there is a forum,3 where you can ask
questions and share experiences; an errata page,4 where you can report bugs;
and a wiki,5 where you can discuss the exercises found throughout the book.
These resources are shared resources. Feel free to post not only questions
and problems to the forum and wiki but also any suggestions and answers
that you may have to questions others may have posted.
Let’s get started! The first steps are to install Ruby and Rails and to verify
the installation with a simple demonstration.

3.
4.
5.

http://forums.pragprog.com/forums/148
http://www.pragprog.com/titles/rails4/errata
http://www.pragprog.com/wikis/wiki/RailsPlayTime

report erratum • discuss

Part I

Getting Started

In this chapter, we’ll see
• installing Ruby, RubyGems, SQLite3, and Rails; and
• development environments and tools.

CHAPTER 1

Installing Rails
In Part I of this book, we’ll introduce you to both the Ruby language and the
Rails framework. But we can’t get anywhere until you’ve installed both and
verified that they are operating correctly.
To get Rails running on your system, you’ll need the following:
• A Ruby interpreter. Rails is written in Ruby, and you’ll be writing your
applications in Ruby too. Rails 3.2 requires Ruby version 1.9.3, 1.9.2, or
1.8.7. It is known not to work on Ruby versions 1.8.6 and Ruby 1.9.1, or
on patch levels 248 and 249 of Ruby 1.8.7.
The differences between versions of Ruby that affect this book are described in the sidebar on page 4.
• The Ruby packaging system, namely, RubyGems. This edition is based
on RubyGems version 1.8.10.
• Ruby on Rails. This book was written using Rails version 3.2 (specifically
Rails 3.2.0 at the current time).
• A JavaScript interpreter. Both Microsoft Windows and Mac OS X have
JavaScript interpreters built in, and Rails will use the version already on
your system. On other operating systems, you may need to install a
JavaScript interpreter separately.
• Some libraries, depending on the operating system.
• A database. We’re using both SQLite 3 and MySQL 5.1 in this book.
For a development machine, that’s about all you’ll need (apart from an editor,
and we’ll talk about editors separately). However, if you are going to deploy
your application, you will also need to install a production web server (as a
minimum) along with some support code to let Rails run efficiently. We have

report erratum • discuss

4

•

Chapter 1. Installing Rails

Choosing a Ruby version
This book is based on Ruby 1.9.3.
While Rails 3.2 works with Ruby 1.8.7 as well as with Ruby 1.9.2 and 1.9.3, the Rails
core team recommends Ruby 1.9.2 or later for all new Rails applications. Ruby 1.9.2
has improved syntax and performance. Furthermore, support for Ruby 1.8.7 is expected to be dropped in Rails 4.0.
Should you decide to install or stick with Ruby 1.8.7 instead, some of the generated
scaffolding will use the “old style” hash syntax. Here’s an example of the “new style”
hash syntax:
redirect_to @cart, notice: 'Cart was successfully created.'

Here’s what Rails 3.2 will generate instead if you are using Ruby 1.8.7:
redirect_to @cart, :notice => 'Cart was successfully created.'

Note that the position of the colon character changed and the addition of an arrow
formed using an equals sign and a greater-than sign.
The other change that you will need to be aware of is that the format of the output
of tests has changed.
If you keep these two factors in mind, you can use this book to learn Rails 3.2 using
Ruby 1.8.7.

a whole chapter devoted to this, starting in Chapter 16, Task K: Deployment
and Production, on page 229, so we won’t talk about it more here.
So, how do you get all this installed? It depends on your operating system...

1.1

Installing on Windows
The easiest way to install Rails on Windows is by using the RailsInstaller1package. At the time of this writing, the latest version of RailsInstaller is version
2.0, which includes Ruby 1.9.2 and Rails 3.1. Until a new version is released
that supports Rails 3.2 and Ruby 1.9.3, feel free to use version 2.0 of
RailsInstaller to get you started.
Base installation is a snap. After you download, click Run, then click Next.
Select “I accept the License” (after reading it carefully of course), click Next,
Install, and Finish.
This opens a command window and prompts you for your name and email.
This is only to set up the git version control system. For the purposes of the

1.

http://railsinstaller.org/

report erratum • discuss

Installing on Mac OS X

•

5

exercises in this book, you won’t need to worry about the ssh key that is
generated.
Close this window and open a new command prompt by selecting the Windows
Start, Run..., enter cmd, and click OK.
If you have trouble, try looking for suggestions on the Troubleshooting page
on the RubyInstaller site.2
As long as the version of RailsInstaller you used installed a version of Ruby
that is 1.9.2 or later, there is no need to upgrade to a later version of Ruby.
Please do skip forward to Section 1.4, Choosing a Rails Version, on page 8
to ensure that the version of Rails you have installed matches the version
described in this printing. See you there.

1.2

Installing on Mac OS X
Since neither Snow Leopard nor Lion prepackage Ruby 1.9.3, you’ll need to
download and build it yourself. The easiest way we’ve found to do this is to
use RVM. Installation of RVM is described on the RVM site.3 An overview of
the steps is included here.
First, you’ll need to make sure you have Xcode 3 or later installed. If you’re
running Mac OS X 10.7 (Lion), you can download Xcode 4.14 as a free app
from the Mac App Store and it’ll be automatically installed on your Mac. If
you’re running Mac OS X 10.6 (Snow Leopard), you’ll need to install Xcode
from the Snow Leopard DVD that came with your Mac. You’ll find Xcode in
the Optional Installs directory. Verify your installation by running the following
command:
$ xcodebuild -version

If you have Xcode version 3 installed, you’ll need to install the Git version
control system separately. Download5 and install the version that matches
your operating system and hardware. Verify your installation by running the
following command:
$ git --version

Next, install RVM itself:
$ bash < <(curl -s https://rvm.beginrescueend.com/install/rvm)

2.
3.
4.
5.

https://github.com/oneclick/rubyinstaller/wiki/Troubleshooting
https://rvm.beginrescueend.com/rvm/install/
http://itunes.apple.com/us/app/xcode/id448457090?mt=12
http://code.google.com/p/git-osx-installer/downloads/list?can=3

report erratum • discuss

6

•

Chapter 1. Installing Rails

Follow the installation instructions that this command outputs. In particular,
you’ll need to append RVM function setup instructions to your .bash_profile:
$ echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] && \
. "$HOME/.rvm/scripts/rvm"' >> ~/.bash_profile

Exit your command window or Terminal application and open a new one.
This will cause your .bash_profile to be reloaded. In this new window, install the
Ruby interpreter itself:
$ rvm install 1.9.3

The preceding step will take a while as it downloads, configures, and compiles
the necessary executables. Once it completes, use that environment, and
install rails:
$ rvm use 1.9.3
$ gem install rails

With the exception of the rvm use statement, each of the above instructions
need only be done once. The rvm use statement needs to be repeated each time
you open a shell window. The use keyword is optional, so you can abbreviate
this to rvm 1.9.3. You can also choose to make it the default Ruby interpreter
for new terminal sessions with the following command:
$ rvm --default 1.9.3

You can verify successful installation using the following command:
$ rails -v

If you have trouble, try the suggestions listed under the Troubleshooting Your
Install heading on the rvm site.6
OK, you OS X users are done. You can skip forward to join the Windows users
in Section 1.4, Choosing a Rails Version, on page 8. See you there.

1.3

Installing on Linux
Start with your platform’s native package management system, be it apt-get,
dpkg, portage, rpm, rug, synaptic, up2date, or yum.
The first step is to install the necessary dependencies. The following instructions are for Ubuntu 11.10, Oneiric Ocelot; if you are running a different
operating system you may need to adjust both the command and the package
names:
$ sudo apt-get install apache2 curl git libmysqlclient-dev mysql-server nodejs

6.

https://rvm.beginrescueend.com/rvm/install

report erratum • discuss

Installing on Linux

•

7

You’ll be prompted for a root password for your mysql server. If you leave it
blank, you’ll be prompted multiple times. If you specify a password, you’ll
need to use that password when you create a database in Iteration K1 on
page 234.
Since Ubuntu 11.10 doesn’t prepackage Ruby 1.9.3, you’ll need to download
and build it. The easiest way we’ve found to do this is to use RVM. Installation
of RVM is described on the RVM site.7 An overview of the steps is included
here.
First, install RVM itself:
$ bash < <(curl -s https://rvm.beginrescueend.com/install/rvm)

Follow the installation instructions that are output by this command. In
particular, you’ll need to append RVM function setup instructions to your
.bash_profile:
$ echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] && \
. "$HOME/.rvm/scripts/rvm"' >> ~/.bash_profile

Exit your command window or Terminal application and open a new one.
This causes your .bash_profile to be reloaded.
Execute the following command, which provides additional installation
instructions tailored to your specific operating system:
$ rvm requirements

Look for the line that tells you how to install the necessary OS dependencies
for Ruby (MRI). Once you complete those instructions, you can proceed to
install the Ruby interpreter itself:
$ rvm install 1.9.3

The preceding step will take a while as it downloads, configures, and compiles
the necessary executables. Once it completes, use that environment, and
install rails:
$ rvm use 1.9.3
$ gem install rails

With the exception of the rvm use statement, each of the above instructions
need only be done once. The rvm use statement needs to be repeated each time
you open a shell window. The use keyword is optional, so you can abbreviate

7.

https://rvm.beginrescueend.com/rvm/install/

report erratum • discuss

8

•

Chapter 1. Installing Rails

this to rvm 1.9.3. You can also chose to make it the default Ruby interpreter
for new terminal sessions with the following command:
$ rvm --default 1.9.3

You can verify successful installation using the following command:
$ rails -v

If you have trouble, try the suggestions listed under the Troubleshooting Your
Install heading on the RVM site.8
At this point, we’ve covered Windows, Mac OS X, and Linux. Instructions after
this point are common to all three operating systems.

1.4

Choosing a Rails Version
The previous instructions helped you install the latest version of Rails. But
occasionally you might not want to run the latest version. For example, you
might want to run the version of Rails that matches this version used to
develop this book so that you can be absolutely confident that the output
and examples exactly match. Or perhaps you are developing on one machine
but intending to deploy on another machine that contains a version of Rails
that you don’t have any control over.
If either of these situations applies to you, you need to be aware of a few
things. For starters, you can find out all the versions of Rails you have
installed using the gem command:
$ gem list --local rails

You can also verify what version of Rails you are running as the default by
using the rails --version command. It should return 3.2.0 or newer.
Installing another version of Rails is also done via the gem command. Depending on your operating system, you might need to preface the command with
sudo.
$ gem install rails --version 3.2.0

Now, having multiple versions of Rails wouldn’t do anybody any good unless
there were a way to pick one. As luck would have it, there is. On any rails
command, you can control which version of Rails is used by inserting the full
version number surrounded by underscores before the first parameter of the
command:
$ rails _3.2.0_ --version

8.

https://rvm.beginrescueend.com/rvm/install

report erratum • discuss

Setting Up Your Development Environment

•

9

This is particularly handy when you create a new application, because once
you create an application with a specific version of Rails, it will continue to
use that version of Rails—even if newer versions are installed on the system—until you decide it is time to upgrade. To upgrade, simply update the
version number in the Gemfile that is in the root directory of your application,
and run bundle install. We will cover this command in greater depth in Section
25.3, Managing Dependencies with Bundler, on page 423.

1.5

Setting Up Your Development Environment
The day-to-day business of writing Rails programs is pretty straightforward.
Everyone works differently; here’s how we work.

The Command Line
We do a lot of work at the command line. Although there are an increasing
number of GUI tools that help generate and manage a Rails application, we
find the command line is still the most powerful place to be. It’s worth
spending a little while getting familiar with the command line on your operating system. Find out how to use it to edit commands that you’re typing, how
to search for and edit previous commands, and how to complete the names
of files and commands as you type.
So-called tab completion is standard on Unix shells such as Bash and zsh.
It allows you to type the first few characters of a filename, hit Tab , and have
the shell look for and complete the name based on matching files.

Version Control
We keep all our work in a version control system (currently Git). We make a
point of checking a new Rails project into Git when we create it and committing
changes once we have passed the tests. We normally commit to the repository
many times an hour.
If you’re working on a Rails project with other people, consider setting up a
continuous integration (CI) system. When anyone checks in changes, the CI
system will check out a fresh copy of the application and run all the tests.
It’s a simple way to ensure that accidental breakages get immediate attention.
You can also set up your CI system so that your customers can use it to play
with the bleeding-edge version of your application. This kind of transparency
is a great way of ensuring that your project isn’t going off the tracks.

report erratum • discuss

10

•

Chapter 1. Installing Rails

Where’s My IDE?
If you’re coming to Ruby and Rails from languages such as C# and Java, you may
be wondering about IDEs. After all, we all know that it’s impossible to code modern
applications without at least 100MB of IDE supporting our every keystroke. For you
enlightened ones, here’s the point in the book where we recommend you sit
down—ideally propped up on each side by a pile of framework references and 1,000page Made Easy books.
It may surprise you to know that most Rails developers don’t use fully fledged IDEs
for Ruby or Rails (although some of the environments come close). Indeed, many Rails
developers use plain old editors. And it turns out that this isn’t as much of a problem
as you might think. With other, less expressive languages, programmers rely on IDEs
to do much of the grunt work for them, because IDEs do code generation, assist with
navigation, and compile incrementally to give early warning of errors.
With Ruby, however, much of this support just isn’t necessary. Editors such as
TextMate and BBEdit give you 90 percent of what you’d get from an IDE but are far
lighter weight. Just about the only useful IDE facility that’s missing is refactoring
support.

Editors
We write our Rails programs using a programmer’s editor. We’ve found over
the years that different editors work best with different languages and environments. For example, Dave originally wrote this chapter using Emacs,
because he thinks that its Filladapt mode is unsurpassed when it comes to
neatly formatting XML as he types. Sam updated the chapter using Vim. But
many think that neither Emacs nor Vim is ideal for Rails development and
prefer to use TextMate. Although the choice of editor is a personal one, here
are some suggestions of features to look for in a Rails editor:
• Support for syntax highlighting of Ruby and HTML. Ideally support for
.erb files (a Rails file format that embeds Ruby snippets within HTML).
• Support of automatic indentation and reindentation of Ruby source. This
is more than an aesthetic feature: having an editor indent your program
as you type is the best way of spotting bad nesting in your code. Being
able to reindent is important when you refactor your code and move stuff.
(TextMate’s ability to reindent when it pastes code from the clipboard is
very convenient.)
• Support for insertion of common Ruby and Rails constructs. You’ll be
writing lots of short methods, and if the IDE creates method skeletons
with a keystroke or two, you can concentrate on the interesting stuff
inside.

report erratum • discuss

Setting Up Your Development Environment

•

11

• Good file navigation. As you’ll see, Rails applications are spread across
many files: a newly created Rails application enters the world containing
forty-six files spread across thirty-four directories. That’s before you’ve
written a thing.
You need an environment that helps you navigate quickly between these.
You’ll add a line to a controller to load a value, switch to the view to add
a line to display it, and then switch to the test to verify you did it all right.
Something like Notepad, where you traverse a File Open dialog box to
select each file to edit, just won’t cut it. We prefer a combination of a tree
view of files in a sidebar, a small set of keystrokes that help us find a file
(or files) in a directory tree by name, and some built-in smarts that know
how to navigate (say) between a controller action and the corresponding
view.
• Name completion. Names in Rails tend to be long. A nice editor will let
you type the first few characters and then suggest possible completions
to you at the touch of a key.
We hesitate to recommend specific editors because we’ve used only a few in
earnest and we’ll undoubtedly leave someone’s favorite editor off the list.
Nevertheless, to help you get started with something other than Notepad,
here are some suggestions:
• The Ruby and Rails editor of choice on Mac OS X is TextMate (http://
macromates.com/).
• For those who would otherwise like to use TextMate but happen to be
using Windows, E-TextEditor (http://e-texteditor.com/) provides “the
Power of TextMate on Windows.”
• Aptana RadRails (http://www.aptana.com/products/radrails) is an integrated Rails development environment that runs in Aptana Studio and
Eclipse. It runs on Windows, Mac OS X, and Linux. It won an award for
being the best open source developer tool based on Eclipse in 2006, and
Aptana became the home for the project in 2007.
• NetBeans IDE 6.5 (http://netbeans.org/features/ruby/index.html) supports Windows, Mac OS X, Solaris, and Linux. It’s available in a download
bundle with Ruby support or as a Ruby pack that can be downloaded
later. In addition to specific support for Rails 2.0, Rake targets, and
database migrations, it supports a Rails code generator graphical wizard
and quick navigation from a Rails action to its corresponding view.
• jEdit (http://www.jedit.org/) is a fully featured editor with support for
Ruby. It has extensive plugin support.

report erratum • discuss

12

•

Chapter 1. Installing Rails

• Komodo (http://www.activestate.com/komodo-ide) is ActiveState’s IDE
for dynamic languages, including Ruby.
• RubyMine (http://www.jetbrains.com/ruby/features/index.html) is a
commercial IDE for Ruby and is available for free to qualified educational
and open source projects. It runs on Windows, Mac OS X, and Linux.
Ask experienced developers who use your kind of operating system which
editor they use. Spend a week or so trying alternatives before settling in.

The Desktop
We’re not going to tell you how to organize your desktop while working with
Rails, but we will describe what we do.
Most of the time, we’re writing code, running tests, and poking at an application in a browser. So, our main development desktop has an editor window
and a browser window permanently open. We also want to keep an eye on
the logging that’s generated by the application, so we keep a terminal window
open. In it, we use tail -f to scroll the contents of the log file as it’s updated.
We normally run this window with a very small font so it takes up less
space—if we see something interesting flash by, we zoom it up to investigate.
We also need access to the Rails API documentation, which we view in a
browser. In the introduction, we talked about using the gem server command
to run a local web server containing the Rails documentation. This is convenient, but it unfortunately splits the Rails documentation across a number
of separate documentation trees. If you’re online, you can use http://api.
rubyonrails.org/ to see a consolidated view of all the Rails documentation in
one place.

1.6

Rails and Databases
The examples in this book were written using SQLite 3 (version 3.7.4 or
thereabouts). If you want to follow along with our code, it’s probably simplest
if you use SQLite 3 too. If you decide to use something else, it won’t be a
major problem. You may have to make minor adjustments to any explicit SQL
in our code, but Rails pretty much eliminates database-specific SQL from
applications.
If you want to connect to a database other than SQLite 3, Rails also works
with DB2, MySQL, Oracle, Postgres, Firebird, and SQL Server. For all but
SQLite 3, you’ll need to install a database driver, a library that Rails can use
to connect to and use your database engine. This section contains links to
instructions to get that done.

report erratum • discuss

Rails and Databases

•

13

Creating Your Own Rails API Documentation
You can create your own local version of the consolidated Rails API documentation.
Just type the following commands at a command prompt:
rails_apps> rails new dummy_app
rails_apps> cd dummy_app
dummy_app> rake doc:rails

The last step takes a while. When it finishes, you’ll have the Rails API documentation
in a directory tree starting at doc/api. We suggest moving this folder to your desktop
and then deleting the dummy_app tree.
To view the Rails API documentation, open the location doc/api/index.html with your
browser.

The database drivers are all written in C and are primarily distributed in
source form. If you don’t want to bother building a driver from source, take
a careful look at the driver’s website. Many times you’ll find that the author
also distributes binary versions.
If you can’t find a binary version or if you’d rather build from source anyway,
you’ll need a development environment on your machine to build the library.
Under Windows, this means having a copy of Visual C++. Under Linux, you’ll
need gcc and friends (but these will likely already be installed).
Under OS X, you’ll need to install the developer tools (they come with the
operating system but aren’t installed by default). You’ll also need to install
your database driver into the correct version of Ruby. If you installed your
own copy of Ruby, bypassing the built-in one, it is important to remember to
have this version of Ruby first in your path when building and installing the
database driver. You can use the command which ruby to make sure you’re not
running Ruby from /usr/bin.
The following are the available database adapters and the links to their
respective home pages:
DB2

http://raa.ruby-lang.org/project/ruby-db2 or http://rubyforge.org/projects/rubyibm

Firebird

http://rubyforge.org/projects/fireruby/

MySQL

http://www.tmtm.org/en/mysql/ruby/

Oracle

http://rubyforge.org/projects/ruby-oci8

Postgres

http://rubyforge.org/projects/ruby-pg

SQL Server

https://github.com/rails-sqlserver

report erratum • discuss

•

14

Chapter 1. Installing Rails

SQLite

http://rubyforge.org/projects/sqlite-ruby

A pure-Ruby version of the Postgres adapter is available. Download postgres-pr
from the Ruby-DBI page at http://rubyforge.org/projects/postgres-pr.
MySQL and SQLite adapters are also available for download as RubyGems
(mysql2 and sqlite3, respectively).

1.7

What We Just Did
•
•
•
•

We
We
We
We

installed (or upgraded) the Ruby language.
installed (or upgraded) the Rails framework.
installed (or upgraded) the SQLite3 and MySQL databases.
selected an editor.

Now that we have Rails installed, let’s use it. It’s time to move on to the next
chapter where we create our first application.

report erratum • discuss

In this chapter, we’ll see
• creating a new application,
• starting the server,
• accessing the server from a browser,
• producing dynamic content,
• adding hypertext links, and
• passing data from the controller to the view.

CHAPTER 2

Instant Gratification
Let’s write a simple application to verify we have Rails snugly installed on our
machines. Along the way, we’ll get a peek at the way Rails applications work.

2.1

Creating a New Application
When you install the Rails framework, you also get a new command-line tool,
rails, that is used to construct each new Rails application you write.
Why do we need a tool to do this? Why can’t we just hack away in our favorite
editor and create the source for our application from scratch? Well, we could
just hack. After all, a Rails application is just Ruby source code. But Rails
also does a lot of magic behind the curtain to get our applications to work
with a minimum of explicit configuration. To get this magic to work, Rails
needs to find all the various components of your application. As we’ll see later
(in Section 18.1, Where Things Go, on page 255), this means we need to create
a specific directory structure, slotting the code we write into the appropriate
places. The rails command simply creates this directory structure for us and
populates it with some standard Rails code.
To create your first Rails application, pop open a shell window, and navigate
to a place in your filesystem where you want to create your application’s
directory structure. In our example, we’ll be creating our projects in a directory called work. In that directory, use the rails command to create an application
called demo. Be slightly careful here—if you have an existing directory called
demo, you will be asked whether you want to overwrite any existing files. (Note:
if you want to specify which Rails version to use, as described in Section 1.4,
Choosing a Rails Version, on page 8, now would be the time to do so.)
rubys> cd work
work> rails new demo
create
create README

report erratum • discuss

16

•

Chapter 2. Instant Gratification

create Rakefile
create config.ru
:
:
:
create vendor/plugins
create vendor/plugins/.gitkeep
run bundle install
Fetching source index for http://rubygems.org/
:
:
:
Your bundle is complete!
Use `bundle show [gemname]` to see where a bundled gem is installed.
work>

The command has created a directory named demo. Pop down into that directory, and list its contents (using ls on a Unix box or dir under Windows). You
should see a bunch of files and subdirectories:
work> cd demo
demo> ls -p
app/
config.ru doc/
Gemfile.lock
config/ db/
Gemfile lib/

log/
Rakefile script/ tmp/
public/ README
test/
vendor/

All these directories (and the files they contain) can be intimidating to start
with, but we can ignore most of them for now. In this chapter, we’ll use only
one of them directly: the app directory, where we’ll write our application.
Examine your installation using the following command:
demo> rake about

If you get a Ruby version other than 1.9.3, please reread Choosing a Ruby
version, on page 4. If you get a Rails version other than 3.2.0, please reread
Section 1.4, Choosing a Rails Version, on page 8.
This command will also detect common installation errors. For example, if it
can’t find a JavaScript runtime, it will provide you with a link to available
runtimes. If you see a bunch of messages concerning already initialized
constants or possible conflict with an extension, consider deleting the demo
directory, creating a separate RVM gemset,1 and starting over. If that doesn’t
work, use bundle exec2 to run rake commands.
Once you get rake about working, you have everything you need to start a standalone web server that can run our newly created Rails application. So, without
further ado, let’s start our demo application:

1.
2.

http://beginrescueend.com/gemsets/basics/
http://gembundler.com/man/bundle-exec.1.html

report erratum • discuss

Hello, Rails!

•

17

demo> rails server
=> Booting WEBrick
=> Rails 3.2.0 application starting on http://0.0.0.0:3000
=> Call with -d to detach
=> Ctrl-C to shutdown server
[2011-07-23 10:38:18] INFO WEBrick 1.3.1
[2011-07-23 10:38:18] INFO ruby 1.9.3 (2011-10-30) [x86_64-linux]
[2011-07-23 10:38:18] INFO WEBrick::HTTPServer#start: pid=6044 port=3000

Which web server is run depends on what servers you have installed. WEBrick
is a pure-Ruby web server that is distributed with Ruby itself and therefore
is guaranteed to be available. However, if another web server is installed on
your system (and Rails can find it), the rails server command may use it in
preference to WEBrick. You can force Rails to use WEBrick by providing an
option to the rails command:
demo> rails server webrick

As the last line of the startup tracing indicates, we just started a web server
on port 3000. The 0.0.0.0 part of the address means that WEBrick will accept
connections on all interfaces. On Dave’s OS X system, that means both local
interfaces (127.0.0.1 and ::1) and his LAN connection. We can access the
application by pointing a browser at the URL http://localhost:3000. The result
is shown in Figure 1, Newly created Rails application, on page 18.
If you look at the window where you started the server, you’ll see tracing
showing you started the application. We’re going to leave the server running
in this console window. Later, as we write application code and run it via our
browser, we’ll be able to use this console window to trace the incoming
requests. When the time comes to shut down your application, you can press
Ctrl-C in this window to stop WEBrick. (Don’t do that yet—we’ll be using this
particular application in a minute.)
At this point, we have a new application running, but it has none of our code
in it. Let’s rectify this situation.

2.2

Hello, Rails!
We can’t help it—we just have to write a “Hello, World!” program to try a new
system. Let’s start by creating a simple application that sends our cheery
greeting to a browser. After we get that working, we will embellish it with the
current time and links.
As we’ll explore further in Chapter 3, The Architecture of Rails Applications,
on page 29, Rails is a Model-View-Controller framework. Rails accepts incoming requests from a browser, decodes the request to find a controller, and

report erratum • discuss

18

•

Chapter 2. Instant Gratification

Figure 1—Newly created Rails application

calls an action method in that controller. The controller then invokes a particular view to display the results to the user. The good news is that Rails
takes care of most of the internal plumbing that links all these actions. To
write our simple “Hello, World!” application, we need code for a controller and
a view, and we need a route to connect the two. We don’t need code for a
model, because we’re not dealing with any data. Let’s start with the controller.
In the same way that we used the rails command to create a new Rails application, we can also use a generator script to create a new controller for our
project. This command is called rails generate. So, to create a controller called
say, we make sure we’re in the demo directory and run the command, passing
in the name of the controller we want to create and the names of the actions
we intend for this controller to support:
demo> rails generate controller Say hello goodbye
create app/controllers/say_controller.rb
route get "say/goodbye"
route get "say/hello"
invoke erb

report erratum • discuss

Hello, Rails!
create
create
create
invoke
create
invoke
create
invoke
create
invoke
invoke
create
invoke
create

•

19

app/views/say
app/views/say/hello.html.erb
app/views/say/goodbye.html.erb
test_unit
test/functional/say_controller_test.rb
helper
app/helpers/say_helper.rb
test_unit
test/unit/helpers/say_helper_test.rb
assets
coffee
app/assets/javascripts/say.js.coffee
scss
app/assets/stylesheets/say.css.scss

The rails generate command logs the files and directories it examines, noting
when it adds new Ruby scripts or directories to your application. For now,
we’re interested in one of these scripts and (in a minute) the .html.erb files.
The first source file we’ll be looking at is the controller. You’ll find it in the
file app/controllers/say_controller.rb. Let’s take a look at it:
defining classes

Download rails32/demo1/app/controllers/say_controller.rb
class SayController < ApplicationController
def hello
end

↪ on page 46

def goodbye
end
end

Pretty minimal, eh? SayController is a class that inherits from ApplicationController,
so it automatically gets all the default controller behavior. What does this
code have to do? For now, it does nothing—we simply have an empty action
method named hello. To understand why this method is named this way, we
need to look at the way Rails handles requests.

Rails and Request URLs
Like any other web application, a Rails application appears to its users to be
associated with a URL. When you point your browser at that URL, you are
talking to the application code, which generates a response to you.
Let’s try it now. Navigate to the URL http://localhost:3000/say/hello in a
browser window. (Note that in the development environment we don’t have
any application string at the front of the path—we route directly to the controller.) You’ll see something that looks like this:

report erratum • discuss

20

•

Chapter 2. Instant Gratification

Our First Action
At this point, we can see not only that have we connected the URL to our
controller but also that Rails is pointing the way to our next step, namely, to
tell Rails what to display. That’s where views come in. Remember when we
ran the script to create the new controller? That command added six files and
a new directory to our application. That directory contains the template files
for the controller’s views. In our case, we created a controller named say, so
the views will be in the directory app/views/say.
By default, Rails looks for templates in a file with the same name as the action
it’s handling. In our case, that means we need to replace a file called hello.html.erb in the directory app/views/say. (Why .html.erb? We’ll explain in a minute.)
For now, let’s just put some basic HTML in there:
Download rails32/demo1/app/views/say/hello.html.erb
<h1>Hello from Rails!</h1>

Save the file hello.html.erb, and refresh your browser window. You should see
it display our friendly greeting:

In total, we’ve looked at two files in our Rails application tree. We looked at
the controller, and we modified a template to display a page in the browser.
These files live in standard locations in the Rails hierarchy: controllers go
into app/controllers, and views go into subdirectories of app/views. See Figure 2,
Standard locations for controllers and views, on page 21.

report erratum • discuss

Hello, Rails!

demo/
app/

•

21

class SayController < ApplicationController
def hello
end
end

controllers/
say_controller.rb
models/
views/
say/
hello.html.erb

<html>
<head>
<title>Hello, Rails!</title>
</head>
<body>
<h1>Hello from Rails!</h1>
</body>
</html>

Figure 2—Standard locations for controllers and views

Making It Dynamic
So far, our Rails application is pretty boring—it just displays a static page.
To make it more dynamic, let’s have it show the current time each time it
displays the page.
To do this, we need to change the template file in the view—it now needs to
include the time as a string. That raises two questions. First, how do we add
dynamic content to a template? Second, where do we get the time from?

Dynamic Content
There are many ways of creating dynamic templates in Rails. The most common way, which we’ll use here, is to embed Ruby code in the template itself.
That’s why we named our template file hello.html.erb; the .html.erb suffix tells
Rails to expand the content in the file using a system called ERB.
ERB is a filter that is installed as part of the Rails installation that takes an
.erb file and outputs a transformed version. The output file is often HTML in

Rails, but it can be anything. Normal content is passed through without being
changed. However, content between <%= and %> is interpreted as Ruby code
and executed. The result of that execution is converted into a string, and that
value is substituted in the file in place of the <%=…%> sequence. For example,
change hello.html.erb to display the current time:
Download rails32/demo2/app/views/say/hello.html.erb
<h1>Hello from Rails!</h1>
➤ <p>
➤
It is now <%= Time.now %>
➤ </p>

report erratum • discuss

22

•

Chapter 2. Instant Gratification

When we refresh our browser window, we see the time displayed using Ruby’s
standard format: 3

Notice that if you hit Refresh in your browser, the time updates each time
the page is displayed. It looks as if we’re really generating dynamic content.

Adding the Time
Our original problem was to display the time to users of our application. We
now know how to make our application display dynamic data. The second
issue we have to address is working out where to get the time from.
We’ve shown that the approach of embedding a call to Ruby’s Time.now() method
in our hello.html.erb template works. Each time we access this page, the user
will see the current time substituted into the body of the response. And for
our trivial application, that might be good enough. In general, though, we
probably want to do something slightly different. We’ll move the determination
of the time to be displayed into the controller and leave the view with the
simple job of displaying it. We’ll change our action method in the controller
to set the time value into an instance variable called @time:
instance variable
↪ on page 46

Download rails32/demo3/app/controllers/say_controller.rb
class SayController < ApplicationController
def hello
➤
@time = Time.now
end
def goodbye
end
end

In the .html.erb template, we’ll use this instance variable to substitute the time
into the output:

3.

With Ruby 1.8.7, the standard format was different, and looks more like the following:
Mon Jul 25 09:43:25 -0400 2011.

report erratum • discuss

Hello, Rails!

•

23

Making Development Easier
You might have noticed something about the development we’ve been doing so far.
As we’ve been adding code to our application, we haven’t had to restart the running
application. It has been happily chugging away in the background. And yet each
change we make is available whenever we access the application through a browser.
What gives?
It turns out that the Rails dispatcher is pretty clever. In development mode (as opposed
to testing or production), it automatically reloads application source files when a new
request comes along. That way, when we edit our application, the dispatcher makes
sure it’s running the most recent changes. This is great for development.
However, this flexibility comes at a cost—it causes a short pause after you enter a
URL before the application responds. That’s caused by the dispatcher reloading stuff.
For development it’s a price worth paying, but in production it would be unacceptable.
Because of this, this feature is disabled for production deployment (see Chapter 16,
Task K: Deployment and Production, on page 229).

Download rails32/demo3/app/views/say/hello.html.erb
<h1>Hello from Rails!</h1>
<p>
➤
It is now <%= @time %>
</p>

When we refresh our browser window, we will again see the current time,
showing that the communication between the controller and the view was
successful.
Why did we go to the extra trouble of setting the time to be displayed in the
controller and then using it in the view? Good question. In this application,
it doesn’t make much difference, but by putting the logic in the controller
instead, we buy ourselves some benefits. For example, we may want to extend
our application in the future to support users in many countries. In that case,
we’d want to localize the display of the time, choosing a time appropriate to
their time zone. That would be a fair amount of application-level code, and it
would probably not be appropriate to embed it at the view level. By setting
the time to display in the controller, we make our application more flexible—we
can change the time zone in the controller without having to update any view
that uses that time object. The time is data, and it should be supplied to the
view by the controller. We’ll see a lot more of this when we introduce models
into the equation.

The Story So Far
Let’s briefly review how our current application works:

report erratum • discuss

24

•

Chapter 2. Instant Gratification

1. The user navigates to our application. In our case, we do that using a local
URL such as http://localhost:3000/say/hello.
2. Rails then matches the route pattern, which it previously split into two
parts and analyzed.
The say part is taken to be the name of a controller, so Rails creates a new
instance of the Ruby class SayController (which it finds in app/controllers/
say_controller.rb).
3. The next part of the pattern, hello, identifies an action. Rails invokes a
method of that name in the controller. This action method creates a new
Time object holding the current time and tucks it away in the @time instance
variable.
4. Rails looks for a template to display the result. It searches the directory
app/views for a subdirectory with the same name as the controller (say) and
in that subdirectory for a file named after the action (hello.html.erb).
5. Rails processes this file through the ERB templating system, executing
any embedded Ruby and substituting in values set up by the controller.
6. The result is returned to the browser, and Rails finishes processing this
request.
This isn’t the whole story—Rails gives you lots of opportunities to override
this basic workflow (and we’ll be taking advantage of them shortly). As it
stands, our story illustrates convention over configuration, one of the fundamental parts of the philosophy of Rails. By providing convenient defaults and
by applying certain conventions on how a URL is constructed or in what file
a controller definition is placed and what class name and method names are
used, Rails applications are typically written using little or no external configuration—things just knit themselves together in a natural way.

2.3

Linking Pages Together
It’s a rare web application that has just one page. Let’s see how we can add
another stunning example of web design to our “Hello, World!” application.
Normally, each page in your application will correspond to a separate view.
In our case, we’ll also use a new action method to handle the page (although
that isn’t always the case, as we’ll see later in the book). We’ll use the same
controller for both actions. Again, this needn’t be the case, but we have no
compelling reason to use a new controller right now.

report erratum • discuss

Linking Pages Together

•

25

We already defined a goodbye action for this controller, so all that remains
is to create a new template in the directory app/views/say. This time it’s called
goodbye.html.erb, because by default templates are named after their associated
actions.
Download rails32/demo4/app/views/say/goodbye.html.erb
<h1>Goodbye!</h1>
<p>
It was nice having you here.
</p>

Fire up our trusty browser again, but this time point to our new view using
the URL http://localhost:3000/say/goodbye. You should see something like
this:

Now we need to link the two screens. We’ll put a link on the hello screen that
takes us to the goodbye screen, and vice versa. In a real application, we might
want to make these proper buttons, but for now we’ll just use hyperlinks.
We already know that Rails uses a convention to parse the URL into a target
controller and an action within that controller. So, a simple approach would
be to adopt this URL convention for our links.
The file hello.html.erb would contain the following:
...
<p>
Say <a href="/say/goodbye">Goodbye</a>!
</p>
...

And the file goodbye.html.erb would point the other way:
...
<p>
Say <a href="/say/hello">Hello</a>!
</p>
...

report erratum • discuss

26

•

Chapter 2. Instant Gratification

This approach would certainly work, but it’s a bit fragile. If we were to move
our application to a different place on the web server, the URLs would no
longer be valid. It also encodes assumptions about the Rails URL format into
our code; it’s possible a future version of Rails might change this.
Fortunately, these aren’t risks we have to take. Rails comes with a bunch of
helper methods that can be used in view templates. Here, we’ll use the helper
method link_to(), which creates a hyperlink to an action. (The link_to() method
can do a lot more than this, but let’s take it gently for now.) Using link_to(),
hello.html.erb becomes the following:

➤
➤
➤
➤

Download rails32/demo5/app/views/say/hello.html.erb
<h1>Hello from Rails!</h1>
<p>
It is now <%= @time %>
</p>
<p>
Time to say
<%= link_to "Goodbye", say_goodbye_path %>!
</p>

There’s a link_to() call within an ERB <%=…%> sequence. This creates a link to
a URL that will invoke the goodbye() action. The first parameter in the call to
link_to() is the text to be displayed in the hyperlink, and the next parameter
tells Rails to generate the link to the goodbye action.
Let’s stop for a minute to consider how we generated the link. We wrote this:
link_to "Goodbye!", say_goodbye_path

First, link_to is a method call. (In Rails, we call methods that make it easier to
write templates helpers.) If you come from a language such as Java, you might
be surprised that Ruby doesn’t insist on parentheses around method parameters. You can always add them if you like.
The say_goodbye_path is a precomputed value that Rails makes available to
application views. It evaluates to the /say/goodbye path. Over time you will see
that Rails provides the ability to name all the routes that you will be using
in your application.
OK, back to the application. If we point our browser at our hello page, it will
now contain the link to the goodbye page, as shown in Figure 3, Link to the
goodbye page, on page 27
We can make the corresponding change in goodbye.html.erb, linking it back to
the initial hello page:

report erratum • discuss

What We Just Did

•

27

Figure 3—Link to the goodbye page

Download rails32/demo5/app/views/say/goodbye.html.erb
<h1>Goodbye!</h1>
<p>
It was nice having you here.
</p>
➤ <p>
➤
Say <%= link_to "Hello", say_hello_path %> again.
➤ </p>

At this point, we’ve completed our toy application and in the process verified
that our installation of Rails is functioning properly. After a brief recap, it is
now time to move on to building a real application.

2.4

What We Just Did
We constructed a toy application that showed us the following:
• How to create a new Rails application and how to create a new controller
in that application
• How to create dynamic content in the controller and display it via the
view template
• How to link pages together
This is a great foundation, and it didn’t really take much time or effort. This
experience will continue as we move on to the next chapter and build a much
bigger application.

Playtime
Here’s some stuff to try on your own:

report erratum • discuss

28

•

Chapter 2. Instant Gratification

• Experiment with the following expressions:
• Addition: <%= 1+2 %>
• Concatenation: <%= "cow" + "boy" %>
• Time in one hour: <%= 1.hour.from_now %>
• A call to the following Ruby method returns a list of all the files in the
current directory:
@files = Dir.glob('*')

Use it to set an instance variable in a controller action, and then write
the corresponding template that displays the filenames in a list on the
browser.
Hint: you can iterate over a collection using something like this:
<% for file in @files %>
file name is: <%= file %>
<% end %>

You might want to use a <ul> for the list.
(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

Cleaning Up
Maybe you’ve been following along and writing the code in this chapter. If so,
chances are that the application is still running on your computer. When we
start coding our next application in ten pages or so, we’ll get a conflict the
first time we run it, because it will also try to use the computer’s port 3000
to talk with the browser. Now would be a good time to stop the current application by pressing Ctrl-C in the window you used to start it.
Now let’s move on to an overview of Rails.

report erratum • discuss

In this chapter, we’ll see
• models,
• views, and
• controllers.

CHAPTER 3

The Architecture of Rails Applications
One of the interesting features of Rails is that it imposes some fairly serious
constraints on how you structure your web applications. Surprisingly, these
constraints make it easier to create applications—a lot easier. Let’s see why.

3.1

Models, Views, and Controllers
Back in 1979, Trygve Reenskaug came up with a new architecture for developing interactive applications. In his design, applications were broken into
three types of components: models, views, and controllers.
The model is responsible for maintaining the state of the application. Sometimes this state is transient, lasting for just a couple of interactions with the
user. Sometimes the state is permanent and will be stored outside the application, often in a database.
A model is more than just data; it enforces all the business rules that apply
to that data. For example, if a discount shouldn’t be applied to orders of less
than $20, the model will enforce the constraint. This makes sense; by putting
the implementation of these business rules in the model, we make sure that
nothing else in the application can make our data invalid. The model acts as
both a gatekeeper and a data store.
The view is responsible for generating a user interface, normally based on
data in the model. For example, an online store will have a list of products
to be displayed on a catalog screen. This list will be accessible via the model,
but it will be a view that accesses the list from the model and formats it for
the end user. Although the view may present the user with various ways of
inputting data, the view itself never handles incoming data. The view’s work
is done once the data is displayed. There may well be many views that access
the same model data, often for different purposes. In the online store, there’ll

report erratum • discuss

30

•

Chapter 3. The Architecture of Rails Applications

Controller

View

Browser sends request
Controller interacts with model
Controller invokes view
View renders next browser screen

Model

Database

Figure 4—The Model-View-Controller architecture

be a view that displays product information on a catalog page and another
set of views used by administrators to add and edit products.
Controllers orchestrate the application. Controllers receive events from the
outside world (normally user input), interact with the model, and display an
appropriate view to the user.
This triumvirate—the model, view, and controller—together form an architecture known as MVC. To learn how the three concepts fit together, see Figure
4, The Model-View-Controller architecture, on page 30.
The MVC architecture was originally intended for conventional GUI applications, where developers found the separation of concerns led to far less
coupling, which in turn made the code easier to write and maintain. Each
concept or action was expressed in just one well-known place. Using MVC
was like constructing a skyscraper with the girders already in place—it was
a lot easier to hang the rest of the pieces with a structure already there.
During the development of our application, we will be making heavy use of
Rails’ ability to generate scaffolding for our application.
Ruby on Rails is an MVC framework, too. Rails enforces a structure for your
application—you develop models, views, and controllers as separate chunks
of functionality, and it knits them all together as your program executes. One
of the joys of Rails is that this knitting process is based on the use of intelligent
defaults so that you typically don’t need to write any external configuration
metadata to make it all work. This is an example of the Rails philosophy of
favoring convention over configuration.
In a Rails application, an incoming request is first sent to a router, which
works out where in the application the request should be sent and how the
request itself should be parsed. Ultimately, this phase identifies a particular

report erratum • discuss

Models, Views, and Controllers

Routing

31

http://my.url/line_items?product_id=2
Controller interacts with model
Controller invokes view
View renders next browser screen

Line Items
Controller

Line Items
View

•

Active
Record
Model

Database

Figure 5—Rails and MVC

method (called an action in Rails parlance) somewhere in the controller code.
The action might look at data in the request, it might interact with the model,
and it might cause other actions to be invoked. Eventually the action prepares
information for the view, which renders something to the user.
Rails handles an incoming request as shown in Figure 5, Rails and MVC, on
page 31. In this example, the application has previously displayed a product
catalog page, and the user has just clicked the Add to Cart button next to one
of the products. This button posts to http://localhost:3000/line_items?product_id=2, where line_items is a resource in our application and 2 is our internal
id for the selected product.
The routing component receives the incoming request and immediately picks
it apart. The request contains a path (/line_items?product_id=2) and a method (this
button does a POST operation; other common methods are GET, PUT, and
DELETE). In this simple case, Rails takes the first part of the path, line_items,
as the name of the controller and the product_id as the id of a product. By
convention, POST methods are associated with create() actions. As a result of
all this analysis, the router knows it has to invoke the create() method in the
controller class LineItemsController (we’ll talk about naming conventions in Section
18.2, Naming Conventions, on page 264).
The create() method handles user requests. In this case, it finds the current
user’s shopping cart (which is an object managed by the model). It also asks
the model to find the information for product 2. It then tells the shopping
cart to add that product to itself. (See how the model is being used to keep
track of all the business data? The controller tells it what to do, and the
model knows how to do it.)

report erratum • discuss

32

•

Chapter 3. The Architecture of Rails Applications

Now that the cart includes the new product, we can show it to the user. The
controller invokes the view code, but before it does, it arranges things so that
the view has access to the cart object from the model. In Rails, this invocation
is often implicit; again, conventions help link a particular view with a given
action.
That’s all there is to an MVC web application. By following a set of conventions
and partitioning your functionality appropriately, you’ll discover that your
code becomes easier to work with and your application becomes easier to
extend and maintain. Seems like a good trade.
If MVC is simply a question of partitioning your code a particular way, you
might be wondering why you need a framework such as Ruby on Rails. The
answer is straightforward: Rails handles all of the low-level housekeeping for
you—all those messy details that take so long to handle by yourself—and lets
you concentrate on your application’s core functionality. Let’s see how.

3.2

Rails Model Support
In general, we’ll want our web applications to keep their information in a
relational database. Order-entry systems will store orders, line items, and
customer details in database tables. Even applications that normally use
unstructured text, such as weblogs and news sites, often use databases as
their back-end data store.
Although it might not be immediately apparent from the SQL1 you use to
access them, relational databases are actually designed around mathematical
set theory. Although this is good from a conceptual point of view, it makes it
difficult to combine relational databases with object-oriented (OO) programming languages. Objects are all about data and operations, and databases
are all about sets of values. Operations that are easy to express in relational
terms are sometimes difficult to code in an OO system. The reverse is also
true.
Over time, folks have worked out ways of reconciling the relational and OO
views of their corporate data. Let’s look at the way that Rails chooses to map
relational data onto objects.

Object-Relational Mapping
ORM libraries map database tables to classes. If a database has a table called
orders, our program will have a class named Order. Rows in this table correspond
1.

SQL, referred to by some as Structured Query Language, is the language used to query
and update relational databases.

report erratum • discuss

Rails Model Support

•

33

to objects of the class—a particular order is represented as an object of class
Order. Within that object, attributes are used to get and set the individual
columns. Our Order object has methods to get and set the amount, the sales
tax, and so on.
In addition, the Rails classes that wrap our database tables provide a set of
class-level methods that perform table-level operations. For example, we might
need to find the order with a particular id. This is implemented as a class
method that returns the corresponding Order object. In Ruby code, this might
look like this:

class method
↪ on page 46
puts

order = Order.find(1)
puts "Customer #{order.customer_id}, amount=$#{order.amount}"

↪ on page 39

Sometimes these class-level methods return collections of objects:
iterating

Order.where(name: 'dave').each do |order|
puts order.amount
end

↪ on page 44

Finally, the objects corresponding to individual rows in a table have methods
that operate on that row. Probably the most widely used is save(), the operation
that saves the row to the database:
Order.where(name: 'dave').each do |order|
order.pay_type = "Purchase order"
order.save
end

So, an ORM layer maps tables to classes, rows to objects, and columns to
attributes of those objects. Class methods are used to perform table-level
operations, and instance methods perform operations on the individual rows.
In a typical ORM library, you supply configuration data to specify the mappings between entities in the database and entities in the program.
Programmers using these ORM tools often find themselves creating and
maintaining a boatload of XML configuration files.

Active Record
Active Record is the ORM layer supplied with Rails. It closely follows the
standard ORM model: tables map to classes, rows to objects, and columns
to object attributes. It differs from most other ORM libraries in the way it is
configured. By relying on convention and starting with sensible defaults, Active
Record minimizes the amount of configuration that developers perform.
To illustrate this, here’s a program that uses Active Record to wrap our orders
table:

report erratum • discuss

34

•

Chapter 3. The Architecture of Rails Applications

require 'active_record'
class Order < ActiveRecord::Base
end
order = Order.find(1)
order.pay_type = "Purchase order"
order.save

This code uses the new Order class to fetch the order with an id of 1 and
modify the pay_type. (We’ve omitted the code that creates a database connection for now.) Active Record relieves us of the hassles of dealing with the
underlying database, leaving us free to work on business logic.
But Active Record does more than that. As you’ll see when we develop our
shopping cart application, starting in Chapter 5, The Depot Application, on
page 55, Active Record integrates seamlessly with the rest of the Rails
framework. If a web form sends the application data related to a business
object, Active Record can extract it into our model. Active Record supports
sophisticated validation of model data, and if the form data fails validations,
the Rails views can extract and format errors.
Active Record is the solid model foundation of the Rails MVC architecture.

3.3

Action Pack: The View and Controller
When you think about it, the view and controller parts of MVC are pretty
intimate. The controller supplies data to the view, and the controller receives
events from the pages generated by the views. Because of these interactions,
support for views and controllers in Rails is bundled into a single component,
Action Pack.
Don’t be fooled into thinking that your application’s view code and controller
code will be jumbled up just because Action Pack is a single component. Quite
the contrary; Rails gives you the separation you need to write web applications
with clearly demarcated code for control and presentation logic.

View Support
In Rails, the view is responsible for creating either all or part of a response
to be displayed in a browser, processed by an application or sent as an email.
At its simplest, a view is a chunk of HTML code that displays some fixed text.
More typically you’ll want to include dynamic content created by the action
method in the controller.
In Rails, dynamic content is generated by templates, which come in three
flavors. The most common templating scheme, called Embedded Ruby (ERb),

report erratum • discuss

Action Pack: The View and Controller

•

35

embeds snippets of Ruby code within a view document, in many ways similar
to the way it is done in other web frameworks, such as PHP or JSP. Although
this approach is very flexible, some are concerned that it violates the spirit
of MVC. By embedding code in the view, we risk adding logic that should be
in the model or the controller. As with everything, while judicious use in
moderation is healthy, overuse can become a problem. Maintaining a clean
separation of concerns is part of the job of the developer. (We look at HTML
templates in Section 25.2, Generating HTML with ERb, on page 421.)
You can also use ERb to construct JavaScript fragments on the server that
are then executed on the browser. This is great for creating dynamic Ajax
interfaces. We talk about these starting in Section 11.2, Iteration F2: Creating
an Ajax-Based Cart, on page 136.
Rails also provides XML Builder to construct XML documents using Ruby
code—the structure of the generated XML will automatically follow the
structure of the code. We discuss xml.builder templates starting in Section 25.1,
Generating XML with Builder, on page 419.

And the Controller!
The Rails controller is the logical center of your application. It coordinates
the interaction between the user, the views, and the model. However, Rails
handles most of this interaction behind the scenes; the code you write concentrates on application-level functionality. This makes Rails controller code
remarkably easy to develop and maintain.
The controller is also home to a number of important ancillary services:
• It is responsible for routing external requests to internal actions. It handles
people-friendly URLs extremely well.
• It manages caching, which can give applications orders-of-magnitude
performance boosts.
• It manages helper modules, which extend the capabilities of the view
templates without bulking up their code.
• It manages sessions, giving users the impression of ongoing interaction
with our applications.
We’ve already seen and modified a controller in Section 2.2, Hello, Rails!, on
page 17, and will be seeing and modifying a number of controllers in the
development of a sample application, starting with the products controller in
Section 8.1, Iteration C1: Creating the Catalog Listing, on page 91.
There’s a lot to Rails. But before going any further, let’s have a brief refresher
—and for some of you, a brief introduction—to the Ruby language.

report erratum • discuss

In this chapter, we’ll see
• objects: names and methods;
• data: strings, arrays, hashes, and regular expressions;
• control: if, while, blocks, iterators, and exceptions;
• building blocks: classes and modules;
• YAML and marshalling; and
• common idioms that you will see used in this book.

CHAPTER 4

Introduction to Ruby
Many people who are new to Rails are also new to Ruby. If you are familiar
with a language such as Java, JavaScript, PHP, Perl, or Python, you will find
Ruby pretty easy to pick up.
This chapter is not a complete introduction to Ruby. It will not cover topics
such as precedence rules (like most other programming languages, 1+2*3==7
in Ruby). It is only meant to explain enough Ruby that the examples in the
book make sense.
This chapter draws heavily from material in Chapter 2 of Programming
Ruby [TFH08]. If you think you need more background on the Ruby language,
and at the risk of being grossly self-serving, we’d like to suggest that the best
way to learn Ruby, and the best reference for Ruby’s classes, modules, and
libraries, is Programming Ruby [TFH08] (also known as the PickAxe book).
Welcome to the Ruby community!

4.1

Ruby Is an Object-Oriented Language
Everything you manipulate in Ruby is an object, and the results of those
manipulations are themselves objects.
When you write object-oriented code, you’re normally looking to model concepts from the real world. Typically during this modeling process you’ll discover
categories of things that need to be represented. In an online store, the concept
of a line item could be such a category. In Ruby, you’d define a class to represent each of these categories. You then use this class as a kind of factory
that generates objects—instances of that class. An object is a combination of
state (for example, the quantity and the product id) and methods that use
that state (perhaps a method to calculate the line item’s total cost). We’ll show
how to create classes in Classes, on page 46.

report erratum • discuss

38

•

Chapter 4. Introduction to Ruby

Objects are created by calling a constructor, a special method associated with
a class. The standard constructor is called new().
Given a class called LineItem, you could create line item objects as follows:
line_item_one = LineItem.new
line_item_one.quantity = 1
line_item_one.sku
= "AUTO_B_00"

Methods are invoked by sending a message to an object. The message contains
the method’s name, along with any parameters the method may need. When
an object receives a message, it looks into its own class for a corresponding
method. Let’s look at some method calls:
"dave".length
line_item_one.quantity()
cart.add_line_item(next_purchase)
submit_tag "Add to Cart"

Parentheses are generally optional in method calls. In Rails applications,
you’ll find that most method calls involved in larger expressions will have
parentheses, while those that look more like commands or declarations tend
not to have them.
Methods have names, as do many other constructs in Ruby. Names in Ruby
have special rules, rules that you may not have seen if you come to Ruby
from another language.

Ruby Names

@name
↪ on page 46

Local variables, method parameters, and method names should all start with
a lowercase letter or with an underscore: order, line_item, and xr2000 are all valid.
Instance variables begin with an “at” (@) sign, such as @quantity and @product_id.
The Ruby convention is to use underscores to separate words in a multiword
method or variable name (so line_item is preferable to lineItem).
Class names, module names, and constants must start with an uppercase
letter. By convention they use capitalization, rather than underscores, to
distinguish the start of words within the name. Class names look like Object,
PurchaseOrder, and LineItem.
Rails uses symbols to identify things. In particular, it uses them as keys when
naming method parameters and looking things up in hashes. Here is an
example:
redirect_to :action => "edit", :id => params[:id]

report erratum • discuss

Data Types

•

39

As you can see, a symbol looks like a variable name, but it’s prefixed with a
colon. Examples of symbols include :action, :line_items, and :id. You can think of
symbols as string literals that are magically made into constants. Alternatively,
you can consider the colon to mean “thing named,” so :id is “the thing named
id.”
Now that we have used a few methods, let’s move on to how they are defined.

Methods
Let’s write a method that returns a cheery, personalized greeting. We’ll invoke
that method a couple of times:
def say_goodnight(name)
result = 'Good night, ' + name
return result
end
# Time for bed...
puts say_goodnight('Mary-Ellen')
puts say_goodnight('John-Boy')

Having defined the method, we call it twice. In both cases, we pass the result
to the method puts(), which outputs to the console its argument followed by a
newline (moving on to the next line of output).
You don’t need a semicolon at the end of a statement as long as you put each
statement on a separate line. Ruby comments start with a # character and
run to the end of the line. Indentation is not significant (but two-character
indentation is the de facto Ruby standard).
Ruby doesn’t use braces to delimit the bodies of compound statements and
definitions (such as methods and classes). Instead, you simply finish the body
with the keyword end. The keyword return is optional, and if not present, the
results of the last expression evaluated will be returned.

4.2

Data Types
While everything in Ruby is an object, some of the data types in Ruby have
special syntax support, in particular for defining literal values. In these examples, we’ve used some simple strings and even string concatenation.

Strings
This previous example also showed some Ruby string objects. One way to
create a string object is to use string literals, which are sequences of characters
between single or double quotation marks. The difference between the two
forms is the amount of processing Ruby does on the string while constructing

report erratum • discuss

40

•

Chapter 4. Introduction to Ruby

the literal. In the single-quoted case, Ruby does very little. With a few exceptions, what you type into the single-quoted string literal becomes the string’s
value.
In the double-quoted case, Ruby does more work. First, it looks for substitutions—sequences that start with a backslash character—and replaces them
with some binary value. The most common of these is \n, which is replaced
with a newline character. When you write a string containing a newline to
the console, the \n forces a line break.
Second, Ruby performs expression interpolation in double-quoted strings. In
the string, the sequence #{expression} is replaced by the value of expression.
We could use this to rewrite our previous method:
def say_goodnight(name)
"Good night, #{name.capitalize}"
end
puts say_goodnight('pa')

When Ruby constructs this string object, it looks at the current value of name
and substitutes it into the string. Arbitrarily complex expressions are allowed
in the #{…} construct. Here we invoked the capitalize() method, defined for all
strings, to output our parameter with a leading uppercase letter.
Strings are a fairly primitive data type that contain an ordered collection of
bytes or characters. Ruby also provides means for defining collections of
arbitrary objects via arrays and hashes.

Arrays and Hashes
Ruby’s arrays and hashes are indexed collections. Both store collections of
objects, accessible using a key. With arrays, the key is an integer, whereas
hashes support any object as a key. Both arrays and hashes grow as needed
to hold new elements. It’s more efficient to access array elements, but hashes
provide more flexibility. Any particular array or hash can hold objects of differing types; you can have an array containing an integer, a string, and a
floating-point number, for example.
You can create and initialize a new array object using an array literal—a set
of elements between square brackets. Given an array object, you can access
individual elements by supplying an index between square brackets, as the
next example shows. Ruby array indices start at zero.
a = [ 1, 'cat', 3.14 ]
a[0]
a[2] = nil

#
#
#
#

array with three elements
access the first element (1)
set the third element
array now [ 1, 'cat', nil ]

report erratum • discuss

Data Types

•

41

You may have noticed that we used the special value nil in this example. In
many languages, the concept of nil (or null) means “no object.” In Ruby, that’s
not the case; nil is an object, just like any other, that happens to represent
nothing.
The method <<() is commonly used with arrays. It appends a value to its
receiver.
ages = []
for person in @people
ages << person.age
end

Ruby has a shortcut for creating an array of words:
a = [ 'ant', 'bee', 'cat', 'dog', 'elk' ]
# this is the same:
a = %w{ ant bee cat dog elk }

Ruby hashes are similar to arrays. A hash literal uses braces rather than
square brackets. The literal must supply two objects for every entry: one for
the key, the other for the value. For example, you may want to map musical
instruments to their orchestral sections:
inst_section
:cello
:clarinet
:drum
:oboe
:trumpet
:violin
}

= {
=> 'string',
=> 'woodwind',
=> 'percussion',
=> 'woodwind',
=> 'brass',
=> 'string'

The thing to the left of the => is the key, and that on the right is the corresponding value. Keys in a particular hash must be unique—you can’t have
two entries for :drum. The keys and values in a hash can be arbitrary objects
—you can have hashes where the values are arrays, other hashes, and so on.
In Rails, hashes typically use symbols as keys. Many Rails hashes have been
subtly modified so that you can use either a string or a symbol interchangeably
as a key when inserting and looking up values.
Use of symbols as hash keys is so commonplace that starting with Ruby 1.9
there is a special syntax for it, saving both keystrokes and eyestrain.
inst_section = {
cello:
'string',
clarinet: 'woodwind',
drum:
'percussion',
oboe:
'woodwind',

report erratum • discuss

42

•

Chapter 4. Introduction to Ruby

trumpet:
violin:

'brass',
'string'

}

Doesn’t that look much better?
Feel free to use whichever syntax you like. You can even intermix usages in
a single expression. Obviously you’ll need to use the arrow syntax whenever
the key is not a symbol, or if you are using Ruby 1.8.7. However, most developers seem to prefer the new syntax, and Rails will even generate scaffolds
using the new syntax if it detects that you are running Rails 1.9.2 or later.
Hashes are indexed using the same square bracket notation as arrays:
inst_section[:oboe]
inst_section[:cello]
inst_section[:bassoon]

#=> 'woodwind'
#=> 'string'
#=> nil

As the previous example shows, a hash returns nil when indexed by a key it
doesn’t contain. Normally this is convenient, because nil means false when
used in conditional expressions.
You can pass hashes as parameters on method calls. Ruby allows you to omit
the braces, but only if the hash is the last parameter of the call. Rails makes
extensive use of this feature. The following code fragment shows a two-element
hash being passed to the redirect_to() method. In effect, though, you can ignore
that it’s a hash and pretend that Ruby has keyword arguments.
redirect_to action: 'show', id: product.id

There is one more data type worth mentioning—the regular expression.

Regular Expressions
A regular expression lets you specify a pattern of characters to be matched
in a string. In Ruby, you typically create a regular expression by writing /pattern/
or %r{pattern}.
For example, you could write a pattern that matches a string containing the
text Perl or the text Python using the regular expression /Perl|Python/.
The forward slashes delimit the pattern, which consists of the two things
we’re matching, separated by a vertical bar (|). This bar character means “either
the thing on the left or the thing on the right,” in this case either Perl or
Python. You can use parentheses within patterns, just as you can in arithmetic
expressions, so you could also have written this pattern as /P(erl|ython)/. Programs typically test strings against regular expressions using the =~ match
operator:

report erratum • discuss

Logic

•

43

if line =~ /P(erl|ython)/
puts "There seems to be another scripting language here"
end

You can specify repetition within patterns. /ab+c/ matches a string containing
an a followed by one or more b’s, followed by a c. Change the plus to an asterisk, and /ab*c/ creates a regular expression that matches one a, zero or more
b’s, and one c.
Backward slashes start special sequences; most notably, \d matches any
digit, \s matches any whitespace character, and \w matches any alphanumeric
("word") character.
Ruby’s regular expressions are a deep and complex subject; this section
barely skims the surface. See the PickAxe book for a full discussion.
This book will only make light use of regular expressions.
With that brief introduction to data, let’s move on to logic.

4.3

Logic
Method calls are statements. Ruby also provides a number of ways to make
decisions that affect the repetition and order in which methods are invoked.

Control Structures
Ruby has all the usual control structures, such as if statements and while
loops. Java, C, and Perl programmers may well get caught by the lack of
braces around the bodies of these statements. Instead, Ruby uses the keyword
end to signify the end of a body:
if count > 10
puts "Try again"
elsif tries == 3
puts "You lose"
else
puts "Enter a number"
end

Similarly, while statements are terminated with end:
while weight < 100 and num_pallets <= 30
pallet = next_pallet()
weight += pallet.weight
num_pallets += 1
end

report erratum • discuss

44

•

Chapter 4. Introduction to Ruby

Ruby also contains variants of these statements: unless is like if except that it
checks for the condition to not be true. Similarly, until is like while except that
the loop continues until the condition evaluates to be true.
Ruby statement modifiers are a useful shortcut if the body of an if, unless, while,
or until statement is just a single expression. Simply write the expression, followed by the modifier keyword and the condition:
puts "Danger, Will Robinson" if radiation > 3000
distance = distance * 1.2 while distance < 100

Although if statements are fairly common in Ruby applications, newcomers
to the Ruby language are often surprised to find that looping constructs are
rarely used. Blocks and iterators often take their place.

Blocks and Iterators
Code blocks are just chunks of code between braces or between do…end. A
common convention is that people use braces for single-line blocks and do/
end for multiline blocks:
{ puts "Hello" }

# this is a block

do

###
# and so is this
#
###

club.enroll(person)
person.socialize
end

To pass a block to a method, place the block after the parameters (if any) to
the method. In other words, put the start of the block at the end of the source
line containing the method call. For example, in the following code, the block
containing puts "Hi" is associated with the call to the method greet():
greet

{ puts "Hi" }

If a method call has parameters, they appear before the block:
verbose_greet("Dave", "loyal customer")

{ puts "Hi" }

A method can invoke an associated block one or more times using the Ruby
yield statement. You can think of yield as being something like a method call
that calls out to the block associated with the method containing the yield.
You can pass values to the block by giving parameters to yield. Within the
block, you list the names of the arguments to receive these parameters between
vertical bars (|).

report erratum • discuss

Logic

•

45

Code blocks appear throughout Ruby applications. Often they are used in
conjunction with iterators: methods that return successive elements from
some kind of collection, such as an array:
animals = %w( ant bee cat dog elk )
animals.each {|animal| puts animal }

# create an array
# iterate over the contents

Each integer N implements a times() method, which invokes an associated
block N times:
3.times { print "Ho! " }

#=>

Ho! Ho! Ho!

The & prefix operator will allow a method to capture a passed block as a named
parameter.
def wrap &b
print "Santa says: "
3.times(&b)
print "\n"
end
wrap { print "Ho! " }

Within a block, or a method, control is sequential except when there is an
exception.

Exceptions
Exceptions are objects (of class Exception or its subclasses). The raise method
causes an exception to be raised. This interrupts the normal flow through
the code. Instead, Ruby searches back through the call stack for code that
says it can handle this exception.
Both methods and blocks of code wrapped between begin and end keywords
intercept certain classes of exceptions using rescue clauses.
begin
content = load_blog_data(file_name)
rescue BlogDataNotFound
STDERR.puts "File #{file_name} not found"
rescue BlogDataFormatError
STDERR.puts "Invalid blog data in #{file_name}"
rescue Exception => exc
STDERR.puts "General error loading #{file_name}: #{exc.message}"
end

rescue clauses can be directly placed on the outermost level of a method defi-

nition without needing to enclose the contents in a begin/end block.
That concludes our brief introduction to control flow, and at this point we
have our basic building blocks upon which we can build larger structures.

report erratum • discuss

46

4.4

•

Chapter 4. Introduction to Ruby

Organizing Structures
There are two basic concepts in Ruby for organizing methods, namely, classes
and modules. We cover each in turn.

Classes
Here’s a Ruby class definition:
Line 1
-

class Order < ActiveRecord::Base
has_many :line_items

-

def self.find_all_unpaid
self.where('paid = 0')
end
def total
sum = 0
line_items.each {|li| sum += li.total}
sum
end

5
10
-

end

Class definitions start with the keyword class followed by the class name (which
must start with an uppercase letter). This Order class is defined to be a subclass
of the class Base within the ActiveRecord module.
Rails makes heavy use of class-level declarations. Here has_many is a method
that’s defined by Active Record. It’s called as the Order class is being defined.
Normally these kinds of methods make assertions about the class, so in this
book we call them declarations.
Within a class body you can define class methods and instance methods.
Prefixing a method name with self. (as we do on line 4) makes it a class method;
it can be called on the class generally. In this case, we can make the following
call anywhere in our application:
to_collect = Order.find_all_unpaid

Objects of a class hold their state in instance variables. These variables, whose
names all start with @, are available to all the instance methods of a class.
Each object gets its own set of instance variables.
Instance variables are not directly accessible outside the class. To make them
available, write methods that return their values:
class Greeter
def initialize(name)
@name = name
end

report erratum • discuss

Organizing Structures

•

47

def name
@name
end
def name=(new_name)
@name = new_name
end
end
g = Greeter.new("Barney")
puts g.name
#=> Barney
g.name = "Betty"
puts g.name
#=> Betty

Ruby provides convenience methods that write these accessor methods for
you (which is great news for folks tired of writing all those getters and setters):
class Greeter
attr_accessor
attr_reader
attr_writer

:name
:greeting
:age

# create reader and writer methods
# create reader only
# create writer only

A class’s instance methods are public by default; anyone can call them. You’ll
probably want to override this for methods that are intended to be used only
by other class instance methods:
class MyClass
def m1
# this method is public
end
protected
def m2
# this method is protected
end
private
def m3
# this method is private
end
end

The private directive is the strictest; private methods can be called only from
within the same instance. Protected methods can be called both in the same
instance and by other instances of the same class and its subclasses.
Classes are not the only organizing structure in Ruby. The other organizing
structure is a module.

Modules
Modules are similar to classes in that they hold a collection of methods,
constants, and other module and class definitions. Unlike classes, you cannot
create objects based on modules.

report erratum • discuss

48

•

Chapter 4. Introduction to Ruby

Modules serve two purposes. First, they act as a namespace, letting you define
methods whose names will not clash with those defined elsewhere. Second,
they allow you to share functionality between classes—if a class mixes in a
module, that module’s instance methods become available as if they had been
defined in the class. Multiple classes can mix in the same module, sharing
the module’s functionality without using inheritance. You can also mix
multiple modules into a single class.
Helper methods are an example of where Rails uses modules. Rails automatically mixes these helper modules into the appropriate view templates. For
example, if you wanted to write a helper method that would be callable from
views invoked by the store controller, you could define the following module
in the file store_helper.rb in the app/helpers directory:
module StoreHelper
def capitalize_words(string)
string.split(' ').map {|word| word.capitalize}.join(' ')
end
end

There is one module that is part of the standard library of Ruby that deserves
special mention given its usage in Rails, namely, YAML.

YAML
YAML1 is a recursive acronym that stands for YAML Ain’t Markup Language.
In the context of Rails, YAML is used as a convenient way to define configuration of things such as databases, test data, and translations. Here is an
example:
development:
adapter: sqlite3
database: db/development.sqlite3
pool: 5
timeout: 5000

In YAML, indentation is important, so this defines development as having a set
of four key/value pairs, separated by colons.
While YAML is one way to represent data, particularly when interacting with
humans, Ruby provides a more general way for representing data for use by
applications.

1.

http://www.yaml.org/

report erratum • discuss

Marshaling Objects

4.5

•

49

Marshaling Objects
Ruby can take an object and convert it into a stream of bytes that can be
stored outside the application. This process is called marshaling. This saved
object can later be read by another instance of the application (or by a totally
separate application), and a copy of the originally saved object can be
reconstituted.
There are two potential issues when you use marshaling. First, some objects
cannot be dumped. If the objects to be dumped include bindings, procedure
or method objects, instances of class IO, or singleton objects, or if you try to
dump anonymous classes or modules, a TypeError will be raised.
Second, when you load a marshaled object, Ruby needs to know the definition
of the class of that object (and of all the objects it contains).
Rails uses marshaling to store session data. If you rely on Rails to dynamically
load classes, it is possible that a particular class may not have been defined
at the point it reconstitutes session data. For that reason, you’ll use the
model declaration in your controller to list all models that are marshaled. This
preemptively loads the necessary classes to make marshaling work.
Now that you have the Ruby basics down, let’s give what we learned a whirl
with a slightly larger, annotated example that pulls together a number of
concepts. We’ll follow that with a walk-through of special features that will
help you with your Rails coding.

4.6

Pulling It All Together
Let’s look at an example of how Rails applies a number of Ruby features
together to make the code you need to maintain more declarative. You will
see this example again in Generating the Scaffold, on page 62. For now, we
will focus on the Ruby-language aspects of the example.
class CreateProducts < ActiveRecord::Migration
def change
create_table :products do |t|
t.string :title
t.text :description
t.string :image_url
t.decimal :price, precision: 8, scale: 2
t.timestamps
end
end
end

report erratum • discuss

50

•

Chapter 4. Introduction to Ruby

Even if you didn’t know any Ruby, you would probably be able to decipher
that this code creates a table named products. The fields defined when creating
this table include title, description, image_url, and price as well as a few timestamps
(we’ll describe these in Chapter 23, Migrations, on page 387).
Now let’s look at the same example from a Ruby perspective. A class named
CreateProducts is defined, which inherits from the Migration class from the ActiveRecord module. One method is defined named change(). This method calls a single
class method (defined in ActiveRecord::Migration), passing it the name of the table
in the form of a symbol.
The call to create_table() also passes a block that is to be evaluated before the
table is created. This block, when called, is passed an object named t, which
is used to accumulate a list of fields. Rails defines a number of methods on
this object—methods with names that are named after common data types.
These methods, when called, simply add a field definition to the ever-accumulating set of names.
The definition of decimal also accepts a number of optional parameters,
expressed as a hash.
To someone new to Ruby, this is a lot of heavy machinery thrown at solving
such a simple problem. To someone familiar with Ruby, none of this machinery
is particularly heavy. In any case, Rails makes extensive use of the facilities
provided by Ruby to make defining operations (for example, migration tasks)
as simple and as declarative as possible. Even small features of the language,
such as optional parentheses and braces, contribute to the overall readability
and ease of authoring.
Finally, there are a number of small features, or rather idiomatic combinations
of features, that are often not immediately obvious to people new to the Ruby
language. We close this chapter with them.

4.7

Ruby Idioms
A number of individual Ruby features can be combined in interesting ways,
and the meaning of such idiomatic usage is often not immediately obvious to
people new to the language. We use these common Ruby idioms in this book:
Methods such as empty! and empty?
Ruby method names can end with an exclamation mark (a bang method)
or a question mark (a predicate method). Bang methods normally do
something destructive to the receiver. Predicate methods return true or
false depending on some condition.

report erratum • discuss

Ruby Idioms

•

51

a || b

The expression a || b evaluates a. If it isn’t false or nil, then evaluation stops,
and the expression returns a. Otherwise, the statement returns b. This is
a common way of returning a default value if the first value hasn’t been
set.
a ||= b

The assignment statement supports a set of shortcuts: a op= b is the same
as a = a op b. This works for most operators.
count += 1
price *= discount
count ||= 0

# same as count = count + 1
#
price = price * discount
#
count = count || 0

So, count ||= 0 gives count the value 0 if count doesn’t already have a value.
obj = self.new

Sometimes a class method needs to create an instance of that class.
class Person < ActiveRecord::Base
def self.for_dave
Person.new(name: 'Dave')
end
end

This works fine, returning a new Person object. But later, someone might
subclass our class:
class Employee < Person
# ..
end
dave = Employee.for_dave

# returns a Person

The for_dave() method was hardwired to return a Person object, so that’s
what is returned by Employee.for_dave. Using self.new instead returns a new
object of the receiver’s class, Employee.
lambda

The lambda operator converts a block into an object of type Proc. We will
see this used Scopes, on page 288.
require File.dirname(__FILE__) + '/../test_helper'

Ruby’s require method loads an external source file into our application.
This is used to include library code and classes that our application relies
on. In normal use, Ruby finds these files by searching in a list of directories, the LOAD_PATH.

report erratum • discuss

52

•

Chapter 4. Introduction to Ruby

Sometimes we need to be specific about what file to include. We can do
that by giving require a full filesystem path. The problem is, we don’t know
what that path will be—our users could install our code anywhere.
Wherever our application ends up getting installed, the relative path
between the file doing the requiring and the target file will be the same.
Knowing this, we can construct the absolute path to the target by taking
the absolute path to the file doing the requiring (available in the special
variable __FILE__), stripping out all but the directory name, and then appending the relative path to the target file.
In addition, there are many good resources on the Web showing Ruby idioms
and Ruby gotchas. Here are just a few:
• http://www.ruby-lang.org/en/documentation/ruby-from-other-languages/
• http://en.wikipedia.org/wiki/Ruby_programming_language
• http://www.zenspider.com/Languages/Ruby/QuickRef.html
By this point, we have a firm foundation upon which to build: we’ve installed
Rails, verified that we have things working with a simple application, covered
a brief description of what Rails is, and reviewed (or for some of you, learned
for the first time) the basics of the Ruby language. Now it is time to put this
knowledge in place to build a larger application.

report erratum • discuss

Part II

Building an Application

In this chapter, we’ll see
• incremental development;
• use cases, page flow, data; and
• priorities.

CHAPTER 5

The Depot Application
We could mess around all day hacking together simple test applications, but
that won’t help us pay the bills. So, let’s get our teeth into something meatier.
Let’s create a web-based shopping cart application called Depot.
Does the world need another shopping cart application? Nope, but that hasn’t
stopped hundreds of developers from writing one. Why should we be different?
More seriously, it turns out that our shopping cart will illustrate many of the
features of Rails development. We’ll see how to create simple maintenance
pages, link database tables, handle sessions, and create forms. Over the next
twelve chapters, we’ll also touch on peripheral topics such as unit testing,
security, and page layout.

5.1

Incremental Development
We’ll be developing this application incrementally. We won’t attempt to specify everything before we start coding. Instead, we’ll work out enough of a
specification to let us start and then immediately create some functionality.
We’ll try ideas, gather feedback, and continue with another cycle of mini-design
and development.
This style of coding isn’t always applicable. It requires close cooperation with
the application’s users, because we want to gather feedback as we go along.
We might make mistakes, or the client might discover they asked for one
thing but really wanted something different. It doesn’t matter what the reason—the earlier we discover we’ve made a mistake, the less expensive it will
be to fix that mistake. All in all, with this style of development, there’s a lot
of change as we go along.
Because of this, we need to use a toolset that doesn’t penalize us for changing
our minds. If we decide we need to add a new column to a database table or

report erratum • discuss

56

•

Chapter 5. The Depot Application

change the navigation between pages, we need to be able to get in there and
do it without a bunch of coding or configuration hassle. As you’ll see, Ruby
on Rails shines when it comes to dealing with change—it’s an ideal agile
programming environment.
Along the way, we will be building and maintaining a corpus of tests. These
tests will ensure that the application is always doing what we intend to do.
Not only does Rails enable the creation of such tests, but it actually provides
you with an initial set of tests each time you define a new controller.
On with the application.

5.2

What Depot Does
Let’s start by jotting down an outline specification for the Depot application.
We’ll look at the high-level use cases and sketch out the flow through the web
pages. We’ll also try working out what data the application needs (acknowledging that our initial guesses will likely be wrong).

Use Cases
A use case is simply a statement about how some entity uses a system.
Consultants invent these kinds of phrases to label things we’ve all known all
along—it’s a perversion of business life that fancy words always cost more
than plain ones, even though the plain ones are more valuable.
Depot’s use cases are simple (some would say tragically so). We start off by
identifying two different roles or actors: the buyer and the seller.
The buyer uses Depot to browse the products we have to sell, select some to
purchase, and supply the information needed to create an order.
The seller uses Depot to maintain a list of products to sell, to determine the
orders that are awaiting shipping, and to mark orders as shipped. (The seller
also uses Depot to make scads of money and retire to a tropical island, but
that’s the subject of another book.)
For now, that’s all the detail we need. We could go into excruciating detail
about what it means to maintain products and what constitutes an order
ready to ship, but why bother? If there are details that aren’t obvious, we’ll
discover them soon enough as we reveal successive iterations of our work to
the customer.
Talking of getting feedback, let’s get some right now—let’s make sure our
initial (admittedly sketchy) use cases are on the mark by asking our user.

report erratum • discuss

What Depot Does

•

57

Assuming the use cases pass muster, let’s work out how the application will
work from the perspectives of its various users.

Page Flow
We always like to have an idea of the main pages in our applications and to
understand roughly how users navigate between them. This early in the
development, these page flows are likely to be incomplete, but they still help
us focus on what needs doing and know how actions are sequenced.
Some folks like to mock up web application page flows using Photoshop,
Word, or (shudder) HTML. We like using a pencil and paper. It’s quicker, and
the customer gets to play too, grabbing the pencil and scribbling alterations
right on the paper.
The first sketch of the buyer flow is shown in Figure 6, Flow of buyer pages,
on page 58. It’s pretty traditional. The buyer sees a catalog page, from which
he selects one product at a time. Each product selected gets added to the
cart, and the cart is displayed after each selection. The buyer can continue
shopping using the catalog pages or check out and buy the contents of the
cart. During checkout, we capture contact and payment details and then
display a receipt page. We don’t yet know how we’re going to handle payment,
so those details are fairly vague in the flow.
The seller flow, shown in Figure 7, Flow of seller pages, on page 58, is also
fairly simple. After logging in, the seller sees a menu letting her create or view
a product or ship existing orders. Once viewing a product, the seller may
optionally edit the product information or delete the product entirely.
The shipping option is very simplistic. It displays each order that has not yet
been shipped, one order per page. The seller may choose to skip to the next
or may ship the order, using the information from the page as appropriate.
The shipping function is clearly not going to survive long in the real world,
but shipping is also one of those areas where reality is often stranger than
you might think. Overspecify it up front, and we’re likely to get it wrong. For
now let’s leave it as it is, confident that we can change it as the user gains
experience using our application.

Data
Finally, we need to think about the data we’re going to be working with.
Notice that we’re not using words such as schema or classes here. We’re also
not talking about databases, tables, keys, and the like. We’re simply talking

report erratum • discuss

58

•

Chapter 5. The Depot Application

Figure 6—Flow of buyer pages

Figure 7—Flow of seller pages

report erratum • discuss

What Depot Does

•

59

General Recovery Advice
Everything in this book has been tested. If you follow along with this scenario precisely,
using the recommended version of Rails and SQLite3 on Linux, Mac OS X, or Windows,
then everything should work as described. However, deviations from this path may
occur. Typos happen to the best of us, and not only are side explorations possible,
but they are positively encouraged. Be aware that this might lead you to strange
places. Don’t be afraid: specific recovery actions for common problems appear in the
specific sections where such problems often occur. A few additional general suggestions
are included here.
You should only ever need to restart the server in the few places where doing so is
noted in the book. But if you ever get truly stumped, restarting the server might be
worth trying.
A “magic” command worth knowing, explained in detail in Part III, is rake db:migrate:redo.
It will undo and reapply the last migration.
If your server won’t accept some input on a form, refresh the form on your browser,
and resubmit it.

about data. At this stage in the development, we don’t know whether we’ll
even be using a database.
Based on the use cases and the flows, it seems likely that we’ll be working
with the data shown in Figure 8, Initial guess at application data, on page 60.
Again, using pencil and paper seems a whole lot easier than some fancy tool,
but use whatever works for you.
Working on the data diagram raised a couple of questions. As the user buys
items, we’ll need somewhere to keep the list of products they bought, so we
added a cart. But apart from its use as a transient place to keep this product
list, the cart seems to be something of a ghost—we couldn’t find anything
meaningful to store in it. To reflect this uncertainty, we put a question mark
inside the cart’s box in the diagram. We’re assuming this uncertainty will get
resolved as we implement Depot.
Coming up with the high-level data also raised the question of what information should go into an order. Again, we chose to leave this fairly open for
now—we will refine this further as we start showing our early iterations to
the customer.
Finally, you might have noticed that we’ve duplicated the product’s price in
the line item data. Here we’re breaking the “initially, keep it simple” rule
slightly, but it’s a transgression based on experience. If the price of a product

report erratum • discuss

60

•

Chapter 5. The Depot Application

Figure 8—Initial guess at application data

changes, that price change should not be reflected in the line item price of
currently open orders, so each line item needs to reflect the price of the
product at the time the order was made.
Again, at this point we’ll double-check with the customer that we’re still on
the right track. (The customer was most likely sitting in the room with us
while we drew these three diagrams.)

5.3

Let’s Code
So, after sitting down with the customer and doing some preliminary analysis,
we’re ready to start using a computer for development! We’ll be working from
our original three diagrams, but the chances are pretty good that we’ll be
throwing them away fairly quickly—they’ll become outdated as we gather
feedback. Interestingly, that’s why we didn’t spend too long on them; it’s
easier to throw something away if you didn’t spend a long time creating it.
In the chapters that follow, we’ll start developing the application based on
our current understanding. However, before we turn that page, we have to
answer just one more question: what should we do first?
We like to work with the customer so we can jointly agree on priorities. In
this case, we’d point out to her that it’s hard to develop anything else until
we have some basic products defined in the system, so we suggest spending
a couple of hours getting the initial version of the product maintenance
functionality up and running. And, of course, the client would agree.

report erratum • discuss

In this chapter, we’ll see
• creating a new application,
• configuring the database
• creating models and controllers,
• adding a stylesheet, and
• updating a layout and a view.

CHAPTER 6

Task A: Creating the Application
Our first development task is to create the web interface that lets us maintain
our product information—create new products, edit existing products, delete
unwanted ones, and so on. We’ll develop this application in small iterations,
where small means “measured in minutes.” Let’s get started.
Typically, our iterations involve multiple steps, as in iteration C, which has
steps C1, C2, C3, and so on. In this case, the iteration has two steps.

6.1

Iteration A1: Creating the Products Maintenance Application
At the heart of the Depot application is a database. Getting this installed and
configured and tested before proceeding further will prevent a lot of headaches.
If you aren’t sure of what you want, go with the defaults, and it will go easy.
If you already know what you want, Rails makes it easy for you to describe
your configuration.

Creating a Rails Application
Back in Section 2.1, Creating a New Application, on page 15, we saw how to
create a new Rails application. We’ll do the same thing here. Go to a command
prompt, and type rails new followed by the name of our project. In this case,
our project is called depot, so make sure you are not inside an existing application directory and type this:
work> rails new depot

We see a bunch of output scroll by. When it has finished, we find that a new
directory, depot, has been created. That’s where we’ll be doing our work.
work> cd depot
depot> ls -p
app/
config.ru doc/
Gemfile.lock
config/ db/
Gemfile lib/

log/
Rakefile script/ tmp/
public/ README
test/
vendor/

report erratum • discuss

62

•

Chapter 6. Task A: Creating the Application

Creating the Database
For this application, we’ll use the open source SQLite database (which you’ll
need if you’re following along with the code). We’re using SQLite version 3
here.
SQLite 3 is the default database for Rails development and was installed along
with Rails in Chapter 1, Installing Rails, on page 3. With SQLite 3 there are
no steps required to create a database, and there are no special user accounts
or passwords to deal with. So, now you get to experience one of the benefits
of going with the flow (or, convention over configuration, as Rails folks say...ad
nauseam).
If it’s important to you to use a database server other than SQLite 3, the
commands you’ll need to create the database and grant permissions will be
different. You will find some helpful hints in the Getting Started Rails Guide.1

Generating the Scaffold
Back in Figure 8, Initial guess at application data, on page 60, we sketched
out the basic content of the products table. Now let’s turn that into reality. We
need to create a database table and a Rails model that lets our application
use that table, a number of views to make up the user interface, and a controller to orchestrate the application.

name mapping
↪ on page 264

So, let’s go ahead and create the model, views, controller, and migration for
our products table. With Rails, you can do all that with one command by asking
Rails to generate what is known as a scaffold for a given model. Note that on
the command line2 that follows, we use the singular form, Product. In Rails, a
model is automatically mapped to a database table whose name is the plural
form of the model’s class. In our case, we asked for a model called Product, so
Rails associated it with the table called products. (And how will it find that table?
The development entry in config/database.yml tells Rails where to look for it. For
SQLite 3 users, this will be a file in the db directory.)
depot> rails generate scaffold Product \
title:string description:text image_url:string price:decimal
invoke active_record
create
db/migrate/20110711000001_create_products.rb
create
app/models/product.rb

1.
2.

http://guides.rubyonrails.org/getting_started.html#configuring-a-database
This command is too wide to fit comfortably on the page. To enter a command on
multiple lines, simply put a backslash as the last character on all but the last line,
and you will be prompted for more input. Windows users will need to substitute a
caret (^) for the backslash.

report erratum • discuss

Iteration A1: Creating the Products Maintenance Application
invoke
create
create
route
invoke
create
invoke
create
create
create
create
create
create
invoke
create
invoke
create
invoke
create
create
invoke
invoke
create
invoke
create
invoke
create

•

63

test_unit
test/unit/product_test.rb
test/fixtures/products.yml
resources :products
scaffold_controller
app/controllers/products_controller.rb
erb
app/views/products
app/views/products/index.html.erb
app/views/products/edit.html.erb
app/views/products/show.html.erb
app/views/products/new.html.erb
app/views/products/_form.html.erb
test_unit
test/functional/products_controller_test.rb
helper
app/helpers/products_helper.rb
test_unit
test/unit/helpers/products_helper_test.rb
app/assets/stylesheets/scaffolds.css.scss
assets
coffee
app/assets/javascripts/products.js.coffee
scss
app/assets/stylesheets/products.css.scss
scss
app/assets/stylesheets/scaffolds.css.scss

The generator creates a bunch of files. The one we’re interested in first is the
migration one, namely, 20110711000001_create_products.rb.
A migration represents a change we want to make to the data, expressed in
a source file in database-independent terms. These changes can update both
the database schema and the data in the database tables. We apply these
migrations to update our database, and we can unapply them to roll our
database back. We have a whole section on migrations starting in Chapter
23, Migrations, on page 387. For now, we’ll just use them without too much
more comment.
The migration has a UTC-based timestamp prefix (20110711000001), a name
(create_products), and a file extension (.rb, because it’s a Ruby program).
The timestamp prefix you will see will be different. In fact, the timestamps
used in this book are clearly fictitious. Typically your timestamps will not be
consecutive; instead, they will reflect the time the migration was created.

report erratum • discuss

64

•

Chapter 6. Task A: Creating the Application

Applying the Migration
Although we have already told Rails about the basic data types of each
property, let’s go ahead and refine the definition of the price to have eight
digits of significance and two digits after the decimal point.
Download rails32/depot_a/db/migrate/20110711000001_create_products.rb
class CreateProducts < ActiveRecord::Migration
def change
create_table :products do |t|
t.string :title
t.text :description
t.string :image_url
➤
t.decimal :price, precision: 8, scale: 2
t.timestamps
end
end
end

Reminder: if you are using Ruby 1.8.7, you will need to adjust this syntax as
described in Choosing a Ruby version, on page 4.
Now that we are done with our changes, we need to get Rails to apply this
migration to our development database. We do this using the rake command.
Rake is like having a reliable assistant on hand all the time: you tell it to do
some task, and that task gets done. In this case, we’ll tell Rake to apply any
unapplied migrations to our database:
depot> rake db:migrate
(in /Users/rubys/work/depot)
== CreateProducts: migrating =================================================
-- create_table(:products)
-> 0.0027s
== CreateProducts: migrated (0.0023s) ========================================

And that’s it. Rake looks for all the migrations not yet applied to the database
and applies them. In our case, the products table is added to the database
defined by the development section of the database.yml file.
OK, all the groundwork has been done. We set up our Depot application as
a Rails project. We created the development database and configured our
application to be able to connect to it. We created a products controller and
a Product model and used a migration to create the corresponding products table.
And a number of views have been created for us. It’s time to see all this in
action.

report erratum • discuss

Iteration A1: Creating the Products Maintenance Application

•

65

Seeing the List of Products
With three commands we have created an application and a database (or a
table inside an existing database, if you chose something other than SQLite
3). Before we worry too much about just what happened behind the scenes
here, let’s try our shiny new application.
First, we’ll start a local server, supplied with Rails:
depot> rails server
=> Booting WEBrick
=> Rails 3.2.0 application starting in development on http://0.0.0.0:3000
=> Call with -d to detach
=> Ctrl-C to shutdown server
[2011-07-11 17:45:38] INFO WEBrick 1.3.1
[2011-07-11 17:45:38] INFO ruby 1.9.3 (2011-10-30) [x86_64-linux]
[2011-07-11 17:45:43] INFO WEBrick::HTTPServer#start: pid=24649 port=3000

Just as it did with our demo application on page 15, this command starts a
web server on our local host, port 3000. If you get an error saying Address already
in use when you try to run the server, that simply means you already have a
Rails server running on your machine. If you’ve been following along with the
examples in the book, that might well be the “Hello, World!” application from
Chapter 4. Find its console, and kill the server using Ctrl-C. If you are running
on Windows, you may see the prompt Terminate batch job (Y/N)?. If so, respond
with y.
Let’s connect to it. Remember, the URL we give to our browser contains both
the port number (3000) and the name of the controller in lowercase (products).

That’s pretty boring. It’s showing us an empty list of products. Let’s add some.
Click the New product link, and a form should appear.

report erratum • discuss

66

•

Chapter 6. Task A: Creating the Application

These forms are simply HTML templates, just like the ones you created in
Section 2.2, Hello, Rails!, on page 17. In fact, we can modify them. Let’s change
the number of lines in the description field:
Download rails32/depot_a/app/views/products/_form.html.erb
<%= form_for(@product) do |f| %>
<% if @product.errors.any? %>
<div id="error_explanation">
<h2><%= pluralize(@product.errors.count, "error") %>
prohibited this product from being saved:</h2>
<ul>
<% @product.errors.full_messages.each do |msg| %>
<li><%= msg %></li>
<% end %>
</ul>
</div>
<% end %>

➤

<div class="field">
<%= f.label :title %><br />
<%= f.text_field :title %>
</div>
<div class="field">
<%= f.label :description %><br />
<%= f.text_area :description, rows: 6 %>
</div>
<div class="field">
<%= f.label :image_url %><br />
<%= f.text_field :image_url %>
</div>

report erratum • discuss

Iteration A1: Creating the Products Maintenance Application

•

67

<div class="field">
<%= f.label :price %><br />
<%= f.text_field :price %>
</div>
<div class="actions">
<%= f.submit %>
</div>
<% end %>

We will explore this more in Chapter 8, Task C: Catalog Display, on page 91.
But for now, we’ve adjusted one field to taste, so let’s go ahead and fill it in:

Click the Create button, and you should see the new product was successfully
created. If you now click the Back link, you should see the new product in
the list:

report erratum • discuss

68

•

Chapter 6. Task A: Creating the Application

Perhaps it isn’t the prettiest interface, but it works, and we can show it to
our client for approval. She can play with the other links (showing details,
editing existing products, and so on). We explain to her that this is only a
first step—we know it’s rough, but we wanted to get her feedback early. (And
four commands probably count as early in anyone’s book.)
At this point, you’ve accomplished a lot with only four commands. Before we
move on, let’s try one more command:
rake test

Included in the output should be two lines that each say 0 failures, 0 errors. This
is for the unit and functional, tests that Rails generates along with the scaffolding. They are minimal at this point, but simply knowing that they are
there and that they pass should give you confidence. As you proceed through
these chapters in Part II, you are encouraged to run this command frequently
because it will help you spot and track down errors. We will cover this more
in Section 7.2, Iteration B2: Unit Testing of Models, on page 82.
Note that if you’ve used a database other than SQLite3, this step may have
failed. Check your database.yml file, and see the notes in Section 24.1, A StandAlone Application Using Active Record, on page 405.

6.2

Iteration A2: Making Prettier Listings
Our customer has one more request (customers always seem to have one
more request, don’t they?). The listing of all the products is ugly. Can we
“pretty it up” a bit? And, while we’re in there, can we also display the product
image along with the image URL?
We’re faced with a dilemma here. As developers, we’re trained to respond to
these kinds of requests with a sharp intake of breath, a knowing shake of the
head, and a murmured “You want what?” At the same time, we also like to
show off a bit. In the end, the fact that it’s fun to make these kinds of changes
using Rails wins out, and we fire up our trusty editor.
Before we get too far, though, it would be nice if we had a consistent set of
test data to work with. We could use our scaffold-generated interface and type
data in from the browser. However, if we did this, future developers working
on our codebase would have to do the same. And, if we were working as part
of a team on this project, each member of the team would have to enter their
own data. It would be nice if we could load the data into our table in a more
controlled way. It turns out that we can. Rails has the ability to import seed
data.

report erratum • discuss

Iteration A2: Making Prettier Listings

•

69

To start, we simply modify the file in the db directory named seeds.rb.
We then add the code to populate the products table. This uses the create()
method of the Product model. The following is an extract from that file. Rather
than type the file by hand, you might want to download the file from the
sample code available online.3

download
↪ on page xxii

While you’re there, copy the images4 into the app/assets/images directory in your
application. Be warned: this seeds.rb script removes existing data from the
products table before loading in the new data. You might not want to run it if
you’ve just spent several hours typing your own data into your application!
Download rails32/depot_a/db/seeds.rb
Product.delete_all
# . . .
Product.create(title: 'Programming Ruby 1.9',
description:
%{<p>
Ruby is the fastest growing and most exciting dynamic language
out there. If you need to get working programs delivered fast,
you should add Ruby to your toolbox.
</p>},
image_url: 'ruby.jpg',
price: 49.95)
# . . .

(Note that this code uses %{…}. This is an alternative syntax for doublequoted string literals, convenient for use with long strings. Note also that
because it uses Rails’ create() method, it will fail silently if records cannot be
inserted because of validation errors.)
To populate your products table with test data, run the following command:
depot> rake db:seed

Now let’s get the product listing tidied up. There are two pieces to this:
defining a set of style rules, and connecting these rules to the page by defining
an HTML class attribute on the page.
We need somewhere to put our style definitions. As you will continue to find
with Rails, there is a convention for this, and that the generate scaffold command
that you previously issued has already laid all of the necessary groundwork.
As such, we can proceed to fill in the currently empty stylesheet products.css.scss
in the directory app/assets/stylesheets.

3.
4.

http://media.pragprog.com/titles/rails4/code/rails32/depot_a/db/seeds.rb
http://media.pragprog.com/titles/rails4/code/rails32/depot_a/app/assets/images/

report erratum • discuss

70

•

Chapter 6. Task A: Creating the Application

Download rails32/depot_a/app/assets/stylesheets/products.css.scss
// Place all the styles related to the Products controller here.
// They will automatically be included in application.css.
// You can use Sass (SCSS) here: http://sass-lang.com/
➤ .products {
➤
table {
➤
border-collapse: collapse;
➤
}
➤
➤
table tr td {
➤
padding: 5px;
➤
vertical-align: top;
➤
}
➤
➤
.list_image {
➤
width: 60px;
➤
height: 70px;
➤
}
➤
➤
.list_description {
➤
width: 60%;
➤
➤
dl {
➤
margin: 0;
➤
}
➤
➤
dt {
➤
color:
#244;
➤
font-weight: bold;
➤
font-size:
larger;
➤
}
➤
➤
dd {
➤
margin: 0;
➤
}
➤
}
➤
➤
.list_actions {
➤
font-size:
x-small;
➤
text-align:
right;
➤
padding-left: 1em;
➤
}
➤
➤
.list_line_even {
➤
background:
#e0f8f8;
➤
}
➤
➤
.list_line_odd {
➤
background:
#f8b0f8;

report erratum • discuss

Iteration A2: Making Prettier Listings

•

71

➤
}
➤}

Look closely at this stylesheet and you will see that CSS rules are nested, in
that the rule for dl is defined inside the rule for .list_description, which itself is
defined inside the rule for products. This tends to make rules less repetitive,
and therefore easier to read, write, understand, and maintain.
At this point you are familiar with files ending with erb being preprocessed
for embedded Ruby expressions and statements. If you note that this file ends
with scss, you might guess that this means that the file is preprocessed as
Sassy CSS 5 before being served as css. And you would be right!
Again, just like ERb, SCSS does not interfere with writing correct CSS. What
SCSS does is provide additional syntax that makes your stylesheets easier
to author and easier to maintain. All of this is converted for you by SCSS to
standard CSS that your browser understands.
Finally, we will need to define the products class used by this stylesheet. If you
look at the .html.erb files we’ve created so far, you won’t find any reference to
stylesheets. You won’t even find the HTML <head> section where such references would normally live. Instead, Rails keeps a separate file that is used to
create a standard page environment for the entire application. This file, called
application.html.erb, is a Rails layout and lives in the layouts directory:
Download rails32/depot_a/app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
<title>Depot</title>
<%= stylesheet_link_tag
"application", :media => "all" %>
<%= javascript_include_tag "application" %>
<%= csrf_meta_tags %>
</head>
➤ <body class='<%= controller.controller_name %>'>
<%= yield %>
</body>
</html>

Because Rails loads all of the stylesheets all at once, we need a convention
to limit controller-specific rules to pages associated with that controller. Using
the controller_name as a class name is an easy way to accomplish that, and is
what we have done here.
5.

http://sass-lang.com/

report erratum • discuss

72

•

Chapter 6. Task A: Creating the Application

Now that we have the stylesheets all in place, we will use a simple table-based
template, editing the file index.html.erb in app/views/products, replacing the scaffoldgenerated view:
Download rails32/depot_a/app/views/products/index.html.erb
<h1>Listing products</h1>
<table>
<% @products.each do |product| %>
<tr class="<%= cycle('list_line_odd', 'list_line_even') %>">
<td>
<%= image_tag(product.image_url, class: 'list_image') %>
</td>
<td class="list_description">
<dl>
<dt><%= product.title %></dt>
<dd><%= truncate(strip_tags(product.description),
length: 80) %></dd>
</dl>
</td>
<td class="list_actions">
<%= link_to 'Show', product %><br/>
<%= link_to 'Edit', edit_product_path(product) %><br/>
<%= link_to 'Destroy', product,
confirm: 'Are you sure?',
method: :delete %>
</td>
</tr>
<% end %>
</table>
<br />
<%= link_to 'New product', new_product_path %>

Even this simple template uses a number of built-in Rails features:
• The rows in the listing have alternating background colors. The Rails
helper method called cycle() does this by setting the CSS class of each row
to either list_line_even or list_line_odd, automatically toggling between the two
style names on successive lines.
• The truncate() helper is used to display just the first eighty characters of
the description. But before we call truncate(), we called strip_tags() in order
to remove the HTML tags from the description.

report erratum • discuss

Iteration A2: Making Prettier Listings

•

73

• Look at the link_to 'Destroy' line. See how it has the parameter confirm: 'Are you
sure?'. If you click this link, Rails arranges for your browser to pop up a
dialog box asking for confirmation before following the link and deleting
the product. (Also, see the sidebar on page 74 for some inside scoop on
this action.)
We loaded some test data into the database, we rewrote the index.html.erb file
that displays the listing of products, we filled in the products.css.scss stylesheet,
and that stylesheet was loaded into our page by the layout file application.html.erb.
Now, let’s bring up a browser and point to http://localhost:3000/products;
the resulting product listing might look something like the following:

So, we proudly show our customer her new product listing, and she’s pleased.
Now it is time to create the storefront.

What We Just Did
In this chapter, we laid the groundwork for our store application:
• We created a development database.
• We used migration to create and modify the schema in our development
database.
• We created the products table and used the scaffold generator to write an
application to maintain it.
• We updated an application-wide layout as well as a controller-specific
view in order to show a list of products.

report erratum • discuss

74

•

Chapter 6. Task A: Creating the Application

What’s with method: :delete?
You may have noticed that the scaffold-generated Destroy link includes the parameter
method: :delete. This determines which method is called in the ProductsController class and
also affects which HTTP method is used.
Browsers use HTTP to talk with servers. HTTP defines a set of verbs that browsers
can employ and defines when each can be used. A regular hyperlink, for example,
uses an HTTP GET request. A GET request is defined by HTTP to be used to retrieve
data; it isn’t supposed to have any side effects. Using this parameter in this way indicates that an HTTP DELETE method should be used for this hyperlink. Rails uses
this information to determine which action in the controller to route this request to.
Note that when used within a browser, Rails will substitute the POST HTTP method
for PUT and DELETE methods and in the process tack on an additional parameter
so that the router can determine the original intent. Either way, the request will not
be cached or triggered by web crawlers.

What we’ve done did not require much effort, and it got us up and running
quickly. Databases are vital to this application but need not be scary—in fact,
in many cases we can defer the selection of the database to later and simply
get started using the default that Rails provides.
Getting the model right is more important at this stage. As we will soon see,
simple selection of data types doesn’t always fully capture the essence of all
the properties of the model, even in this small application, so that’s what we
will tackle next.

Playtime
Here’s some stuff to try on your own:
• If you’re feeling frisky, you can experiment with rolling back the migration.
Just type the following:
depot> rake db:rollback

Your schema will be transported back in time, and the products table will
be gone. Calling rake db:migrate again will re-create it. You will also want to
reload the seed data. More information can be found in Chapter 23, Migrations, on page 387.
• We mentioned version control in Version Control, on page 9, and now
would be a great point at which to save your work. Should you happen
to choose Git (highly recommended, by the way), there is a tiny bit of
configuration you need to do first; basically, all you need to do is provide
your name and email address:

report erratum • discuss

Iteration A2: Making Prettier Listings

•

75

depot> git config --global --add user.name "Sam Ruby"
depot> git config --global --add user.email rubys@intertwingly.net

You can verify the configuration with the following command:
depot> git config --file .gitconfig --list

Rails also provides a file named .gitignore, which tells Git which files are
not to be version controlled:
Download rails32/depot_a/.gitignore
# See http://help.github.com/ignore-files/ for more about ignoring files.
#
# If you find yourself ignoring temporary files generated by your text editor
# or operating system, you probably want to add a global ignore instead:
#
git config --global core.excludesfile ~/.gitignore_global
# Ignore bundler config
/.bundle
# Ignore the default SQLite database.
/db/*.sqlite3
# Ignore all logfiles and tempfiles.
/log/*.log
/tmp

Note that because this filename begins with a dot, Unix-based operating
systems won’t show it by default in directory listings. Use ls -a to see it.
At this point, you are fully configured. The only tasks that remain are to
initialize a repository, add all the files, and commit them with a commit
message:
depot> git init
depot> git add .
depot> git commit -m "Depot Scaffold"

This may not seem very exciting at this point, but it does mean you are
more free to experiment. Should you overwrite or delete a file that you
didn’t mean to, you can always get back to this point by issuing a single
command:
depot> git checkout .

report erratum • discuss

In this chapter, we’ll see
• performing validation and error reporting, and
• unit testing.

CHAPTER 7

Task B: Validation and Unit Testing
At this point, we have an initial model for a product, as well as a complete
maintenance application for this data provided for us by Rails scaffolding. In
this chapter, we are going to focus on making the model more bulletproof—as
in, making sure that errors in the data provided never get committed to the
database—before we proceed to other aspects of the Depot application in
subsequent chapters.

7.1

Iteration B1: Validating!
While playing with the results of iteration A1, our client noticed something.
If she entered an invalid price or forgot to set up a product description, the
application happily accepted the form and added a line to the database.
Although a missing description is embarrassing, a price of $0.00 actually
costs her money, so she asked that we add validation to the application. No
product should be allowed in the database if it has an empty title or description field, an invalid URL for the image, or an invalid price.
So, where do we put the validation? The model layer is the gatekeeper between
the world of code and the database. Nothing to do with our application comes
out of the database or gets stored into the database that doesn’t first go
through the model. This makes models an ideal place to put validations; it
doesn’t matter whether the data comes from a form or from some programmatic manipulation in our application. If a model checks it before writing to
the database, then the database will be protected from bad data.
Let’s look again at the source code of the model class (in app/models/product.rb):
class Product < ActiveRecord::Base
end

report erratum • discuss

78

•

Chapter 7. Task B: Validation and Unit Testing

Adding our validation should be fairly clean. Let’s start by validating that the
text fields all contain something before a row is written to the database. We
do this by adding some code to the existing model:
validates :title, :description, :image_url, presence: true

The validates() method is the standard Rails validator. It will check one or more
model fields against one or more conditions.
presence: true tells the validator to check that each of the named fields is present

and its contents are not empty. In Figure 9, Validating that fields are present,
on page 79, we can see what happens if we try to submit a new product with
none of the fields filled in. It’s pretty impressive: the fields with errors are
highlighted, and the errors are summarized in a nice list at the top of the
form. That’s not bad for one line of code. You might also have noticed that
after editing and saving the product.rb file you didn’t have to restart the application to test your changes—the same reloading that caused Rails to notice
the earlier change to our schema also means it will always use the latest
version of our code.
We’d also like to validate that the price is a valid, positive number. We’ll use
the delightfully named numericality() option to verify that the price is a valid
number. We also pass the rather verbosely named :greater_than_or_equal_to option
a value of 0.01:
validates :price, numericality: {greater_than_or_equal_to: 0.01}

Now, if we add a product with an invalid price, the appropriate message will
appear, as shown in Figure 10, The price fails validation., on page 80.
Why test against 1 cent, rather than zero? Well, it’s possible to enter a number
such as 0.001 into this field. Because the database stores just two digits after
the decimal point, this would end up being zero in the database, even though
it would pass the validation if we compared against zero. Checking that the
number is at least 1 cent ensures only correct values end up being stored.
We have two more items to validate. First, we want to make sure each product
has a unique title. One more line in the Product model will do this. The
uniqueness validation will perform a simple check to ensure that no other
row in the products table has the same title as the row we’re about to save:
validates :title, uniqueness: true
regular expression
↪ on page 42

Lastly, we need to validate that the URL entered for the image is valid. We’ll
do this using the format option, which matches a field against a regular expression. For now we’ll just check that the URL ends with one of .gif, .jpg, or .png.

report erratum • discuss

Iteration B1: Validating!

•

79

Figure 9—Validating that fields are present

validates :image_url, allow_blank: true, format: {
with:
%r{\.(gif|jpg|png)$}i,
message: 'must be a URL for GIF, JPG or PNG image.'
}

Later, we’d probably want to change this form to let the user select from a
list of available images, but we’d still want to keep the validation to prevent
malicious folks from submitting bad data directly.
So, in a couple of minutes we’ve added validations that check the following:
•
•
•
•

The
The
The
The

field’s title, description, and image URL are not empty.
price is a valid number not less than $0.01.
title is unique among all products.
image URL looks reasonable.

Your updated Product model should look like this:

report erratum • discuss

80

•

Chapter 7. Task B: Validation and Unit Testing

Figure 10—The price fails validation.

Download rails32/depot_b/app/models/product.rb
class Product < ActiveRecord::Base
validates :title, :description, :image_url, presence: true
validates :price, numericality: {greater_than_or_equal_to: 0.01}
validates :title, uniqueness: true
validates :image_url, allow_blank: true, format: {
with:
%r{\.(gif|jpg|png)$}i,
message: 'must be a URL for GIF, JPG or PNG image.'
}
end

Nearing the end of this cycle, we ask our customer to play with the application,
and she’s a lot happier. It took only a few minutes, but the simple act of
adding validation has made the product maintenance pages seem a lot more
solid.
Before we move on, we once again try our tests:
rake test

Uh-oh. This time we see failures. Two, actually—one in should create product and
one in should update product. Clearly something we did caused something to do

report erratum • discuss

Iteration B1: Validating!

•

81

with the creation and updating of products to fail. This isn’t all that surprising.
After all, when you think about it, isn’t that the whole point of validation?
The solution is to give valid test data in test/functional/products_controller_test.rb:
Download rails32/depot_b/test/functional/products_controller_test.rb
require 'test_helper'

➤
➤
➤
➤
➤
➤

class ProductsControllerTest < ActionController::TestCase
setup do
@product = products(:one)
@update = {
title:
'Lorem Ipsum',
description: 'Wibbles are fun!',
image_url:
'lorem.jpg',
price:
19.95
}
end
test "should get index" do
get :index
assert_response :success
assert_not_nil assigns(:products)
end
test "should get new" do
get :new
assert_response :success
end

➤

test "should create product" do
assert_difference('Product.count') do
post :create, product: @update
end
assert_redirected_to product_path(assigns(:product))
end

➤

# ...
test "should update product" do
put :update, id: @product, product: @update
assert_redirected_to product_path(assigns(:product))
end
# ...
end

After making this change, we rerun the tests, and they report that all is well.
But all that means is that we didn’t break anything. We need to do more than
that. We need to make sure the validation code that we just added not only

report erratum • discuss

82

•

Chapter 7. Task B: Validation and Unit Testing

works now but will continue to work as we make further changes. We’ll cover
functional tests in more detail in Section 8.4, Iteration C4: Functional Testing
of Controllers, on page 100. As for now, it is time for us to write some unit tests.

7.2

Iteration B2: Unit Testing of Models
One of the real joys of the Rails framework is that it has support for testing
baked right in from the start of every project. As we have seen, from the
moment you create a new application using the rails command, Rails starts
generating a test infrastructure for you.
Let’s take a peek inside the unit subdirectory to see what’s already there:
depot> ls test/unit
helpers product_test.rb

product_test.rb is the file that Rails created to hold the unit tests for the model

we created earlier with the generate script. This is a good start, but Rails can
help us only so much.
Let’s see what kind of test goodies Rails generated inside test/unit/product_test.rb
when we generated that model:
Download rails32/depot_a/test/unit/product_test.rb
require 'test_helper'
class ProductTest < ActiveSupport::TestCase
# test "the truth" do
#
assert true
# end
end

The generated ProductTest is a subclass of ActiveSupport::TestCase. The fact that
ActiveSupport::TestCase is a subclass of the Test::Unit::TestCase class tells us that
Rails generates tests based on the Test::Unit framework that comes preinstalled with Ruby. This is good news because it means if we’ve already been
testing our Ruby programs with Test::Unit tests (and why wouldn’t we be?),
then we can build on that knowledge to test Rails applications. If you’re new
to Test::Unit, don’t worry. We’ll take it slow.
Inside this test case, Rails generated a single commented out test called "the
truth". The test...do syntax may seem surprising at first, but here Active Support
is combining a class method, optional parentheses, and a block to make
defining a test method just the tiniest bit simpler for you. Sometimes it is the
little things that make all the difference.

report erratum • discuss

Iteration B2: Unit Testing of Models

•

83

The assert line in this method is an actual test. It isn’t much of one, though—all
it does is test that true is true. Clearly, this is a placeholder, one that is intended to be replaced by your actual tests.

A Real Unit Test
Let’s get onto the business of testing validation. First, if we create a product
with no attributes set, we’ll expect it to be invalid and for there to be an error
associated with each field. We can use the model’s errors() and invalid?() methods
to see whether it validates, and we can use the any?() method of the error list
to see whether there is an error associated with a particular attribute.
Now that we know what to test, we need to know how to tell the test framework
whether our code passes or fails. We do that using assertions. An assertion
is simply a method call that tells the framework what we expect to be true.
The simplest assertion is the method assert(), which expects its argument to
be true. If it is, nothing special happens. However, if the argument to assert()
is false, the assertion fails. The framework will output a message and will
stop executing the test method containing the failure. In our case, we expect
that an empty Product model will not pass validation, so we can express that
expectation by asserting that it isn’t valid.
assert product.invalid?

Replace the the truth test with the following code:
Download rails32/depot_b/test/unit/product_test.rb
test "product attributes must not be empty" do
product = Product.new
assert product.invalid?
assert product.errors[:title].any?
assert product.errors[:description].any?
assert product.errors[:price].any?
assert product.errors[:image_url].any?
end

We can rerun just the unit tests by issuing the command rake test:units. When
we do so, we now see the test executed successfully:
depot> rake test:units
Loaded suite lib/rake/rake_test_loader
Started
ProductTest:
PASS product attributes must not be empty (0.23s)
Finished in 0.231576 seconds.
1 tests, 5 assertions, 0 failures, 0 errors, 0 skips

report erratum • discuss

84

•

Chapter 7. Task B: Validation and Unit Testing

Sure enough, the validation kicked in, and all our assertions passed.
Clearly at this point we can dig deeper and exercise individual validations.
Let’s look at just three of the many possible tests.
First, we’ll check that the validation of the price works the way we expect:
Download rails32/depot_c/test/unit/product_test.rb
test "product price must be positive" do
product = Product.new(title:
"My Book Title",
description: "yyy",
image_url:
"zzz.jpg")
product.price = -1
assert product.invalid?
assert_equal "must be greater than or equal to 0.01",
product.errors[:price].join('; ')
product.price = 0
assert product.invalid?
assert_equal "must be greater than or equal to 0.01",
product.errors[:price].join('; ')
product.price = 1
assert product.valid?
end

In this code we create a new product and then try setting its price to -1, 0,
and +1, validating the product each time. If our model is working, the first
two should be invalid, and we verify the error message associated with the
price attribute is what we expect. Because the list of error messages is an array,
we use the handy join1 method to concatenate each message, and we express
the assertion this way in order to verify that there is only one such message.
The last price is acceptable, so we assert that the model is now valid. (Some
folks would put these three tests into three separate test methods—that’s
perfectly reasonable.)
Next, we’ll test that we’re validating that the image URL ends with one of .gif,
.jpg, or .png:
Download rails32/depot_c/test/unit/product_test.rb
def new_product(image_url)
Product.new(title:
"My Book Title",
description: "yyy",
price:
1,
image_url:
image_url)
end
test "image url" do

1.

http://ruby-doc.org/core/classes/Array.html#M002182

report erratum • discuss

Iteration B2: Unit Testing of Models

•

85

ok = %w{ fred.gif fred.jpg fred.png FRED.JPG FRED.Jpg
http://a.b.c/x/y/z/fred.gif }
bad = %w{ fred.doc fred.gif/more fred.gif.more }
ok.each do |name|
assert new_product(name).valid?, "#{name} shouldn't be invalid"
end
bad.each do |name|
assert new_product(name).invalid?, "#{name} shouldn't be valid"
end
end

Here we’ve mixed things up a bit. Rather than write out the nine separate
tests, we’ve used a couple of loops—one to check the cases we expect to pass
validation and the second to try cases we expect to fail. At the same time, we
factored out the common code between the two loops.
You’ll notice that we’ve also added an extra parameter to our assert method
calls. All of the testing assertions accept an optional trailing parameter
containing a string. This will be written along with the error message if the
assertion fails and can be useful for diagnosing what went wrong.
Finally, our model contains a validation that checks that all the product titles
in the database are unique. To test this one, we’re going to need to store
product data in the database.
One way to do this would be to have a test create a product, save it, then
create another product with the same title, and try to save it too. This would
clearly work. But there’s a much simpler way—we can use Rails fixtures.

Test Fixtures
In the world of testing, a fixture is an environment in which you can run a
test. If you’re testing a circuit board, for example, you might mount it in a
test fixture that provides it with the power and inputs needed to drive the
function to be tested.
In the world of Rails, a test fixture is simply a specification of the initial contents of a model (or models) under test. If, for example, we want to ensure
that our products table starts off with known data at the start of every unit test,
we can specify those contents in a fixture, and Rails will take care of the rest.
You specify fixture data in files in the test/fixtures directory. These files contain
test data in either comma-separated value (CSV) or YAML format. For our
tests, we’ll use YAML, the preferred format. Each fixture file contains the data
for a single model. The name of the fixture file is significant; the base name
of the file must match the name of a database table. Because we need some

YAML
↪ on page 48

report erratum • discuss

86

•

Chapter 7. Task B: Validation and Unit Testing

data for a Product model, which is stored in the products table, we’ll add it to the
file called products.yml.
Rails already created this fixture file when we first created the model:
Download rails32/depot_b/test/fixtures/products.yml
# Read about fixtures at
# http://api.rubyonrails.org/classes/ActiveRecord/Fixtures.html
one:
title: MyString
description: MyText
image_url: MyString
price: 9.99
two:
title: MyString
description: MyText
image_url: MyString
price: 9.99

The fixture file contains an entry for each row that we want to insert into the
database. Each row is given a name. In the case of the Rails-generated fixture,
the rows are named one and two. This name has no significance as far as the
database is concerned—it is not inserted into the row data. Instead, as we’ll
see shortly, the name gives us a convenient way to reference test data inside
our test code. They also are the names used in the generated integration tests,
so for now, we’ll leave them alone.
Inside each entry you’ll see an indented list of name/value pairs. Just like in
your config/database.yml, you must use spaces, not tabs, at the start of each of
the data lines, and all the lines for a row must have the same indentation.
Be careful as you make changes because you will need to make sure the
names of the columns are correct in each entry; a mismatch with the database
column names may cause a hard-to-track-down exception.
Let’s add some more data to the fixture file with something we can use to test
our Product model:
Download rails32/depot_c/test/fixtures/products.yml
ruby:
title:
Programming Ruby 1.9
description:
Ruby is the fastest growing and most exciting dynamic
language out there. If you need to get working programs
delivered fast, you should add Ruby to your toolbox.
price:
49.50
image_url:
ruby.png

report erratum • discuss

Iteration B2: Unit Testing of Models

•

87

David says:

Picking Good Fixture Names
Just like the names of variables in general, you want to keep the names of fixtures
as self-explanatory as possible. This increases the readability of the tests when you’re
asserting that product(:valid_order_for_fred) is indeed Fred’s valid order. It also makes it a
lot easier to remember which fixture you’re supposed to test against without having
to look up p1 or order4. The more fixtures you get, the more important it is to pick good
fixture names. So, starting early keeps you happy later.
But what do we do with fixtures that can’t easily get a self-explanatory name like
valid_order_for_fred? Pick natural names that you have an easier time associating to a
role. For example, instead of using order1, use christmas_order. Instead of customer1, use
fred. Once you get into the habit of natural names, you’ll soon be weaving a nice little
story about how fred is paying for his christmas_order with his invalid_credit_card first, then
paying with his valid_credit_card, and finally choosing to ship it all off to aunt_mary.
Association-based stories are key to remembering large worlds of fixtures with ease.

Now that we have a fixture file, we want Rails to load the test data into the
products table when we run the unit test. And, in fact, Rails is already doing
this (convention over configuration for the win!), but you can control which
fixtures to load by specifying the following line in test/unit/product_test.rb:
➤

class ProductTest < ActiveSupport::TestCase
fixtures :products
#...
end

The fixtures() directive loads the fixture data corresponding to the given model
name into the corresponding database table before each test method in the
test case is run. The name of the fixture file determines the table that is
loaded, so using :products will cause the products.yml fixture file to be used.
Let’s say that again another way. In the case of our ProductTest class, adding
the fixtures directive means that the products table will be emptied out and then
populated with the three rows defined in the fixture before each test method
is run.
Note that most of the scaffolding that Rails generates doesn’t contain calls to
the fixtures method. That’s because the default for tests is to load all fixtures
before running the test. Because that default is generally the one you want,
there usually isn’t any need to change it. Once again, conventions are used
to eliminate the need for unnecessary configuration.

report erratum • discuss

88

•

Chapter 7. Task B: Validation and Unit Testing

The products() method indexes into the table created by loading the fixture. We
need to change the index used to match the name we gave in the fixture itself.
So far, we’ve been doing all our work in the development database. Now that
we’re running tests, though, Rails needs to use a test database. If you look
in the database.yml file in the config directory, you’ll notice Rails actually created
a configuration for three separate databases:
• db/development.sqlite3 will be our development database. All of our programming work will be done here.
• db/test.sqlite3 is a test database.
• db/production.sqlite3 is the production database. Our application will use this
when we put it online.
Each test method gets a freshly initialized table in the test database, loaded
from the fixtures we provide. This is automatically done by the rake test command but can be done separately by running rake db:test:prepare.

Using Fixture Data
Now that we know how to get fixture data into the database, we need to find
ways of using it in our tests.
Clearly, one way would be to use the finder methods in the model to read the
data. However, Rails makes it easier than that. For each fixture it loads into
a test, Rails defines a method with the same name as the fixture. You can
use this method to access preloaded model objects containing the fixture
data: simply pass it the name of the row as defined in the YAML fixture file,
and it’ll return a model object containing that row’s data. In the case of our
product data, calling products(:ruby) returns a Product model containing the data
we defined in the fixture. Let’s use that to test the validation of unique product
titles:
Download rails32/depot_c/test/unit/product_test.rb
test "product is not valid without a unique title" do
product = Product.new(title:
products(:ruby).title,
description: "yyy",
price:
1,
image_url:
"fred.gif")
assert !product.save
assert_equal "has already been taken", product.errors[:title].join('; ')
end

The test assumes that the database already includes a row for the Ruby book.
It gets the title of that existing row using this:
products(:ruby).title

report erratum • discuss

What We Just Did

•

89

It then creates a new Product model, setting its title to that existing title. It
asserts that attempting to save this model fails and that the title attribute has
the correct error associated with it.
If you want to avoid using a hard-coded string for the Active Record error,
you can compare the response against its built-in error message table:
Download rails32/depot_c/test/unit/product_test.rb
test "product is not valid without a unique title - i18n" do
product = Product.new(title:
products(:ruby).title,
description: "yyy",
price:
1,
image_url:
"fred.gif")
assert !product.save
assert_equal I18n.translate('activerecord.errors.messages.taken'),
product.errors[:title].join('; ')
end

We will cover the I18n functions in Chapter 15, Task J: Internationalization,
on page 209.
Now we can feel confident that our validation code not only works but will
continue to work. Our product now has a model, a set of views, a controller,
and a set of unit tests. It will serve as a good foundation upon which to build
the rest of the application.

7.3

What We Just Did
In just about a dozen lines of code, we augmented that generated code with
validation:
• We ensured that required fields were present.
• We ensured that price fields were numeric and at least one cent.
• We ensured that titles were unique.
• We ensured that images matched a given format.
• We updated the unit tests that Rails provided, both to conform to the
constraints we have imposed on the model and to verify the new code that
we added.
We show this to our customer, and although she agrees that this is something
an administrator could use, she says that it certainly isn’t anything that she
would feel comfortable turning loose on her customers. Clearly, in the next
iteration we are going to have to focus a bit on the user interface.

report erratum • discuss

90

•

Chapter 7. Task B: Validation and Unit Testing

Playtime
Here’s some stuff to try on your own:
• If you are using Git, now might be a good time to commit our work. You
can first see what files we changed by using the git status command:
depot> git status
# On branch master
# Changes not staged for commit:
#
(use "git add <file>..." to update what will be committed)
#
(use "git checkout -- <file>..." to discard changes in working directory)
#
# modified:
app/models/product.rb
# modified:
test/fixtures/products.yml
# modified:
test/functional/products_controller_test.rb
# modified:
test/unit/product_test.rb
# no changes added to commit (use "git add" and/or "git commit -a")

Since we only modified some existing files and didn’t add any new ones,
we can combine the git add and git commit commands and simply issue a
single git commit command with the -a option:
depot> git commit -a -m 'Validation!'

With this done, we can play with abandon, secure in the knowledge that
we can return to this state at any time using a single git checkout . command.
• The validation option :length checks the length of a model attribute. Add
validation to the Product model to check that the title is at least ten characters long.
• Change the error message associated with one of your validations.
(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

report erratum • discuss

In this chapter, we’ll see
• writing our own views,
• using layouts to decorate pages,
• integrating CSS,
• using helpers, and
• writing functional tests.

CHAPTER 8

Task C: Catalog Display
All in all, it’s been a successful set of iterations. We gathered the initial
requirements from our customer, documented a basic flow, worked out a first
pass at the data we’ll need, and put together the maintenance page for the
Depot application’s products. It hasn’t even taken many lines of code. We
even have a small but growing test suite.
Thus emboldened, it’s on to our next task. We chatted about priorities with
our customer, and she said she’d like to start seeing what the application
looks like from the buyer’s point of view. Our next task is to create a simple
catalog display.
This also makes a lot of sense from our point of view. Once we have the
products safely tucked into the database, it should be fairly simple to display
them. It also gives us a basis from which to develop the shopping cart portion
of the code later.
We should also be able to draw on the work we just did in the product
maintenance task—the catalog display is really just a glorified product listing.
Finally, we will also need to complement our unit tests for the model with
some functional tests for the controller.

8.1

Iteration C1: Creating the Catalog Listing
We’ve already created the products controller, used by the seller to administer
the Depot application. Now it’s time to create a second controller, one that
interacts with the paying customers. Let’s call it Store.
depot> rails generate controller Store index
create app/controllers/store_controller.rb
route get "store/index"
invoke erb
create
app/views/store

report erratum • discuss

92

•

Chapter 8. Task C: Catalog Display

create
invoke
create
invoke
create
invoke
create
invoke
invoke
create
invoke
create

app/views/store/index.html.erb
test_unit
test/functional/store_controller_test.rb
helper
app/helpers/store_helper.rb
test_unit
test/unit/helpers/store_helper_test.rb
assets
coffee
app/assets/javascripts/store.js.coffee
scss
app/assets/stylesheets/store.css.scss

Just as in the previous chapter, where we used the generate utility to create a
controller and associated scaffolding to administer the products, here we’ve
asked it to create a controller (class StoreController in the file store_controller.rb)
containing a single action method, index().
While everything is already set up for this action to be accessed via http://
localhost:3000/store/index (feel free to try it!), we can do better. Let’s simplify
things for the user and make this the root URL for the website. We do this
by editing config/routes.rb:
Download rails32/depot_d/config/routes.rb
Depot::Application.routes.draw do
get "store/index"
resources :products
# ...
# You can have the root of your site routed with "root"
# just remember to delete public/index.html.
# root :to => 'welcome#index'
➤
root to: 'store#index', as: 'store'
# ...
end

At the top of the file, you can see the lines added to support the store and
products controllers. We’ll leave those lines alone. Further along in the file
you will see a commented-out line that defines a root for the website. Either
uncomment out that line or add a new line immediately after that one. All we
are changing on that line is the name of the controller (from welcome to store)
and adding as: 'store'. The latter tells Rails to create a store_path variable. We
saw this before with say_goodbye_path on page 26.

report erratum • discuss

Iteration C1: Creating the Catalog Listing

•

93

Note that the comments also instruct you to delete public/index.html. Let’s do
that now:1
depot> rm public/index.html

Let’s try it. Point a browser at http://localhost:3000/, and up pops our web
page:

It might not make us rich, but at least we know everything is wired together
correctly. The page even tells us where to find the template file that draws
this page.
Let’s start by displaying a simple list of all the products in our database. We
know that eventually we’ll have to be more sophisticated, breaking them into
categories, but this will get us going.
We need to get the list of products out of the database and make it available
to the code in the view that will display the table. This means we have to
change the index() method in store_controller.rb. We want to program at a decent
level of abstraction, so let’s just assume we can ask the model for a list of the
products we can sell:
Download rails32/depot_d/app/controllers/store_controller.rb
class StoreController < ApplicationController
def index
➤
@products = Product.order(:title)
end
end

We ask our customer whether she had a preference regarding the order things
should be listed in, and we jointly decided to see what happened if we displayed the products in alphabetical order. We do this by adding a order(:title)
call to the Product model.

1.

Windows users will want to execute erase public\index.html; if you are managing your source
code using Git, you will want to use git rm public/index.html.

report erratum • discuss

94

•

Chapter 8. Task C: Catalog Display

Now we need to write our view template. To do this, edit the file index.html.erb
in app/views/store. (Remember that the path name to the view is built from the
name of the controller [store] and the name of the action [index]. The .html.erb
part signifies an ERB template that produces an HTML result.)
Download rails32/depot_d/app/views/store/index.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<h1>Your Pragmatic Catalog</h1>
<% @products.each do |product| %>
<div class="entry">
<%= image_tag(product.image_url) %>
<h3><%= product.title %></h3>
<%= sanitize(product.description) %>
<div class="price_line">
<span class="price"><%= product.price %></span>
</div>
</div>
<% end %>

Note the use of the sanitize() method for the description. This allows us to
safely add HTML stylings to make the descriptions more interesting for our
customers. Note that this decision opens a potential security hole,2 but
because product descriptions are created by people who work for our company,
we think that the risk is minimal.
We’ve also used the image_tag() helper method. This generates an HTML <img>
tag using its argument as the image source.
Next we add a stylesheet, making use of the fact that we set things up so that
pages created by the StoreController will define an HTML class by the name of
store:
Download rails32/depot_d/app/assets/stylesheets/store.css.scss
// Place all the styles related to the Store controller here.
// They will automatically be included in application.css.
// You can use Sass (SCSS) here: http://sass-lang.com/
➤ .store {
➤
h1 {
➤
margin: 0;
➤
padding-bottom: 0.5em;
➤
font: 150% sans-serif;
➤
color: #226;

2.

http://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29

report erratum • discuss

Iteration C1: Creating the Catalog Listing
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤}

•

95

border-bottom: 3px dotted #77d;
}
/* An entry in the store catalog */
.entry {
overflow: auto;
margin-top: 1em;
border-bottom: 1px dotted #77d;
min-height: 100px;
img {
width: 80px;
margin-right: 5px;
margin-bottom: 5px;
position: absolute;
}
h3 {
font-size: 120%;
font-family: sans-serif;
margin-left: 100px;
margin-top: 0;
margin-bottom: 2px;
color: #227;
}
p, div.price_line {
margin-left: 100px;
margin-top: 0.5em;
margin-bottom: 0.8em;
}
.price {
color: #44a;
font-weight: bold;
margin-right: 3em;
}
}

Hitting Refresh brings up the display shown on Figure 11, Our first (ugly)
catalog page, on page 96. It is still pretty basic…it seems to be missing
something. The customer happens to be walking by as we ponder this, and
she points out that she’d also like to see a decent-looking banner and sidebar
on public-facing pages.
At this point in the real world, we’d probably want to call in the design
folks—we’ve all seen too many programmer-designed websites to feel comfortable inflicting another on the world. But Pragmatic Web Designer is off getting

report erratum • discuss

96

•

Chapter 8. Task C: Catalog Display

Figure 11—Our first (ugly) catalog page

inspiration on a beach somewhere and won’t be back until later in the year,
so let’s put a placeholder in for now. It’s time for another iteration.

8.2

Iteration C2: Adding a Page Layout
The pages in a typical website often share a similar layout—the designer will
have created a standard template that is used when placing content. Our job
is to modify this page to add decoration to each of the store pages.
So far, we’ve only made minimal changes to application.html.erb, namely to add
a class attribute in Iteration A2 on page 71. As this file is the layout used for
all views for all controllers that don’t otherwise provide a layout, we can
change the look and feel of the entire site by editing just one file. This makes
us feel better about putting a placeholder page layout in for now; we can
update it when the designer eventually returns from the islands.
Let’s update this file to define a banner and a sidebar:

Line 1
5
-

Download rails32/depot_e/app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
<title>Pragprog Books Online Store</title>
<%= stylesheet_link_tag "application" %>
<%= javascript_include_tag "application" %>
<%= csrf_meta_tag %>
</head>
<body class="<%= controller.controller_name %>">

report erratum • discuss

Iteration C2: Adding a Page Layout

10
15
20
25
-

•

97

<div id="banner">
<%= image_tag("logo.png") %>
<%= @page_title || "Pragmatic Bookshelf" %>
</div>
<div id="columns">
<div id="side">
<ul>
<li><a href="http://www....">Home</a></li>
<li><a href="http://www..../faq">Questions</a></li>
<li><a href="http://www..../news">News</a></li>
<li><a href="http://www..../contact">Contact</a></li>
</ul>
</div>
<div id="main">
<%= yield %>
</div>
</div>
</body>
</html>

Apart from the usual HTML gubbins, this layout has three Rails-specific items.
Line 5 uses a Rails stylesheet_link_tag() helper method to generate a <link> tag
to our application’s stylesheet. Similarly, line 6 generates a <link> to our
application’s scripts. Finally, line 7 sets up all the behind-the-scenes data
needed to prevent cross-site request forgery attacks, which will be important
once we add forms in Chapter 12, Task G: Check Out!, on page 153.
On line 12, we set the page heading to the value in the instance variable
@page_title. The real magic, however, takes place on line 24. When we invoke
yield, Rails automatically substitutes in the page-specific content—the stuff
generated by the view invoked by this request. Here, this will be the catalog
page generated by index.html.erb.

yield
↪ on page 44

To make this all work, first rename the file application.css to application.css.scss,
and then add the following:
Download rails32/depot_e/app/assets/stylesheets/application.css.scss
/*
* This is a manifest file that'll be compiled into application.css, which will
* include all the files listed below.
*
* Any CSS and SCSS file within this directory, lib/assets/stylesheets,
* vendor/assets/stylesheets, or vendor/assets/stylesheets of plugins, if any,
* can be referenced here using a relative path.
*
* You're free to add application-wide styles to this file and they'll appear
* at the top of the compiled file, but it's generally better to create a new
* file per style scope.
*

report erratum • discuss

98

•

Chapter 8. Task C: Catalog Display

*= require_self
*= require_tree .
*/
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤

#banner {
background: #9c9;
padding: 10px;
border-bottom: 2px solid;
font: small-caps 40px/40px "Times New Roman", serif;
color: #282;
text-align: center;
img {
float: left;
}
}
#notice {
color: #000 !important;
border: 2px solid red;
padding: 1em;
margin-bottom: 2em;
background-color: #f0f0f0;
font: bold smaller sans-serif;
}
#columns {
background: #141;
#main {
margin-left: 17em;
padding: 1em;
background: white;
}
#side {
float: left;
padding: 1em 2em;
width: 13em;
background: #141;
ul {
padding: 0;
li {
list-style: none;
a {
color: #bfb;
font-size: small;

report erratum • discuss

Iteration C3: Using a Helper to Format the Price

•

99

➤
}
➤
}
➤
}
➤
}
➤}

As explained in the comments, this manifest file will automatically include
all stylesheets available in this directory and in any subdirectory. This is
accomplished via the require_tree directive.
We could instead list the names of individual stylesheets we want to be linked
in the stylesheet_link_tag(), but because we are in the layout for the entire application, and because this layout is already set up to load all stylesheets, we’ll
leave it alone for now.
Again we make heavy use of Sass, which is exactly what the file rename
enabled us to do. For example, there is a img selector nested inside the #banner
selector. There also is an a selector inside of the #side selector.
Hit Refresh, and the browser window looks something like Figure 12, Catalog
with layout added, on page 100. It won’t win any design awards, but it’ll show
our customer roughly what the final page will look like.
Looking at this page, we spot a minor problem with how prices are displayed.
The database stores the price as a number, but we’d like to show it as dollars
and cents. A price of 12.34 should be shown as $12.34, and 13 should display
as $13.00. We’ll tackle that next.

8.3

Iteration C3: Using a Helper to Format the Price
Ruby provides a sprintf() function that can be used to format prices. We could
place logic that makes use of this function directly in the view. For example,
we could say this:
<span class="price"><%= sprintf("$%0.02f", product.price) %></span>

This would work, but it embeds knowledge of currency formatting into the
view. Should we display prices of products in several places and want to
internationalize the application later, this would be a maintenance problem.
Instead, let’s use a helper method to format the price as a currency. Rails
has an appropriate one built in—it’s called number_to_currency().
Using our helper in the view is simple; in the index template, we change this:
<span class="price"><%= product.price %></span>

to the following:

report erratum • discuss

100

•

Chapter 8. Task C: Catalog Display

Figure 12—Catalog with layout added

Download rails32/depot_e/app/views/store/index.html.erb
<span class="price"><%= number_to_currency(product.price) %></span>

Sure enough, when we hit Refresh, we see a nicely formatted price, as in
Figure 13, Catalog with price formatted, on page 101.
Although it looks nice enough, we are starting to get a nagging feeling that
we really should be running and writing tests for all this new functionality,
particularly after our experience of adding logic to our model.

8.4

Iteration C4: Functional Testing of Controllers
Now for the moment of truth. Before we focus on writing new tests, we need
to determine whether we have actually broken anything. Remembering our
experience after we added validation logic to our model, with some trepidation
we run our tests again:
depot> rake test

This time, all is well. We added a lot, but we didn’t break anything. That’s a
relief, but our work is not yet done; we still need tests for what we just added.
The unit testing of models that we did previously seemed straightforward
enough. We called a method and compared what it returned against what we
expected it to return. But now we are dealing with a server that processes
requests and a user viewing responses in a browser. What we will need is

report erratum • discuss

Iteration C4: Functional Testing of Controllers

•

101

Figure 13—Catalog with price formatted

functional tests that verify that the model, view, and controller work well
together. Never fear, Rails makes this easy too.
First, let’s take a look at what Rails generated for us:
Download rails32/depot_d/test/functional/store_controller_test.rb
require 'test_helper'
class StoreControllerTest < ActionController::TestCase
test "should get index" do
get :index
assert_response :success
end
end

The should get index test gets the index and asserts that a successful response
is expected. That certainly seems straightforward enough. That’s a reasonable
beginning, but we also want to verify that the response contains our layout,
our product information, and our number formatting. Let’s see what that
looks like in code:

report erratum • discuss

102

•

Chapter 8. Task C: Catalog Display

Download rails32/depot_e/test/functional/store_controller_test.rb
require 'test_helper'

➤
➤
➤
➤

class StoreControllerTest < ActionController::TestCase
test "should get index" do
get :index
assert_response :success
assert_select '#columns #side a', minimum: 4
assert_select '#main .entry', 3
assert_select 'h3', 'Programming Ruby 1.9'
assert_select '.price', /\$[,\d]+\.\d\d/
end
end

The four lines we added take a look into the HTML that is returned, using
CSS selector notation. As a refresher, selectors that start with a number sign
(#) match on id attributes, selectors that start with a dot (.) match on class
attributes, and selectors that contain no prefix at all match on element names.
So, the first select test looks for an element named a that is contained in an
element with an id with a value of side, which is contained within an element
with an id with a value of columns. This test verifies that there are a minimum
of four such elements. Pretty powerful stuff, assert_select(), eh?
The next three lines verify that all of our products are displayed. The first
verifies that there are three elements with a class name of entry inside the
main portion of the page. The next line verifies that there is an h3 element
with the title of the Ruby book that we had entered previously. The third line
verifies that the price is formatted correctly. These assertions are based on
the test data that we had put inside our fixtures:
Download rails32/depot_e/test/fixtures/products.yml
# Read about fixtures at
# http://api.rubyonrails.org/classes/ActiveRecord/Fixtures.html
one:
title: MyString
description: MyText
image_url: MyString
price: 9.99
two:
title: MyString
description: MyText
image_url: MyString
price: 9.99
ruby:

report erratum • discuss

What We Just Did

•

103

title:
Programming Ruby 1.9
description:
Ruby is the fastest growing and most exciting dynamic
language out there. If you need to get working programs
delivered fast, you should add Ruby to your toolbox.
price:
49.50
image_url:
ruby.png

If you noticed, the type of test that assert_select() performs varies based on the
type of the second parameter. If it is a number, it will be treated as a quantity.
If it is a string, it will be treated as an expected result. Another useful type
of test is a regular expression, which is what we use in our final assertion.
We verify that there is a price that has a value that contains a dollar sign
followed by any number (but at least one), commas, or digits; followed by a
decimal point; followed by two digits.

regular expression
↪ on page 42

One final point before we move on: both validation and functional tests will
test the behavior of controllers only; they will not retroactively affect any
objects that already exist in the database or in fixtures. In the previous example, two products contain the same title. Such data will cause no problems
and will go undetected up to the point where such records are modified and
saved.
We’ve touched on only a few things that assert_select() can do. More information
can be found in the online documentation.3
That’s a lot of verification in just a few lines of code. We can see that it works
by rerunning just the functional tests (after all, that’s all we changed):
depot> rake test:functionals

Now we not only have something recognizable as a storefront, we have tests
that ensure that all of the pieces—the model, view, and controller—are all
working together to produce the desired result. Although this sounds like a
lot, with Rails it was easy. In fact, it was mostly HTML and CSS and not much
in the way of code or tests.

8.5

What We Just Did
We’ve put together the basis of the store’s catalog display. The steps were as
follows:
1. Create a new controller to handle customer-centric interactions.

3.

http://api.rubyonrails.org/classes/ActionDispatch/Assertions/SelectorAssertions.
html

report erratum • discuss

104

•

Chapter 8. Task C: Catalog Display

2. Implement the default index() action.
3. Add a call to the order() method within the Products controller to control
the order in which the items on the website are listed.
4. Implement a view (an .html.erb file) and a layout to contain it (another
.html.erb file).
5. Use a helper to format prices the way we want.
6. Make use of a CSS stylesheet.
7. Write functional tests for our controller.
It’s time to check it all in and move on to the next task, namely, making a
shopping cart!

Playtime
Here’s some stuff to try on your own:
• Add a date and time to the sidebar. It doesn’t have to update; just show
the value at the time the page was displayed.
• Experiment with setting various number_to_currency helper method options,
and see the effect on your catalog listing.
• Write some functional tests for the product maintenance application using
assert_select. The tests will need to be placed into the test/functional/products_controller_test.rb file.
• Just a reminder—the end of an iteration is a good time to save your work
using Git. If you have been following along, you have the basics you need
at this point. We will pick things back up, in terms of exploring more Git
functionality, in Prepping Your Deployment Server, on page 237.
(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

report erratum • discuss

In this chapter, we’ll see
• sessions and session management,
• adding relationships between models, and
• adding a button to add a product to a cart.

CHAPTER 9

Task D: Cart Creation
Now that we have the ability to display a catalog containing all our wonderful
products, it would be nice to be able to sell them. Our customer agrees, so
we’ve jointly decided to implement the shopping cart functionality next. This
is going to involve a number of new concepts, including sessions, relationships
between models, and adding a button to the view, so let’s get started.

9.1

Iteration D1: Finding a Cart
As users browse our online catalog, they will (we hope) select products to buy.
The convention is that each item selected will be added to a virtual shopping
cart, held in our store. At some point, our buyers will have everything they
need and will proceed to our site’s checkout, where they’ll pay for the stuff
in their cart.
This means that our application will need to keep track of all the items added
to the cart by the buyer. To do that, we’ll keep a cart in the database and
store its unique identifier, cart.id, in the session. Every time a request comes
in, we can recover the identity from the session and use it to find the cart in
the database.
Let’s go ahead and create a cart:
depot> rails generate scaffold cart
...
depot> rake db:migrate
== CreateCarts: migrating ====================================================
-- create_table(:carts)
-> 0.0012s
== CreateCarts: migrated (0.0014s) ===========================================

Rails makes the current session look like a hash to the controller, so we’ll
store the id of the cart in the session by indexing it with the symbol :cart_id.

report erratum • discuss

106

•

Chapter 9. Task D: Cart Creation

Download rails32/depot_f/app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
protect_from_forgery
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤

private
def current_cart
Cart.find(session[:cart_id])
rescue ActiveRecord::RecordNotFound
cart = Cart.create
session[:cart_id] = cart.id
cart
end
end

rescue
↪ on page 45

private
↪ on page 47

9.2

The current_cart() starts by getting the :cart_id from the session object and then
attempts to find a cart corresponding to this id. If such a cart record is not
found (which will happen if the id is nil or invalid for any reason), then this
method will proceed to create a new Cart, store the id of the created cart into
the session, and then return the new cart.
Note that we place the current_cart() method in the ApplicationController and mark
it as private. This treatment makes this method available only to controllers
and furthermore prevents Rails from ever making it available as an action on
the controller.

Iteration D2: Connecting Products to Carts
We’re looking at sessions because we need somewhere to keep our shopping
cart. We’ll cover sessions in more depth in Rails Sessions, on page 330, but
for now let’s move on to implement the cart.
Let’s keep things simple. A cart contains a set of products. Based on the Initial
guess at application data diagram on page 60, combined with a brief chat
with our customer, we can now generate the Rails models and populate the
migrations to create the corresponding tables:
depot> rails generate scaffold line_item product_id:integer cart_id:integer
...
depot> rake db:migrate
== CreateLineItems: migrating ================================================
-- create_table(:line_items)
-> 0.0013s
== CreateLineItems: migrated (0.0014s) =======================================

The database now has a place to store the relationships between line items,
carts, and products. However, the Rails application does not. We need to add
some declarations to our model files that specify their interrelationships.

report erratum • discuss

Iteration D2: Connecting Products to Carts

•

107

Open the newly created cart.rb file in app/models, and add a call to has_many():
Download rails32/depot_f/app/models/cart.rb
class Cart < ActiveRecord::Base
➤
has_many :line_items, dependent: :destroy
end

That has_many :line_items part of the directive is fairly self-explanatory: a cart
(potentially) has many associated line items. These are linked to the cart because each line item contains a reference to its cart’s id. The dependent: :destroy
part indicates that the existence of line items is dependent on the existence
of the cart. If we destroy a cart, deleting it from the database, we’ll want Rails
also to destroy any line items that are associated with that cart.
Next, we’ll specify links in the opposite direction, from the line item to the
carts and products tables. To do this, we use the belongs_to() declaration twice in
the line_item.rb file:
Download rails32/depot_f/app/models/line_item.rb
class LineItem < ActiveRecord::Base
➤
belongs_to :product
➤
belongs_to :cart
end

belongs_to tells Rails that rows in the line_items table are children of rows in the
carts and products tables. No line item can exist unless the corresponding cart

and product rows exist. There’s an easy way to remember where to put
belongs_to declarations: if a table has foreign keys, the corresponding model
should have a belongs_to for each.
Just what do these various declarations do? Basically, they add navigation
capabilities to the model objects. Because we added the belongs_to declaration
to LineItem, we can now retrieve its Product and display the book’s title:
li = LineItem.find(...)
puts "This line item is for #{li.product.title}"

And because Cart is declared to have many line items, we can reference them
(as a collection) from a cart object:
cart = Cart.find(...)
puts "This cart has #{cart.line_items.count} line items"

Now, for completeness, we should add a has_many directive to our Product model.
After all, if we have lots of carts, each product might have many line items
referencing it. This time, we will make use of validation code to prevent removal
of products that are referenced by line items.

report erratum • discuss

108

•

Chapter 9. Task D: Cart Creation

Download rails32/depot_f/app/models/product.rb
class Product < ActiveRecord::Base
➤
has_many :line_items
➤

before_destroy :ensure_not_referenced_by_any_line_item
#...

➤

private

➤
➤
➤
➤
➤
➤
➤
➤
➤

# ensure that there are no line items referencing this product
def ensure_not_referenced_by_any_line_item
if line_items.empty?
return true
else
errors.add(:base, 'Line Items present')
return false
end
end
end

Here we declare that a product has many line items and define a hook method
named ensure_not_referenced_by_any_line_item(). A hook method is a method that
Rails calls automatically at a given point in an object’s life. In this case, the
method will be called before Rails attempts to destroy a row in the database.
If the hook method returns false, the row will not be destroyed.
Note that we have direct access to the errors object. This is the same place that
the validates() stores error messages. Errors can be associated with individual
attributes, but in this case we associate the error with the base object itself.
We’ll have more to say about intermodel relationships starting in Specifying
Relationships in Models, on page 276.

9.3

Iteration D3: Adding a Button
Now that that’s done, it is time to add an Add to Cart button for each product.
There is no need to create a new controller or even a new action. Taking a
look at the actions provided by the scaffold generator, you find index(), show(),
new(), edit(), create(), update(), and destroy(). The one that matches this operation
is create(). (new() may sound similar, but its use is to get a form that is used to
solicit input for a subsequent create() action.)
Once this decision is made, the rest follows. What are we creating? Certainly
not a Cart or even a Product. What we are creating is a LineItem. Looking at the
comment associated with the create() method in app/controllers/line_items_controller.rb,

report erratum • discuss

Iteration D3: Adding a Button

•

109

you see that this choice also determines the URL to use (/line_items) and the
HTTP method (POST).
This choice even suggests the proper UI control to use. When we added links
before, we used link_to(), but links default to using HTTP GET. We want to use
POST, so we will add a button this time; this means we will be using the
button_to() method.
We could connect the button to the line item by specifying the URL, but again
we can let Rails take care of this for us by simply appending _path to the controller’s name. In this case, we will use line_items_path.
However, there’s a problem with this: how will the line_items_path method know
which product to add to our cart? We’ll need to pass it the id of the product
corresponding to the button. That’s easy enough—all we need to do is add
the :product_id option to the line_items_path() call. We can even pass in the product
instance itself—Rails knows to extract the id from the record in circumstances
such as these.
In all, the one line that we need to add to our index.html.erb looks like this:
Download rails32/depot_f/app/views/store/index.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<h1>Your Pragmatic Catalog</h1>
<% @products.each do |product| %>
<div class="entry">
<%= image_tag(product.image_url) %>
<h3><%= product.title %></h3>
<%= sanitize(product.description) %>
<div class="price_line">
<span class="price"><%= number_to_currency(product.price) %></span>
➤
<%= button_to 'Add to Cart', line_items_path(product_id: product) %>
</div>
</div>
<% end %>

There’s one more formatting issue. button_to creates an HTML <form>, and that
form contains an HTML <div>. Both of these are normally block elements,
which will appear on the next line. We’d like to place them next to the price,
so we need to add a little CSS magic to make them inline:
Download rails32/depot_f/app/assets/stylesheets/store.css.scss
p, div.price_line {
margin-left: 100px;

report erratum • discuss

110

•

Chapter 9. Task D: Cart Creation

margin-top: 0.5em;
margin-bottom: 0.8em;
form, div {
display: inline;
}
}

The ideal place to put these lines is within the rule for .entry which itself is
nested within the rule for .store.
Now our index page looks like Figure 14, Now there's an Add to Cart button.,
on page 111. But before we push the button, we need to modify the create()
method in the line items controller to expect a product id as a form parameter.
Here’s where we start to see how important the id field is in our models. Rails
identifies model objects (and the corresponding database rows) by their id
fields. If we pass an id to create(), we’re uniquely identifying the product to
add.
Why the create() method? The default HTTP method for a link is a get, the default
HTTP method for a button is a post, and Rails uses these conventions to determine which method to call. See the comments inside the app/controllers/
line_items_controller.rb file to see other conventions. We’ll be making extensive use
of these conventions inside the Depot application.
Now let’s modify the LineItemsController to find the shopping cart for the current
session (creating one if there isn’t one there already), add the selected product
to that cart, and display the cart contents. All we need to modify is a few lines
of code in the create() method in app/controllers/line_items_controller.rb:1
Download rails32/depot_f/app/controllers/line_items_controller.rb
def create
➤
@cart = current_cart
➤
product = Product.find(params[:product_id])
➤
@line_item = @cart.line_items.build(product: product)
respond_to do |format|
if @line_item.save
format.html { redirect_to @line_item.cart,
notice: 'Line item was successfully created.' }
format.json { render json: @line_item,
status: :created, location: @line_item }
else
format.html { render action: "new" }
format.json { render json: @line_item.errors,
status: :unprocessable_entity }
end

➤

1.

Some lines have been wrapped to fit on the page.

report erratum • discuss

Iteration D3: Adding a Button

•

111

Figure 14—Now there’s an Add to Cart button.

end
end

We use the current_cart() method we implemented in Iteration D1 on page 106 to
find (or create) a cart in the session. Next, we use the params object to get the
:product_id parameter from the request. The params object is important inside
Rails applications. It holds all of the parameters passed in a browser request.
We store the result in a local variable because there is no need to make this
available to the view.
We then pass that product we found into @cart.line_items.build. This causes a
new line item relationship to be built between the @cart object and the product.
You can build the relationship from either end, and Rails will take care of
establishing the connections on both sides.
We save the resulting line item into an instance variable named @line_item.
The remainder of this method takes care of handling errors, which we will
cover in more detail in Section 10.2, Iteration E2: Handling Errors, on page
119, and handling JSON requests. But for now, we only want to modify one
more thing: once the line item is created, we want to redirect you to the cart
instead of back to the line item itself. Since the line item object knows how
to find the cart object, all we need to do is add .cart to the method call.
As we changed the function of our controller, we know that we will need to
update the corresponding functional test. We need to pass a product id on
the call to create and change what we expect for the target of the redirect. We
do this by updating test/functional/line_items_controller_test.rb.

report erratum • discuss

112

•

Chapter 9. Task D: Cart Creation

Download rails32/depot_g/test/functional/line_items_controller_test.rb
test "should create line_item" do
assert_difference('LineItem.count') do
➤
post :create, product_id: products(:ruby).id
end
➤

assert_redirected_to cart_path(assigns(:line_item).cart)
end

While we haven’t talked about the assigns method to date, that’s because it
has been in generated scaffolding. This method gives us access to the instance
variables that have been (or can be) assigned by controller actions for use in
views.
We now rerun the functional tests:
depot> rake test:functionals

Confident that the code works as intended, we try the Add to Cart buttons in
our browser.
And here is what we see:

This is a bit underwhelming. Although we have scaffolding for the cart, when
we created it, we didn’t provide any attributes, so the view doesn’t have anything to show. For now, let’s write a trivial template (we’ll tart it up in a
minute):
Download rails32/depot_f/app/views/carts/show.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<h2>Your Pragmatic Cart</h2>
<ul>
<% @cart.line_items.each do |item| %>
<li><%= item.product.title %></li>
<% end %>
</ul>

report erratum • discuss

What We Just Did

•

113

So, with everything plumbed together, let’s hit Refresh in our browser and
see our simple view displayed:

Go back to http://localhost:3000/, the main catalog page, and add a different
product to the cart. You’ll see the original two entries plus our new item in
your cart. It looks like we have sessions working. It’s time to show our customer, so we call her over and proudly display our handsome new cart.
Somewhat to our dismay, she makes that tsk-tsk sound that customers make
just before telling you that you clearly don’t get something.
Real shopping carts, she explains, don’t show separate lines for two of the
same product. Instead, they show the product line once with a quantity of 2.
Looks like we’re lined up for our next iteration.

9.4

What We Just Did
It has been a busy, productive day so far. We’ve added a shopping cart to our
store, and along the way we’ve dipped our toes into some neat Rails features:
• We created a Cart object in one request and were able to successfully locate
the same cart in subsequent requests using a session object,
• We added a private method in the base class for all of our controllers,
making it accessible to all of our controllers,
• We created relationships between carts and line items and relationships
between line items and products, and we were able to navigate using
these relationships.
• We added a button that caused a product to be posted to a cart, causing
a new line item to be created.

report erratum • discuss

114

•

Chapter 9. Task D: Cart Creation

Playtime
Here’s some stuff to try on your own:
• Add a new variable to the session to record how many times the user has
accessed the store controller’s index action. Note that the first time this
page is accessed, your count won’t be in the session. You can test for this
with code like this:
if session[:counter].nil?
...

If the session variable isn’t there, you’ll need to initialize it. Then you’ll
be able to increment it.
• Pass this counter to your template, and display it at the top of the catalog
page. Hint: the pluralize helper (definition on page 354) might be useful when
forming the message you display.
• Reset the counter to zero whenever the user adds something to the cart.
• Change the template to display the counter only if it is greater than five.
(You’ll find hints at http://pragprog.com/wikis/wiki/RailsPlayTime.)

report erratum • discuss

In this chapter, we’ll see
• modifying the schema and existing data,
• error diagnosis and handling,
• the flash, and
• logging.

CHAPTER 10

Task E: A Smarter Cart
Although we have rudimentary cart functionality implemented, we have much
to do. To start with, we will need to recognize when customers add multiples
of the same item to the cart. Once that’s done, we will also have to make sure
that the cart itself can handle error cases and communicate problems encountered along the way to the customer or system administrator, as appropriate.

10.1 Iteration E1: Creating a Smarter Cart
Associating a count with each product in our cart is going to require us to
modify the line_items table. We’ve used migrations before; for example, we used
a migration in Applying the Migration, on page 64 to update the schema of
the database. While that was as part of creating the initial scaffolding for a
model, the basic approach is the same.
depot> rails generate migration add_quantity_to_line_items quantity:integer

Rails can tell from the name of the migration that you are adding one or more
columns to the line_items table and can pick up the names and data types for
each column from the last argument. The two patterns that Rails matches
on is add_XXX_to_TABLE and remove_XXX_from_TABLE where the value of XXX is
ignored; what matters is the list of column names and types that appear after
the migration name.
The only thing Rails can’t tell is what a reasonable default is for this column.
In many cases, a null value would do, but let’s make it the value 1 for existing
carts by modifying the migration before we apply it:
Download rails32/depot_g/db/migrate/20110711000004_add_quantity_to_line_items.rb
class AddQuantityToLineItems < ActiveRecord::Migration
def change
➤
add_column :line_items, :quantity, :integer, default: 1
end

report erratum • discuss

116

•

Chapter 10. Task E: A Smarter Cart

end

Once complete, we run the migration:
depot> rake db:migrate

Now we need a smart add_product() method in our Cart, one that checks whether
our list of items already includes the product we’re adding; if it does, it bumps
the quantity, and if it doesn’t, it builds a new LineItem:
Download rails32/depot_g/app/models/cart.rb
def add_product(product_id)
current_item = line_items.find_by_product_id(product_id)
if current_item
current_item.quantity += 1
else
current_item = line_items.build(product_id: product_id)
end
current_item
end

This code uses a clever little Active Record trick. You see that the first line of
the method calls find_by_product_id(). But we don’t define a method with that
name. However, Active Record notices the call to an undefined method and
spots that it starts with the string find_by and ends with the name of a column.
It then dynamically constructs a finder method for us, adding it to our class.
We talk more about these dynamic finders starting Dynamic Finders, on page
281.
We also need to modify the line item controller to make use of this method:
Download rails32/depot_g/app/controllers/line_items_controller.rb
def create
@cart = current_cart
product = Product.find(params[:product_id])
➤
@line_item = @cart.add_product(product.id)
respond_to do |format|
if @line_item.save
format.html { redirect_to @line_item.cart,
notice: 'Line item was successfully created.' }
format.json { render json: @line_item,
status: :created, location: @line_item }
else
format.html { render action: "new" }
format.json { render json: @line_item.errors,
status: :unprocessable_entity }
end
end
end

report erratum • discuss

Iteration E1: Creating a Smarter Cart

•

117

There’s one last quick change to the show view to use this new information:
Download rails32/depot_g/app/views/carts/show.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<h2>Your Pragmatic Cart</h2>
<ul>
<% @cart.line_items.each do |item| %>
➤
<li><%= item.quantity %> &times; <%= item.product.title %></li>
<% end %>
</ul>

Now that all the pieces are in place, we can go back to the store page and hit
the Add to Cart button for a product that is already in the cart. What we are
likely to see is a mixture of individual products listed separately and a single
product listed with a quantity of two. This is because we added a quantity of
1 to existing columns instead of collapsing multiple rows when possible. What
we need to do next is migrate the data.
We start by creating a migration:
depot> rails generate migration combine_items_in_cart

This time, Rails can’t infer what we are trying to do, so we can’t rely on the
generated change() method. What we need to do instead is to replace this
method with separate up() and down() methods. First the up() method:
Download rails32/depot_g/db/migrate/20110711000005_combine_items_in_cart.rb
def up
# replace multiple items for a single product in a cart with a single item
Cart.all.each do |cart|
# count the number of each product in the cart
sums = cart.line_items.group(:product_id).sum(:quantity)
sums.each do |product_id, quantity|
if quantity > 1
# remove individual items
cart.line_items.where(product_id: product_id).delete_all
# replace with a single item
cart.line_items.create(product_id: product_id, quantity: quantity)
end
end
end
end

This is easily the most extensive code we’ve seen so far. Let’s look at it in
small pieces:

report erratum • discuss

118

•

Chapter 10. Task E: A Smarter Cart

• We start by iterating over each cart.
iterating
↪ on page 44

• For each cart, we get a sum of the quantity fields for each of the line items
associated with this cart, grouped by product_id. The resulting sums will
be a list of ordered pairs of product_ids and quantity.
• We iterate over these sums, extracting the product_id and quantity from each.
• In cases where the quantity is greater than 1, we will delete all of the
individual line items associated with this cart and this product and replace
them with a single line item with the correct quantity.
Note how easily and elegantly Rails enables you to express this algorithm.
With this code in place, we apply this migration just like any other migration:
depot> rake db:migrate

We can immediately see the results by looking at the cart, as shown in Figure
15, A cart with quantities, on page 119. Although we have reason to be pleased
with ourselves, we are not done yet. An important principle of migrations is
that each step needs to be reversible, so we implement a down() too. This
method finds line items with a quantity of greater than 1; adds new line items
for this cart and product, each with a quantity of 1; and finally deletes the
line item. The following code accomplishes that:
Download rails32/depot_g/db/migrate/20110711000005_combine_items_in_cart.rb
def down
# split items with quantity>1 into multiple items
LineItem.where("quantity>1").each do |line_item|
# add individual items
line_item.quantity.times do
LineItem.create cart_id: line_item.cart_id,
product_id: line_item.product_id, quantity: 1
end
# remove original item
line_item.destroy
end
end

At this point, we can just as easily roll back our migration with a single
command:
depot> rake db:rollback

Once again, we can immediately inspect the results by looking at the cart, as
shown in Figure 16, A cart after the migration has been rolled back, on page
120. Once we reapply the migration (with the rake db:migrate command), we have

report erratum • discuss

Iteration E2: Handling Errors

•

119

Figure 15—A cart with quantities

a cart that maintains a count for each of the products it holds, and we have
a view that displays that count.
Happy that we have something presentable, we call our customer over and
show her the result of our morning’s work. She’s pleased—she can see the
site starting to come together. However, she’s also troubled, having just read
an article in the trade press on the way ecommerce sites are being attacked
and compromised daily. She read that one kind of attack involves feeding
requests with bad parameters into web applications, hoping to expose bugs
and security flaws. She noticed that the link to the cart looks like carts/nnn,
where nnn is our internal cart id. Feeling malicious, she manually types this
request into a browser, giving it a cart id of wibble. She’s not impressed when
our application displays the page in Figure 17, Our application spills its guts.,
on page 121. This reveals way too much information about our application. It
also seems fairly unprofessional. So, our next iteration will be spent making
the application more resilient.

10.2 Iteration E2: Handling Errors
Looking at the page displayed in on page 121, it’s apparent that our application
raised an exception at line 16 of the carts controller.1 That turns out to be
this line:
@cart = Cart.find(params[:id])

1.

Your line number might be different. We have some book-related formatting stuff in
our source files.

report erratum • discuss

120

•

Chapter 10. Task E: A Smarter Cart

Figure 16—A cart after the migration has been rolled back

If the cart cannot be found, Active Record raises a RecordNotFound exception,
which we clearly need to handle. The question arises—how?
We could just silently ignore it. From a security standpoint, this is probably
the best move, because it gives no information to a potential attacker. However,
it also means that should we ever have a bug in our code that generates bad
cart ids, our application will appear to the outside world to be unresponsive—no one will know there has been an error.
Instead, we’ll take two actions when an exception is raised. First, we’ll log the
fact to an internal log file using Rails’ logger facility.2 Second, we’ll redisplay
the catalog page, along with a short message to the user (something along
the lines of “Invalid cart”) so they can continue to use our site.
Rails has a convenient way of dealing with errors and error reporting. It defines
a structure called a flash. A flash is a bucket (actually closer to a Hash) in
which you can store stuff as you process a request. The contents of the flash
are available to the next request in this session before being deleted automatically. Typically the flash is used to collect error messages. For example, when
our show() method detects that it was passed an invalid cart id, it can store
that error message in the flash area and redirect to the index() action to redisplay the catalog. The view for the index action can extract the error and display
it at the top of the catalog page. The flash information is accessible within
the views by using the flash accessor method.

2.

http://guides.rubyonrails.org/debugging_rails_applications.html#the-logger

report erratum • discuss

Iteration E2: Handling Errors

•

121

Figure 17—Our application spills its guts.

Why couldn’t we just store the error in any old instance variable? Remember
that after a redirect is sent by our application to the browser, the browser
sends a new request back to our application. By the time we receive that
request, our application has moved on—all the instance variables from previous requests are long gone. The flash data is stored in the session in order
to make it available between requests.
Armed with all this background about flash data, we can now change our
show() method to intercept bad cart ids and report on the problem:

➤
➤
➤
➤
➤

➤

Download rails32/depot_h/app/controllers/carts_controller.rb
# GET /carts/1
# GET /carts/1.json
def show
begin
@cart = Cart.find(params[:id])
rescue ActiveRecord::RecordNotFound
logger.error "Attempt to access invalid cart #{params[:id]}"
redirect_to store_url, notice: 'Invalid cart'
else
respond_to do |format|
format.html # show.html.erb
format.json { render json: @cart }
end
end
end

The rescue clause intercepts the exception raised by Cart.find(). In the handler,
we do the following:

report erratum • discuss

122

•

Chapter 10. Task E: A Smarter Cart

• Use the Rails logger to record the error. Every controller has a logger
attribute. Here we use it to record a message at the error logging level.
• Redirect to the catalog display using the redirect_to() method. The :notice
parameter specifies a message to be stored in the flash as a notice. Why
redirect, rather than just display the catalog, here? If we redirect, the
user’s browser will end up displaying the store URL, rather than
http://.../cart/wibble. We expose less of the application this way. We also prevent
the user from retriggering the error by hitting the Reload button.
With this code in place, we can rerun our customer’s problematic query. This
time, when we enter the following URL:
http://localhost:3000/carts/wibble

we don’t see a bunch of errors in the browser. Instead, the catalog page is
displayed. If we look at the end of the log file (development.log in the log directory),
we’ll see our message:
Started GET "/carts/wibble" for 127.0.0.1 at 2011-05-27 12:16:28 -0400
Processing by CartsController#show as HTML
Parameters: {"id"=>"wibble"}
^[[1m^[[35mCart Load (0.1ms)^[[0m SELECT "carts".* FROM "carts" WHERE
"carts"."id" = ? LIMIT 1 [["id", "wibble"]]
➤ Attempt to access invalid cart wibble
Redirected to http://localhost:3000/
Completed 302 Found in 3ms

For a much more user-friendly result, see Figure 18, Much more user-oriented
error message, on page 123.
On Unix machines, we’d probably use a command such as tail or less to view
this file. On Windows, you could use your favorite editor. It’s often a good
idea to keep a window open showing new lines as they are added to this file.
In Unix you’d use tail -f. You can download a tail command for Windows from
http://gnuwin32.sourceforge.net/packages/coreutils.htm or get a GUI-based
tool from http://tailforwin32.sourceforge.net/. Finally, some OS X users use
Console.app to track log files. Just say open name.log at the command line.
It makes good sense to review this file periodically—it has a lot of useful information. For example, Rails 3.2 comes with a nice feature that automatically
explains queries that take more than half a second in the development mode.
This identifies places where you might need optimizations, such as adding
the proper indexes.
Sensing the end of an iteration, we call our customer over and show her that
the error is now properly handled. She’s delighted and continues to play with

report erratum • discuss

Iteration E3: Finishing the Cart

•

123

Figure 18—Much more user-oriented error message

the application. She notices a minor problem on our new cart display—there’s
no way to empty items out of a cart. This minor change will be our next iteration. We should make it before heading home.

10.3 Iteration E3: Finishing the Cart
We know by now that in order to implement the “empty cart” function, we
have to add a link to the cart and modify the destroy() method in the carts
controller to clean up the session. Let’s start with the template and again use
the button_to() method to put a button on the page:
Download rails32/depot_h/app/views/carts/show.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<h2>Your Pragmatic Cart</h2>
<ul>
<% @cart.line_items.each do |item| %>
<li><%= item.quantity %> &times; <%= item.product.title %></li>
<% end %>
</ul>
➤ <%= button_to 'Empty cart', @cart, method: :delete,
➤
confirm: 'Are you sure?' %>

report erratum • discuss

124

•

Chapter 10. Task E: A Smarter Cart

In the controller, we’ll modify the destroy() method to ensure that the user is
deleting their own cart (think about it!) and to remove the cart from the session
before redirecting to the index page with a notification message:
Download rails32/depot_h/app/controllers/carts_controller.rb
def destroy
➤
@cart = current_cart
@cart.destroy
➤
session[:cart_id] = nil
➤
➤

respond_to do |format|
format.html { redirect_to store_url,
notice: 'Your cart is currently empty' }
format.json { head :no_content }
end
end

And we update the corresponding test in test/functional/carts_controller_test.rb.
Download rails32/depot_i/test/functional/carts_controller_test.rb
test "should destroy cart" do
assert_difference('Cart.count', -1) do
➤
session[:cart_id] = @cart.id
delete :destroy, id: @cart
end
➤

assert_redirected_to store_path
end

Now when we view our cart and click the Empty cart button, we get taken back
to the catalog page, and a nice little message says this:

We can also remove the flash message that is automatically generated when
a line item is added:
Download rails32/depot_i/app/controllers/line_items_controller.rb
def create
@cart = current_cart
product = Product.find(params[:product_id])
@line_item = @cart.add_product(product.id)

➤

respond_to do |format|
if @line_item.save
format.html { redirect_to @line_item.cart }
format.json { render json: @line_item,
status: :created, location: @line_item }
else

report erratum • discuss

Iteration E3: Finishing the Cart

•

125

David says:

Battle of the Routes: product_path vs. product_url
It can seem hard in the beginning to know when to use product_path and when to use
product_url when you want to link or redirect to a given route. In reality, it’s really quite
simple.
When you use product_url, you’ll get the full enchilada with protocol and domain name,
like http://example.com/products/1. That’s the thing to use when you’re doing redirect_to because the HTTP spec requires a fully qualified URL when doing 302 Redirect
and friends. You also need the full URL if you’re redirecting from one domain to another, ala product_url(domain: "example2.com", product: product).
The rest of the time, you can happily use product_path. This will generate only the
/products/1 part, and that’s all you need when doing links or pointing forms, like link_to
"My lovely product", product_path(product).
Now the confusing part is that oftentimes the two are interchangeable because of
lenient browsers. You can do a redirect_to with a product_path and it’ll probably work, but
it won’t be valid according to spec. And you can link_to a product_url, but then you’re
littering up your HTML with needless characters, which is a bad idea too.

format.html { render action: "new" }
format.json { render json: @line_item.errors,
status: :unprocessable_entity }
end
end
end

And, finally, we’ll get around to tidying up the cart display. Rather than use
<li> elements for each item, let’s use a table. Again, we’ll rely on CSS to do
the styling:
Download rails32/depot_i/app/views/carts/show.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<div class="cart_title">Your Cart</div>
<table>
<% @cart.line_items.each do |item| %>
<tr>
<td><%= item.quantity %>&times;</td>
<td><%= item.product.title %></td>
<td class="item_price"><%= number_to_currency(item.total_price) %></td>
</tr>
<% end %>
<tr class="total_line">

report erratum • discuss

126

•

Chapter 10. Task E: A Smarter Cart

<td colspan="2">Total</td>
<td class="total_cell"><%= number_to_currency(@cart.total_price) %></td>
</tr>
</table>
<%= button_to 'Empty cart', @cart, method: :delete,
confirm: 'Are you sure?' %>

To make this work, we need to add a method to both the LineItem and Cart
models that returns the total price for the individual line item and entire cart,
respectively. First the line item, which involves only simple multiplication:
Download rails32/depot_i/app/models/line_item.rb
def total_price
product.price * quantity
end

We implement the Cart method using Rails’ nifty Array::sum() method to sum
the prices of each item in the collection:
Download rails32/depot_i/app/models/cart.rb
def total_price
line_items.to_a.sum { |item| item.total_price }
end

Then we need to add a small bit to our carts.css.scss stylesheet:
Download rails32/depot_i/app/assets/stylesheets/carts.css.scss
// Place all the styles related to the Carts controller here.
// They will automatically be included in application.css.
// You can use Sass (SCSS) here: http://sass-lang.com/
➤ .carts {
➤
.cart_title {
➤
font: 120% bold;
➤
}
➤
➤
.item_price, .total_line {
➤
text-align: right;
➤
}
➤
➤
.total_line .total_cell {
➤
font-weight: bold;
➤
border-top: 1px solid #595;
➤
}
➤}

For a nicer-looking cart, see Figure 19, Cart display with a total, on page 127.

report erratum • discuss

Iteration E3: Finishing the Cart

•

127

Figure 19—Cart display with a total

What We Just Did
Our shopping cart is now something the client is happy with. Along the way,
we covered the following:
•
•
•
•
•
•

Adding a column to an existing table, with a default value
Migrating existing data into the new table format
Providing a flash notice of an error that was detected
Using the logger to log events
Deleting a record
Adjusting the way a table is rendered, using CSS

But, just as we think we’ve wrapped this functionality up, our customer
wanders over with a copy of Information Technology and Golf Weekly. Apparently, there’s an article about a new style of browser interface, where stuff
gets updated on the fly. “Ajax,” she says, proudly. Hmmm…let’s look at that
tomorrow.

Playtime
Here’s some stuff to try on your own:
• Create a migration that copies the product price into the line item, and
change the add_product() method in the Cart model to capture the price
whenever a new line item is created.
• Add unit tests that add unique products and duplicate products. Note
that you will need to modify the fixture to refer to products and carts by
name, for example product: ruby.

report erratum • discuss

128

•

Chapter 10. Task E: A Smarter Cart

• Check products and line items for other places where a user-friendly error
message would be in order.
• Add the ability to delete individual line items from the cart. This will require buttons on each line, and such buttons will need to be linked to
the destroy() action in the LineItemsController.
(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

report erratum • discuss

In this chapter, we’ll see
• using partial templates,
• rendering into the page layout,
• updating pages dynamically with Ajax and JavaScript,
• highlighting changes with jQuery UI,
• hiding and revealing DOM elements, and
• testing the Ajax updates.

CHAPTER 11

Task F: Add a Dash of Ajax
Our customer wants us to add Ajax support to the store. But just what is
Ajax?
In the old days (up until 2005 or so), browsers were treated as really dumb
devices. When you wrote a browser-based application, you’d send stuff to the
browser and then forget about that session. At some point, the user would
fill in some form fields or click a hyperlink, and your application would get
woken up by an incoming request. It would render a complete page back to
the user, and the whole tedious process would start afresh. That’s exactly
how our Depot application behaves so far.
But it turns out that browsers aren’t really that dumb (who knew?). They can
run code. Almost all browsers can run JavaScript. And it turns out that the
JavaScript in the browser can interact behind the scenes with the application
on the server, updating the stuff the user sees as a result. Jesse James Garrett
named this style of interaction Ajax (which once stood for Asynchronous
JavaScript and XML but now just means “making browsers suck less”).
So, let’s Ajaxify our shopping cart. Rather than having a separate shopping
cart page, let’s put the current cart display into the catalog’s sidebar. Then,
we’ll add the Ajax magic that updates the cart in the sidebar without redisplaying the whole page.
Whenever you work with Ajax, it’s good to start with the non-Ajax version of
the application and then gradually introduce Ajax features. That’s what we’ll
do here. For starters, let’s move the cart from its own page and put it in the
sidebar.

report erratum • discuss

130

•

Chapter 11. Task F: Add a Dash of Ajax

11.1 Iteration F1: Moving the Cart
Currently, our cart is rendered by the show action in the CartController and the
corresponding .html.erb template. What we’d like to do is to move that rendering
into the sidebar. This means it will no longer be in its own page. Instead, we’ll
render it in the layout that displays the overall catalog. And that’s easy using
partial templates.

Partial Templates
Programming languages let you define methods. A method is a chunk of code
with a name: invoke the method by the name, and the corresponding chunk
of code gets run. And, of course, you can pass parameters to a method, which
lets you write one piece of code that can be used in many different
circumstances.
You can think of Rails partial templates (partials for short) as a kind of method
for views. A partial is simply a chunk of a view in its own separate file. You
can invoke (render) a partial from another template or from a controller, and
the partial will render itself and return the results of that rendering. And,
just as with methods, you can pass parameters to a partial, so the same
partial can render different results.
We’ll use partials twice in this iteration. First, let’s look at the cart display
itself:
Download rails32/depot_i/app/views/carts/show.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<div class="cart_title">Your Cart</div>
<table>
<% @cart.line_items.each do |item| %>
<tr>
<td><%= item.quantity %>&times;</td>
<td><%= item.product.title %></td>
<td class="item_price"><%= number_to_currency(item.total_price) %></td>
</tr>
<% end %>
<tr class="total_line">
<td colspan="2">Total</td>
<td class="total_cell"><%= number_to_currency(@cart.total_price) %></td>
</tr>
</table>

report erratum • discuss

Iteration F1: Moving the Cart

•

131

<%= button_to 'Empty cart', @cart, method: :delete,
confirm: 'Are you sure?' %>

It creates a list of table rows, one for each item in the cart. Whenever you find
yourself iterating like this, you might want to stop and ask yourself, is this
too much logic in a template? It turns out we can abstract away the loop using
partials (and, as we’ll see, this also sets the stage for some Ajax magic later).
To do this, we’ll make use of the fact that you can pass a collection to the
method that renders partial templates, and that method will automatically
invoke the partial once for each item in the collection. Let’s rewrite our cart
view to use this feature:
Download rails32/depot_j/app/views/carts/show.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<div class="cart_title">Your Cart</div>
<table>
➤
<%= render(@cart.line_items) %>
<tr class="total_line">
<td colspan="2">Total</td>
<td class="total_cell"><%= number_to_currency(@cart.total_price) %></td>
</tr>
</table>
<%= button_to 'Empty cart', @cart, method: :delete,
confirm: 'Are you sure?' %>

That’s a lot simpler. The render() method will iterate over any collection that
is passed to it. The partial template itself is simply another template file (by
default in the same directory as the object being rendered and with the name
of the table as the name). However, to keep the names of partials distinct
from regular templates, Rails automatically prepends an underscore to the
partial name when looking for the file. That means we need to name our
partial _line_item.html.erb and place it in the app/views/line_items directory.
Download rails32/depot_j/app/views/line_items/_line_item.html.erb
<tr>
<td><%= line_item.quantity %>&times;</td>
<td><%= line_item.product.title %></td>
<td class="item_price"><%= number_to_currency(line_item.total_price) %></td>
</tr>

There’s something subtle going on here. Inside the partial template, we refer
to the current object using the variable name that matches the name of the

report erratum • discuss

132

•

Chapter 11. Task F: Add a Dash of Ajax

template. In this case, the partial is named line_item, so inside the partial we
expect to have a variable called line_item.
So, now we’ve tidied up the cart display, but that hasn’t moved it into the
sidebar. To do that, let’s revisit our layout. If we had a partial template that
could display the cart, we could simply embed a call like this within the
sidebar:
render("cart")

But how would the partial know where to find the cart object? One way would
be for it to make an assumption. In the layout, we have access to the @cart
instance variable that was set by the controller. It turns out that this is also
available inside partials called from the layout. However, this is a bit like
calling a method and passing it some value in a global variable. It works, but
it’s ugly coding, and it increases coupling (which in turn makes your programs
brittle and hard to maintain).
Now that we have a partial for a line item, let’s do the same for the cart. First,
we’ll create the _cart.html.erb template. This is basically our carts/show.html.erb
template but using cart instead of @cart, and without the notice. (Note that it’s
OK for a partial to invoke other partials.)
Download rails32/depot_j/app/views/carts/_cart.html.erb
<div class="cart_title">Your Cart</div>
<table>
➤
<%= render(cart.line_items) %>

➤

<tr class="total_line">
<td colspan="2">Total</td>
<td class="total_cell"><%= number_to_currency(cart.total_price) %></td>
</tr>
</table>

➤ <%= button_to 'Empty cart', cart, method: :delete,
confirm: 'Are you sure?' %>

As the Rails mantra goes, Don’t Repeat Yourselves (DRY), and we have just
done that. At the moment the two files are in sync, so there may not seem to
be much of a problem, but having one set of logic for the Ajax calls and another
set of logic to handle the case where JavaScript is disabled invites problems.
Let’s avoid all of that and replace the original template with code that causes
the partial to be rendered:

report erratum • discuss

Iteration F1: Moving the Cart

•

133

Download rails32/depot_k/app/views/carts/show.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
➤ <%= render @cart %>

Now we will change the application layout to include this new partial in the
sidebar:
Download rails32/depot_k/app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
<title>Pragprog Books Online Store</title>
<%= stylesheet_link_tag "application" %>
<%= javascript_include_tag "application" %>
<%= csrf_meta_tag %>
</head>
<body class="<%= controller.controller_name %>">
<div id="banner">
<%= image_tag("logo.png") %>
<%= @page_title || "Pragmatic Bookshelf" %>
</div>
<div id="columns">
<div id="side">
➤
<div id="cart">
➤
<%= render @cart %>
➤
</div>
➤
<ul>
<li><a href="http://www....">Home</a></li>
<li><a href="http://www..../faq">Questions</a></li>
<li><a href="http://www..../news">News</a></li>
<li><a href="http://www..../contact">Contact</a></li>
</ul>
</div>
<div id="main">
<%= yield %>
</div>
</div>
</body>
</html>

Next we have to make a small change to the store controller. We’re invoking
the layout while looking at the store’s index action, and that action doesn’t
currently set @cart. That’s easy enough to remedy:

report erratum • discuss

134

•

Chapter 11. Task F: Add a Dash of Ajax

Download rails32/depot_k/app/controllers/store_controller.rb
def index
@products = Product.order(:title)
➤
@cart = current_cart
end

Finally, we modify the style instructions—which currently only apply to the
output produced by the CartController—to also apply to the table when it appears
in the sidebar. Again, SCSS enables us to make this change in one place, as
it will take care of all of the nested definitions.
Download rails32/depot_k/app/assets/stylesheets/carts.css.scss
// Place all the styles related to the Carts controller here.
// They will automatically be included in application.css.
// You can use Sass (SCSS) here: http://sass-lang.com/
➤ .carts, #side #cart {
.cart_title {
font: 120% bold;
}

.item_price, .total_line {
text-align: right;
}
.total_line .total_cell {
font-weight: bold;
border-top: 1px solid #595;
}
}

While the data for the cart is common no matter where it is placed in the
output, there is no requirement that the presentation needs to be identical
independent of where this content is placed. In fact, black lettering on a green
background is rather hard to read, so let’s provide additional rules for this
table when it appears in the sidebar:
Download rails32/depot_k/app/assets/stylesheets/application.css.scss
#side {
float: left;
padding: 1em 2em;
width: 13em;
background: #141;
➤
➤
➤
➤
➤
➤

form, div {
display: inline;
}
input {
font-size: small;

report erratum • discuss

Iteration F1: Moving the Cart
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤

•

135

}
#cart {
font-size: smaller;
color:
white;
table {
border-top:
1px dotted #595;
border-bottom: 1px dotted #595;
margin-bottom: 10px;
}
}
ul {
padding: 0;
li {
list-style: none;
a {
color: #bfb;
font-size: small;
}
}
}
}

If you display the catalog after adding something to your cart, you should see
something like Figure 20, The cart is in the sidebar., on page 136. Let’s just
wait for the Webby Award nomination.

Changing the Flow
Now that we’re displaying the cart in the sidebar, we can change the way that
the Add to Cart button works. Rather than displaying a separate cart page, all
it has to do is refresh the main index page.
The change is pretty simple: at the end of the create action, we simply redirect
the browser back to the index:
Download rails32/depot_k/app/controllers/line_items_controller.rb
def create
@cart = current_cart
product = Product.find(params[:product_id])
@line_item = @cart.add_product(product.id)

➤

respond_to do |format|
if @line_item.save
format.html { redirect_to store_url }
format.json { render json: @line_item,
status: :created, location: @line_item }
else

report erratum • discuss

136

•

Chapter 11. Task F: Add a Dash of Ajax

Figure 20—The cart is in the sidebar.

format.html { render action: "new" }
format.json { render json: @line_item.errors,
status: :unprocessable_entity }
end
end
end

So, now we have a store with a cart in the sidebar. When we click to add an
item to the cart, the page is redisplayed with an updated cart. However, if
our catalog is large, that redisplay might take a while. It uses bandwidth, and
it uses server resources. Fortunately, we can use Ajax to make this better.

11.2 Iteration F2: Creating an Ajax-Based Cart
Ajax lets us write code that runs in the browser that interacts with our serverbased application. In our case, we’d like to make the Add to Cart buttons invoke
the server create action on the LineItems controller in the background. The
server can then send down just the HTML for the cart, and we can replace
the cart in the sidebar with the server’s updates.
Now, normally we’d do this by writing JavaScript that runs in the browser
and by writing server-side code that communicated with this JavaScript
(possibly using a technology such as JavaScript Object Notation [JSON]).
The good news is that, with Rails, all this is hidden from us. We can do everything we need to do using Ruby (and with a whole lot of support from some
Rails helper methods).

report erratum • discuss

Iteration F2: Creating an Ajax-Based Cart

•

137

The trick when adding Ajax to an application is to take small steps. So, let’s
start with the most basic one. Let’s change the catalog page to send an Ajax
request to our server application and have the application respond with the
HTML fragment containing the updated cart.
On the index page, we’re using button_to() to create the link to the create action.
We want to change this to send an Ajax request instead. To do this, we simply
add a remote: true parameter to the call.
Download rails32/depot_l/app/views/store/index.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<h1>Your Pragmatic Catalog</h1>
<% @products.each do |product| %>
<div class="entry">
<%= image_tag(product.image_url) %>
<h3><%= product.title %></h3>
<%= sanitize(product.description) %>
<div class="price_line">
<span class="price"><%= number_to_currency(product.price) %></span>
➤
<%= button_to 'Add to Cart', line_items_path(product_id: product),
➤
remote: true %>
</div>
</div>
<% end %>

So far, we’ve arranged for the browser to send an Ajax request to our application. The next step is to have the application return a response. The plan is
to create the updated HTML fragment that represents the cart and to have
the browser stick that HTML into the browser’s internal representation of the
structure and content of the document being displayed, namely, the Document
Object Model (DOM). By manipulating the DOM, we cause the display to
change in front of the user’s eyes.
The first change is to stop the create action from redirecting to the index display
if the request is for JavaScript. We do this by adding a call to respond_to() telling
it that we want to respond with a format of .js.
This syntax may seem surprising at first, but it is simply a method call that
is passing an optional block as an argument. Blocks are described in Blocks
and Iterators, on page 44. We will cover the respond_to() method in greater detail
in Selecting a Data Representation, on page 316.
Download rails32/depot_l/app/controllers/line_items_controller.rb
def create

report erratum • discuss

138

•

Chapter 11. Task F: Add a Dash of Ajax

@cart = current_cart
product = Product.find(params[:product_id])
@line_item = @cart.add_product(product.id)
respond_to do |format|
if @line_item.save
format.html { redirect_to store_url }
➤
format.js
format.json { render json: @line_item,
status: :created, location: @line_item }
else
format.html { render action: "new" }
format.json { render json: @line_item.errors,
status: :unprocessable_entity }
end
end
end

Because of this change, when create finishes handling the Ajax request, Rails
will look for a create template to render.
Rails supports templates that generate JavaScript—the JS stands for JavaScript. A .js.erb template is a way of getting JavaScript on the browser to do
what you want, all by writing server-side Ruby code. Let’s write our first:
create.js.erb. It goes in the app/views/line_items directory, just like any other view
for line items:
Download rails32/depot_l/app/views/line_items/create.js.erb
$('#cart').html("<%=j render @cart %>");

This simple template tells the browser to replace the content of the element
whose id="cart" with that HTML.
Let’s analyze how it manages to do that.
For simplicity and conciseness, the jQuery library itself is aliased to $, and
most usages of jQuery start there.
The first call—$('#cart')—tells jQuery to find the HTML element that has an id
of cart. The html() method1 is then called with a first argument of the desired
replacement for the contents of this element. This content is formed by calling
the render() method on the @cart object. The output of this method is processed
by a j() helper method that converts this Ruby string into a format acceptable
as input to JavaScript.
Note that this script is executed in the browser. The only parts executed on
the server are the portions within the <%= and %> delimiters.
1.

http://api.jquery.com/html/

report erratum • discuss

Iteration F2: Creating an Ajax-Based Cart

•

139

Does it work? Well, it’s hard to show in a book, but it sure does. Make sure
you reload the index page to get the remote version of the form and the
JavaScript libraries loaded into your browser. Then, click one of the Add to Cart
buttons. You should see the cart in the sidebar update. And you shouldn’t
see your browser show any indication of reloading the page. You’ve just created an Ajax application.

Troubleshooting
Although Rails makes Ajax incredibly simple, it can’t make it foolproof. And,
because you’re dealing with the loose integration of a number of technologies,
it can be hard to work out why your Ajax doesn’t work. That’s one of the
reasons you should always add Ajax functionality one step at a time.
Here are a few hints if your Depot application didn’t show any Ajax magic:
• Does your browser have any special incantation to force it to reload everything on a page? Sometimes browsers hold local cached versions of page
assets, and this can mess up testing. Now would be a good time to do a
full reload.
• Did you have any errors reported? Look in development.log in the logs directory. Also look in the Rails server window because some errors are reported
there.
• Still looking at the log file, do you see incoming requests to the action
create? If not, it means your browser isn’t making Ajax requests. If the
JavaScript libraries have been loaded (using View Source in your browser
will show you the HTML), perhaps your browser has JavaScript execution
disabled?
• Some readers have reported that they had to stop and start their application to get the Ajax-based cart to work.
• If you’re using Internet Explorer, it might be running in what Microsoft
calls quirks mode, which is backward compatible with old Internet Explorer
releases but is also broken. Internet Explorer switches into standards
mode, which works better with the Ajax stuff, if the first line of the
downloaded page is an appropriate DOCTYPE header. Our layouts use this:
<!DOCTYPE html>

The Customer Is Never Satisfied
We’re feeling pretty pleased with ourselves. We changed a handful of lines of
code, and our boring old Web 1.0 application now sports Web 2.0 Ajax speed

report erratum • discuss

140

•

Chapter 11. Task F: Add a Dash of Ajax

stripes. We breathlessly call the client over to come look. Without saying
anything, we proudly press Add to Cart and look at her, eager for the praise
we know will come. Instead, she looks surprised. “You called me over to show
me a bug?” she asks. “You click that button, and nothing happens.”
We patiently explain that, in fact, quite a lot happened. Just look at the cart
in the sidebar. See? When we add something, the quantity changes from 4
to 5.
“Oh,” she says, “I didn’t notice that.” And, if she didn’t notice the page update,
it’s likely our customers won’t either. It’s time for some user-interface hacking.

11.3 Iteration F3: Highlighting Changes
A number of JavaScript libraries are included with Rails. One of those libraries,
namely jQuery UI,2 lets you decorate your web pages with a number of visually interesting effects. One of these effects is the (now) infamous Yellow Fade
Technique. This highlights an element in a browser: by default it flashes the
background yellow and then gradually fades it back to white. We can see the
Yellow Fade Technique being applied to our cart in Figure 21, Our cart with
the Yellow Fade Technique, on page 141; the image at the back shows the
original cart. The user clicks the Add to Cart button, and the count updates
to 2 as the line flares brighter. It then fades back to the background color
over a short period of time.
Including the jQuery UI library is simple enough. Simply add one line to
app/assets/javascripts/application.js.
Download rails32/depot_m/app/assets/javascripts/application.js
// This is a manifest file that'll be compiled into application.js, which will
// include all the files listed below.
//
// Any JavaScript/Coffee file within this directory, lib/assets/javascripts,
// vendor/assets/javascripts, or vendor/assets/javascripts of plugins, if any,
// can be referenced here using a relative path.
//
// It's not advisable to add code directly here, but if you do, it'll appear at
// the bottom of the the compiled file.
//
// WARNING: THE FIRST BLANK LINE MARKS THE END OF WHAT'S TO BE PROCESSED, ANY
// BLANK LINE SHOULD GO AFTER THE REQUIRES BELOW.
//
//= require jquery
➤ //= require jquery-ui
//= require jquery_ujs

2.

http://jqueryui.com/

report erratum • discuss

Iteration F3: Highlighting Changes

•

141

Figure 21—Our cart with the Yellow Fade Technique

//= require_tree .

We saw assets/stylesheets/application.css in Iteration A2 on page 97. This file behaves
similarly, just for JavaScripts instead of stylesheets. Be careful to use a dash
instead of an underscore in this line, as clearly not all authors of libraries
follow the same naming conventions.
Let’s use this library to add this kind of highlight to our cart. Whenever an
item in the cart is updated (either when it is added or when we change the
quantity), let’s flash its background. That will make it clearer to our users
that something has changed, even though the whole page hasn’t been
refreshed.
The first problem we have is identifying the most recently updated item in
the cart. Right now, each item is simply a <tr> element. We need to find a way
to flag the most recently changed one. The work starts in the LineItemsController.
Let’s pass the current line item down to the template by assigning it to an
instance variable:
Download rails32/depot_m/app/controllers/line_items_controller.rb
def create
@cart = current_cart
product = Product.find(params[:product_id])
@line_item = @cart.add_product(product.id)
respond_to do |format|

report erratum • discuss

142

•

Chapter 11. Task F: Add a Dash of Ajax

if @line_item.save
format.html { redirect_to store_url }
➤
format.js
{ @current_item = @line_item }
format.json { render json: @line_item,
status: :created, location: @line_item }
else
format.html { render action: "new" }
format.json { render json: @line_item.errors,
status: :unprocessable_entity }
end
end
end

In the _line_item.html.erb partial, we then check to see whether the item we’re
rendering is the one that just changed. If so, we tag it with an id of current_item:
➤
➤
➤
➤
➤

Download rails32/depot_m/app/views/line_items/_line_item.html.erb
<% if line_item == @current_item %>
<tr id="current_item">
<% else %>
<tr>
<% end %>
<td><%= line_item.quantity %>&times;</td>
<td><%= line_item.product.title %></td>
<td class="item_price"><%= number_to_currency(line_item.total_price) %></td>
</tr>

As a result of these two minor changes, the <tr> element of the most recently
changed item in the cart will be tagged with id="current_item". Now we just need
to tell the JavaScript to change the background color to one that will catch
the eye, and then to gradually change it back.
We do this in the existing create.js.erb template:
Download rails32/depot_m/app/views/line_items/create.js.erb
$('#cart').html("<%=j render @cart %>");
➤
➤ $('#current_item').css({'background-color':'#88ff88'}).
➤
animate({'background-color':'#114411'}, 1000);

See how we identified the browser element that we wanted to apply the effect
to by passing '#current_item' to the $ function? We then called css() to set the
initial background color and followed up with a call to the animate() method to
transition back to the original color used by our layout over a period of 1000
milliseconds, more commonly known as one second.
With that change in place, click any Add to Cart button and you’ll see that the
changed item in the cart glows a light green before fading back to merge with
the background.

report erratum • discuss

Iteration F4: Hiding an Empty Cart

•

143

11.4 Iteration F4: Hiding an Empty Cart
There’s one last request from the customer. Right now, even carts with
nothing in them are still displayed in the sidebar. Can we arrange for the cart
to appear only when it has some content? But of course!
In fact, we have a number of options. The simplest is probably to include the
HTML for the cart only if the cart has something in it. We could do this totally
within the _cart partial:
➤ <% unless cart.line_items.empty? %>
<div class="cart_title">Your Cart</div>
<table>
<%= render(cart.line_items) %>

<tr class="total_line">
<td colspan="2">Total</td>
<td class="total_cell"><%= number_to_currency(cart.total_price) %></td>
</tr>
</table>
<%= button_to 'Empty cart', cart, method: :delete,
confirm: 'Are you sure?' %>
➤ <% end %>

Although this works, the user interface is somewhat brutal: the whole sidebar
redraws on the transition between a cart that’s empty and a cart with something in it. So, let’s not use this code. Instead, let’s smooth it out a little.
The jQuery UI library also provides transitions that make elements appear.
Let’s use the blind option on show() which will smoothly reveal the cart, sliding
the rest of the sidebar down to make room.
Not surprisingly, we’ll again use our existing .js.erb template to call the effect.
Because the create template is invoked only when we add something to the
cart, we know that we have to reveal the cart in the sidebar whenever there
is exactly one item in the cart (because that means previously the cart was
empty and hence hidden). And, because the cart should be visible before we
start the highlight effect, we’ll add the code to reveal the cart before the code
that triggers the highlight.
The template now looks like this:
Download rails32/depot_n/app/views/line_items/create.js.erb
➤ if ($('#cart tr').length == 1) { $('#cart').show('blind', 1000); }
➤
$('#cart').html("<%=j render @cart %>");
$('#current_item').css({'background-color':'#88ff88'}).

report erratum • discuss

144

•

Chapter 11. Task F: Add a Dash of Ajax

animate({'background-color':'#114411'}, 1000);

We also have to arrange to hide the cart when it’s empty. There are two basic
ways of doing this. One, illustrated by the code at the start of this section, is
not to generate any HTML at all. Unfortunately, if we do that, then when we
add something to the cart and suddenly create the cart HTML, we see a
flicker in the browser as the cart is first displayed and then hidden and
slowly revealed by the blind effect.
A better way to handle the problem is to create the cart HTML but set the
CSS style to display: none if the cart is empty. To do that, we need to change
the application.html.erb layout in app/views/layouts. Our first attempt is something
like this:
<div id="cart"
<% if @cart.line_items.empty? %>
style="display: none"
<% end %>
>
<%= render(@cart) %>
</div>

This code adds the CSS style= attribute to the <div> tag, but only if the cart is
empty. It works fine, but it’s really, really ugly. That dangling > character
looks misplaced (even though it isn’t), and the way logic is interjected into
the middle of a tag is the kind of thing that gives templating languages a bad
name. Let’s not let that kind of ugliness litter our code. Instead, let’s create
an abstraction that hides it—we’ll write a helper method.

Helper Methods
Whenever we want to abstract some processing out of a view (any kind of
view), we should write a helper method.
If you look in the app directory, you’ll find six subdirectories:
depot> ls -p app
assets/ controllers/

helpers/

mailers/

models/

views/

Not surprisingly, our helper methods go in the helpers directory. If you look
in that directory, you’ll find it already contains some files:
depot> ls -p app/helpers
application_helper.rb line_items_helper.rb
carts_helper.rb
products_helper.rb

store_helper.rb

The Rails generators automatically created a helper file for each of our controllers (products and store). The Rails command itself (the one that created

report erratum • discuss

Iteration F4: Hiding an Empty Cart

•

145

the application initially) created the file application_helper.rb. If you like, you can
organize your methods into controller-specific helpers, but because this
method will be used in the application layout, let’s put it in the application
helper.
Let’s write a helper method called hidden_div_if(). It takes a condition, an optional
set of attributes, and a block. It wraps the output generated by the block in
a <div> tag, adding the display: none style if the condition is true. Use it in the
store layout like this:
Download rails32/depot_n/app/views/layouts/application.html.erb
<%= hidden_div_if(@cart.line_items.empty?, id: 'cart') do %>
<%= render @cart %>
<% end %>

We’ll write our helper so that it is visible to the store controller by adding it
to application_helper.rb in the app/helpers directory:

➤
➤
➤
➤
➤
➤

Download rails32/depot_n/app/helpers/application_helper.rb
module ApplicationHelper
def hidden_div_if(condition, attributes = {}, &block)
if condition
attributes["style"] = "display: none"
end
content_tag("div", attributes, &block)
end
end

This code uses the Rails standard helper, content_tag(), which can be used to
wrap the output created by a block in a tag. By using the &block notation, we
get Ruby to pass the block that was given to hidden_div_if() down to content_tag().

&block notation
↪ on page 44

And, finally, we need to stop setting the message in the flash that we used to
display when the user empties a cart. It really isn’t needed anymore, because
the cart clearly disappears from the sidebar when the catalog index page is
redrawn. But there’s another reason to remove it, too. Now that we’re using
Ajax to add products to the cart, the main page doesn’t get redrawn between
requests as people shop. That means we’ll continue to display the flash
message saying the cart is empty even as we display a cart in the sidebar.
Download rails32/depot_n/app/controllers/carts_controller.rb
def destroy
@cart = current_cart
@cart.destroy
session[:cart_id] = nil
➤

respond_to do |format|
format.html { redirect_to store_url }
format.json { head :no_content }

report erratum • discuss

146

•

Chapter 11. Task F: Add a Dash of Ajax

end
end

Now that we have added all this Ajax goodness, go ahead and empty your
cart and add an item.
Although this might seem like a lot of work, there really are only two essential
steps to what we did. First, we make the cart hide and reveal itself by making
the CSS display style conditional on the number of items in the cart. Second,
we provided JavaScript instructions to invoke the blind effect when the cart
went from being empty to having one item.
So far, these changes have been pretty, but not functional. Let’s proceed to
changing the behavior of the page itself. How about we make clicking on the
image itself cause an item to be added to the cart? It turns out that that’s
easy too with JQuery.

11.5 Iteration F5: Making Images Clickable
So far, we have only been doing things in response to a click, and only on
things that are defined to be clickable (namely buttons and links). In this
case what we want to do is to handle the onClick event for the image and
have it execute some behavior that we define.
In other words, what we want to do is to have a script that executes when
the page loads, and have it find all the images and associate logic with those
images to forward the processing of click events to the Add to Cart button for
the same entry.
First, we refresh our memory as to how the page in question is organized:
Download rails32/depot_n/app/views/store/index.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<h1>Your Pragmatic Catalog</h1>
<% @products.each do |product| %>
<div class="entry">
<%= image_tag(product.image_url) %>
<h3><%= product.title %></h3>
<%= sanitize(product.description) %>
<div class="price_line">
<span class="price"><%= number_to_currency(product.price) %></span>
<%= button_to 'Add to Cart', line_items_path(product_id: product),
remote: true %>
</div>

report erratum • discuss

Iteration F5: Making Images Clickable

•

147

</div>
<% end %>

Using this information, we proceed by modifying app/assets/javascripts/store.js.coffee:
Download rails32/depot_n/app/assets/javascripts/store.js.coffee
# Place all the behaviors and hooks related to the matching controller here.
# All this logic will automatically be available in application.js.
# You can use CoffeeScript in this file: http://jashkenas.github.com/coffee-script/
➤ $ ->
➤
$('.store .entry > img').click ->
➤
$(this).parent().find(':submit').click()

CoffeeScript3 is another preprocessor that makes writing assets easier. In
this case, CoffeeScript helps you express JavaScript in a more concise form.
Combined with JQuery, you can produce significant effects with very little
effort.
In this case, the first thing we want to do is to define a function that executes
on page load. That’s what the first line of this script does: it defines a function
using the -> operator and passes it to a function named $ which, as previously
discussed, is aliased to jQuery. That’s all it takes to get jQuery to schedule the
execution of these scripts when the page completes loading.
The second line finds all images that are immediate children of elements that
are defined with class="entry", which themselves are descendants of an element
with class="store". This last part is important as, just like with stylesheets, Rails
will by default combine all JavaScripts into a single resource. For each image
found, which could be zero when run against other pages in our application,
a function is defined that is associated with the click event for that image.
The third and final line processes that click event. It starts with the element
on which the event occurred, namely this. It then proceeds to find the parent
element, which will be the div that specifies class="entry". Within that element
we find the submit button, and we proceed to click it.
Proceeding to the browser, the page looks no different than it did in Figure
20, The cart is in the sidebar., on page 136. But it behaves differently. Click on
the images to cause items to be added to the cart. Marvel in the fact that all
this was accomplished with a mere three lines of code.
Of course, you could have done all of this in JavaScript directly, but that
would have required five more sets of parentheses, two sets of braces, and
overall about 50% more characters. And this just barely scratches the surface
3.

http://jashkenas.github.com/coffee-script/

report erratum • discuss

148

•

Chapter 11. Task F: Add a Dash of Ajax

of what CoffeeScript can do. A good place to find out more on this subject is
CoffeeScript: Accelerated JavaScript Development [Bur11].
At this point, it occurs to us that we hadn’t really done much with respect to
testing, but it doesn’t really feel like we’ve made much in the way of functional
changes, so we should be fine. But just to be sure, we run our tests again:
depot> rake test
Loaded suite
Started
...
Finished in 0.458259 seconds.
7 tests, 28 assertions, 0 failures, 0 errors, 0 skips
Loaded suite
Started
...
Finished in 1.048274 seconds.
23 tests, 26 assertions, 1 failures, 9 errors, 0 skips

Oh dear. Failures and errors. This is not good. Clearly, we need to revisit our
approach to testing. In fact, we will do that next.

11.6 Testing Ajax Changes
We look at the test failures, and we see a number of errors that look like the
following:
ActionView::Template::Error: undefined method `line_items' for nil:NilClass

Since this error represents the majority of the problems reported, let’s address
it first so that we can focus on the rest. According to the test, we will have a
problem if we get the product index, and sure enough, when we point our
browser to http://localhost:3000/products/, we see Figure 22, An error in a
layout can affect the entire application., on page 149.
This information is very helpful. The message identifies the template file was
being processed at the point where the error occurs (app/views/layouts/application.html.erb), the line number where the error occurred, and an excerpt from
the template of lines around the error. From this, we can see that the expression being evaluated at the point of error is @cart.line_items, and the message
produced is undefined method `line_items' for nil.
So, @cart is apparently nil when we display an index of our products. That
makes sense, because it is set only in the store controller. This is easy enough
to fix; all we need to do is avoid displaying the cart at all unless this value is
set:

report erratum • discuss

Testing Ajax Changes

•

149

Figure 22—An error in a layout can affect the entire application.

Download rails32/depot_o/app/views/layouts/application.html.erb
➤ <% if @cart %>
<%= hidden_div_if(@cart.line_items.empty?, id: 'cart') do %>
<%= render @cart %>
<% end %>
➤ <% end %>

After this fix, we rerun the tests again and see that we are down to one error.
The value of the redirect was not what was expected. This occurred on creating
a line item. Sure enough, we did change that on Changing the Flow, on page
135. Unlike the last change, which was entirely accidental, this change was
intentional, so we update the corresponding functional test case:
Download rails32/depot_o/test/functional/line_items_controller_test.rb
test "should create line_item" do
assert_difference('LineItem.count') do
post :create, product_id: products(:ruby).id
end
➤

assert_redirected_to store_path
end

With this change in place, our tests now once again pass. Just imagine what
could have happened. A change in one part of an application in order to
support a new requirement breaks a function we previously implemented in
another part of the application. If you are not careful, this can happen in a
small application like Depot. Even if you are careful, this will happen in a
large application.

report erratum • discuss

150

•

Chapter 11. Task F: Add a Dash of Ajax

But we are not done yet. We haven’t tested any of our Ajax additions, such
as what happens when we click the Add to Cart button. Rails makes that easy
too.
We already have a test for should create line item, so let’s add another one
called should create line item via ajax:
Download rails32/depot_o/test/functional/line_items_controller_test.rb
test "should create line_item via ajax" do
assert_difference('LineItem.count') do
xhr :post, :create, product_id: products(:ruby).id
end
assert_response :success
assert_select_jquery :html, '#cart' do
assert_select 'tr#current_item td', /Programming Ruby 1.9/
end
end

This test differs in the name of the test, in the manner of invocation from the
create line item test (xhr :post vs. simply post, where xhr stands for the XMLHttpRequest mouthful), and in the expected results. Instead of a redirect, we
expect a successful response containing a call to replace the HTML for the
cart, and in that HTML we expect to find a row with an id of current_item with
a value matching Programming Ruby 1.9. This is achieved by applying the assert_select_jquery() to extract the relevant HTML and then processing that HTML via
whatever additional assertions you want to apply.
Finally, there is the CoffeeScript that we introduced. While testing code that
actually executes in the browser is outside the scope of this book, we should
test that the markup that this script depends on is in place. And it is certainly
easy enough:
Download rails32/depot_o/test/functional/store_controller_test.rb
test "markup needed for store.js.coffee is in place" do
get :index
assert_select '.store .entry > img', 3
assert_select '.entry input[type=submit]', 3
end

This way, should an exuberant web designer change the markup on the page
in a way that affects our logic, we will be alerted to this issue and be able to
make a change before the code goes into production. Note that :submit is a
jQuery-only extension to CSS; we simply need to spell out input[type=submit] in
our test.
Keeping tests up-to-date is an important part of maintaining your application.
Rails makes this easy to do. Agile programmers make testing an integral part

report erratum • discuss

Testing Ajax Changes

•

151

of their development efforts. Many even go so far as to write their tests first,
before the first line of code is written.

What We Just Did
In this iteration, we added Ajax support to our cart:
• We moved the shopping cart into the sidebar. We then arranged for the
create action to redisplay the catalog page.
• We used remote: true to invoke the LineItemsController.create() action using Ajax.
• We then used an ERb template to create JavaScript that will execute on
the client. This script made use of jQuery in order to update to the page
with just the cart’s HTML.
• To help the user see changes to the cart, we added a highlight effect, using
the jQuery-UI library.
• We wrote a helper method that hides the cart when it is empty, and used
jQuery to reveal it when an item is added.
• We wrote a test that verifies not only the creation of a line item but also
the content of the response that is returned from such a request.
The key point to take away is the incremental style of Ajax development. Start
with a conventional application, and then add Ajax features, one by one. Ajax
can be hard to debug: by adding it slowly to an application, you make it easier to track down what changed if your application stops working. And, as
we saw, starting with a conventional application makes it easier to support
both Ajax and non-Ajax behavior in the same codebase.
Finally, we’ll give you a couple of hints. First, if you plan to do a lot of Ajax
development, you’ll probably need to get familiar with your browser’s JavaScript debugging facilities and with its DOM inspectors, such as Firefox’s
Firebug, Internet Explorer 8’s Developer Tools, Google Chrome’s Developer
Tools, Safari’s Web Inspector, or Opera’s Dragonfly. And, second, the NoScript
plug-in for Firefox makes checking JavaScript/no JavaScript a one-click
breeze. Others find it useful to run two different browsers when they are
developing—with JavaScript enabled in one and disabled in the other. Then,
as new features are added, poking at it with both browsers will make sure
your application works regardless of the state of JavaScript.

Playtime
Here’s some stuff to try on your own:

report erratum • discuss

152

•

Chapter 11. Task F: Add a Dash of Ajax

• The cart is currently hidden when the user empties it by redrawing the
entire catalog. Can you change the application to use the jQuery UI blind
effect instead?
• Add a button next to each item in the cart. When clicked, it should invoke
an action to decrement the quantity of the item, deleting it from the cart
when the quantity reaches zero. Get it working without using Ajax first,
and then add the Ajax goodness.
(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

report erratum • discuss

In this chapter, we’ll see
• linking tables with foreign keys;
• using belongs_to, has_many, and :through;
• creating forms based on models (form_for);
• linking forms, models, and views;
• generating a feed using atom_helper on model objects.

CHAPTER 12

Task G: Check Out!
Let’s take stock. So far, we’ve put together a basic product administration
system, we’ve implemented a catalog, and we have a pretty spiffy-looking
shopping cart. So, now we need to let the buyer actually purchase the contents
of that cart. Let’s implement the checkout function.
We’re not going to go overboard here. For now, all we’ll do is capture the
customer’s contact details and payment option. Using these, we’ll construct
an order in the database. Along the way, we’ll be looking a bit more at models,
validation, and form handling.

12.1 Iteration G1: Capturing an Order
An order is a set of line items, along with details of the purchase transaction.
Our cart already contains line_items, so all we need to do is add an order_id column to the line_items table and create an orders table based on the Initial guess
at application data diagram on page 60, combined with a brief chat with our
customer.
First we create the order model and update the line_items table:
depot> rails generate scaffold order name:string address:text \
email:string pay_type:string
...
depot> rails generate migration add_order_id_to_line_item \
order_id:integer

Now that we’ve created the migrations, we can apply them:
depot> rake db:migrate
== CreateOrders: migrating =======================================
-- create_table(:orders)
-> 0.0014s
== CreateOrders: migrated (0.0015s) ==============================
==

AddOrderIdToLineItem: migrating ===============================

report erratum • discuss

154

•

Chapter 12. Task G: Check Out!

-- add_column(:line_items, :order_id, :integer)
-> 0.0008s
== AddOrderIdToLineItem: migrated (0.0009s) ======================

Because the database did not have entries for these two new migrations in
the schema_migrations table, the db:migrate task applied both migrations to the
database. We could, of course, have applied them separately by running the
migration task after creating the individual migrations.

Creating the Order Capture Form
Now that we have our tables and our models as we need them, we can start
the checkout process. First, we need to add a Checkout button to the shopping
cart. Because it will create a new order, we’ll link it back to a new action in
our order controller:
Download rails32/depot_o/app/views/carts/_cart.html.erb
<div class="cart_title">Your Cart</div>
<table>
<%= render(cart.line_items) %>
<tr class="total_line">
<td colspan="2">Total</td>
<td class="total_cell"><%= number_to_currency(cart.total_price) %></td>
</tr>
</table>
➤ <%= button_to "Checkout", new_order_path, method: :get %>
<%= button_to 'Empty cart', cart, method: :delete,
confirm: 'Are you sure?' %>

The first thing we want to do is check to make sure that there’s something
in the cart. If there is nothing in the cart, we redirect the user back to the
storefront, provide a notice of what we did, and return immediately. This
prevents people from navigating directly to the checkout option and creating
empty orders. The return statement is important here; without it you will get
a double render error because your controller will attempt to both redirect
and render output.

➤
➤
➤
➤
➤
➤

Download rails32/depot_o/app/controllers/orders_controller.rb
def new
@cart = current_cart
if @cart.line_items.empty?
redirect_to store_url, notice: "Your cart is empty"
return
end
@order = Order.new

report erratum • discuss

Iteration G1: Capturing an Order

•

155

Joe asks:

Where’s the Credit-Card Processing?
In the real world, we’d probably want our application to handle the commercial side
of checkout. We might even want to integrate credit-card processing. However, to
integrate with back-end payment-processing systems requires a fair amount of paperwork and jumping through hoops. And this would distract from looking at Rails, so
we’re going to punt on this particular detail for the moment.
We will come back to this in Section 26.1, Credit Card Processing with Active Merchant,
on page 437, where we will explore a plugin that can help us with this function.

respond_to do |format|
format.html # new.html.erb
format.json { render json: @order }
end
end

And we add a test for requires item in cart and modify the existing test for
should get new to ensure that there is an item in the cart:
Download rails32/depot_o/test/functional/orders_controller_test.rb
➤ test "requires item in cart" do
➤
get :new
➤
assert_redirected_to store_path
➤
assert_equal flash[:notice], 'Your cart is empty'
➤ end
➤
➤
➤
➤

test "should get new" do
cart = Cart.create
session[:cart_id] = cart.id
LineItem.create(cart: cart, product: products(:ruby))
get :new
assert_response :success
end

Now we want the new action to present our user with a form, prompting them
to enter the information in the orders table: their name, address, email address,
and payment type. This means we will need to display a Rails template
containing a form. The input fields on this form will have to link to the corresponding attributes in a Rails model object, so we’ll need to create an empty
model object in the new action to give these fields something to work with.
As always with HTML forms, the trick is populating any initial values into the
form fields and then extracting those values back out into our application
when the user hits the submit button.

report erratum • discuss

156

•

Chapter 12. Task G: Check Out!

In the controller, the @order instance variable is set to reference a new Order
model object. This is done because the view populates the form from the data
in this object. As it stands, that’s not particularly interesting. Because it’s a
new model object, all the fields will be empty. However, consider the general
case. Maybe we want to edit an existing order. Or maybe the user has tried
to enter an order but their data has failed validation. In these cases, we want
any existing data in the model shown to the user when the form is displayed.
Passing in the empty model object at this stage makes all these cases consistent—the view can always assume it has a model object available.
Then, when the user hits the submit button, we’d like the new data from the
form to be extracted into a model object back in the controller.
Fortunately, Rails makes this relatively painless. It provides us with a bunch
of form helper methods. These helpers interact with the controller and with
the models to implement an integrated solution for form handling. Before we
start on our final form, let’s look at a simple example:
Line 1
2
3
4
5
6

<%= form_for @order do |f| %>
<p>
<%= f.label :name, "Name:" %>
<%= f.text_field :name, size: 40 %>
</p>
<% end %>

There are two interesting things in this code. First, the form_for() helper on
line 1 sets up a standard HTML form. But it does more. The first parameter,
@order, tells the method the instance variable to use when naming fields and
when arranging for the field values to be passed back to the controller.
You’ll see that form_for sets up a Ruby block environment (this block ends on
line 6). Within this block, you can put normal template stuff (such as the <p>
tag). But you can also use the block’s parameter (f in this case) to reference
a form context. We use this context on line 4 to add a text field to the form.
Because the text field is constructed in the context of the form_for, it is automatically associated with the data in the @order object.
All these relationships can be confusing. It’s important to remember that
Rails needs to know both the names and the values to use for the fields associated with a model. The combination of form_for and the various field-level
helpers (such as text_field) gives it this information. We can see this process in
Figure 23, Names in form_for map to objects and attributes, on page 157.
Now we can update the template for the form that captures a customer’s
details for checkout. It’s invoked from the new action in the order controller,

report erratum • discuss

Iteration G1: Capturing an Order

•

157

model object:

controller:
def edit
@order = Order.find(...)
end

"Dave"

@order.name

<%= form_for @order do |f| %>
<p>
<%= f.label :name, "Name:" %>
<%= f.text_field
:name , size: 40 %>
</p>
<% end %>
Name:

Dave

Figure 23—Names in form_for map to objects and attributes

so the template is called new.html.erb and can be found in the directory app/views/
orders:
Download rails32/depot_o/app/views/orders/new.html.erb
<div class="depot_form">
<fieldset>
<legend>Please Enter Your Details</legend>
<%= render 'form' %>
</fieldset>
</div>

This template makes use of a partial named _form:
Download rails32/depot_o/app/views/orders/_form.html.erb
<%= form_for(@order) do |f| %>
<% if @order.errors.any? %>
<div id="error_explanation">
<h2><%= pluralize(@order.errors.count, "error") %>
prohibited this order from being saved:</h2>
<ul>
<% @order.errors.full_messages.each do |msg| %>
<li><%= msg %></li>
<% end %>
</ul>
</div>
<% end %>
<div class="field">
<%= f.label :name %><br />

report erratum • discuss

158
➤

➤

➤

➤
➤

➤

•

Chapter 12. Task G: Check Out!

<%= f.text_field :name, size: 40 %>
</div>
<div class="field">
<%= f.label :address %><br />
<%= f.text_area :address, rows: 3, cols: 40 %>
</div>
<div class="field">
<%= f.label :email %><br />
<%= f.email_field :email, size: 40 %>
</div>
<div class="field">
<%= f.label :pay_type %><br />
<%= f.select :pay_type, Order::PAYMENT_TYPES,
prompt: 'Select a payment method' %>
</div>
<div class="actions">
<%= f.submit 'Place Order' %>
</div>
<% end %>

Rails has form helpers for all the different HTML-level form elements. In the
previous code, we use text_field, email_field, and text_area helpers to capture the
customer’s name, email, and address. We cover form helpers in more depth
in Section 21.2, Generating Forms, on page 343.
The only tricky thing in there is the code associated with the selection list.
We’ve assumed that the list of available payment options is an attribute of
the Order model. We’d better define the option array in the model order.rb before
we forget:
Download rails32/depot_o/app/models/order.rb
class Order < ActiveRecord::Base
➤
PAYMENT_TYPES = [ "Check", "Credit card", "Purchase order" ]
end

In the template, we pass this array of payment type options to the select helper.
We also pass the :prompt parameter, which adds a dummy selection containing
the prompt text.
Add a little CSS magic:
Download rails32/depot_o/app/assets/stylesheets/application.css.scss
.depot_form {
fieldset {
background: #efe;
legend {
color: #dfd;
background: #141;
font-family: sans-serif;

report erratum • discuss

Iteration G1: Capturing an Order

•

159

padding: 0.2em 1em;
}
}
form {
label {
width: 5em;
float: left;
text-align: right;
padding-top: 0.2em;
margin-right: 0.1em;
display: block;
}
select, textarea, input {
margin-left: 0.5em;
}
.submit {
margin-left: 4em;
}
br {
display: none
}
}
}

We’re ready to play with our form. Add some stuff to your cart, and then click
the Checkout button. You should see something like Figure 24, Our checkout
screen, on page 160.
Looking good! Before we move on, let’s finish the new action by adding some
validation. We’ll change the Order model to verify that the customer enters
data for all the input fields.
We also validate that the payment type is one of the accepted values.
Some folks might be wondering why we bother to validate the payment type,
given that its value comes from a drop-down list that contains only valid
values. We do it because an application can’t assume that it’s being fed values
from the forms it creates. Nothing is stopping a malicious user from submitting
form data directly to the application, bypassing our form. If the user set an
unknown payment type, they might conceivably get our products for free.
Download rails32/depot_o/app/models/order.rb
class Order < ActiveRecord::Base
# ...
➤
validates :name, :address, :email, presence: true

report erratum • discuss

160

•

Chapter 12. Task G: Check Out!

Figure 24—Our checkout screen

➤

validates :pay_type, inclusion: PAYMENT_TYPES
end

Note that we already loop over the @order.errors at the top of the page. This will
report validation failures.
Since we modified validation rules, we need to modify our test fixture to match:
Download rails32/depot_o/test/fixtures/orders.yml
# Read about fixtures at
# http://api.rubyonrails.org/classes/ActiveRecord/Fixtures.html
one:
name: Dave Thomas
address: MyText
➤
email: dave@example.org
➤
pay_type: Check
➤

two:
name: MyString
address: MyText
email: MyString
pay_type: MyString

Furthermore, for an order to be created, a line item needs to be in the cart,
so we need to modify the line items test fixture too:
Download rails32/depot_o/test/fixtures/line_items.yml
# Read about fixtures at
# http://api.rubyonrails.org/classes/ActiveRecord/Fixtures.html
one:

report erratum • discuss

Iteration G1: Capturing an Order

➤

•

161

product: ruby
order: one
two:
product: ruby
cart: one

Feel free to make other changes, but only the first is currently used in the
functional tests. For these tests to pass, we will need to implement the model.

Capturing the Order Details
Let’s implement the create() action in the controller. This method has to do the
following:
1. Capture the values from the form to populate a new Order model object.
2. Add the line items from our cart to that order.
3. Validate and save the order. If this fails, display the appropriate messages,
and let the user correct any problems.
4. Once the order is successfully saved, delete the cart, redisplay the catalog
page, and display a message confirming that the order has been placed.
First, we define the relationships themselves, first from the line item to the
order:
Download rails32/depot_o/app/models/line_item.rb
class LineItem < ActiveRecord::Base
➤
belongs_to :order
belongs_to :product
belongs_to :cart
def total_price
product.price * quantity
end
end

then from the order to the line item, once again indicating that all line items
that belong to an order are to be destroyed whenever the order is destroyed:
Download rails32/depot_o/app/models/order.rb
class Order < ActiveRecord::Base
➤
has_many :line_items, dependent: :destroy
# ...
end

The method itself ends up looking something like this:
Download rails32/depot_o/app/controllers/orders_controller.rb
def create

report erratum • discuss

162

➤

➤
➤
➤
➤

➤

•

Chapter 12. Task G: Check Out!

@order = Order.new(params[:order])
@order.add_line_items_from_cart(current_cart)
respond_to do |format|
if @order.save
Cart.destroy(session[:cart_id])
session[:cart_id] = nil
format.html { redirect_to store_url, notice:
'Thank you for your order.' }
format.json { render json: @order, status: :created,
location: @order }
else
@cart = current_cart
format.html { render action: "new" }
format.json { render json: @order.errors,
status: :unprocessable_entity }
end
end
end

We start by creating a new Order object and initialize it from the form data. In
this case, we want all the form data related to order objects, so we select the
:order hash from the parameters (this is the name we passed as the first
parameter to form_for). The next line adds into this order the items that are
already stored in the cart—we’ll write the actual method to do this in a minute.
Next we tell the order object to save itself (and its children, the line items) to
the database. Along the way, the order object will perform validation (but we’ll
get to that in a minute). If the save succeeds, we do two things. First, we ready
ourselves for this customer’s next order by deleting the cart from the session.
Then, we redisplay the catalog using the redirect_to() method to display a
cheerful message. If, instead, the save fails, we redisplay the checkout form
with the current cart.
In the create action we assumed that the order object contains the method
add_line_items_from_cart(), so let’s implement that method now:

➤
➤
➤
➤
➤
➤

Download rails32/depot_p/app/models/order.rb
class Order < ActiveRecord::Base
# ...
def add_line_items_from_cart(cart)
cart.line_items.each do |item|
item.cart_id = nil
line_items << item
end
end
end

report erratum • discuss

Iteration G1: Capturing an Order

•

163

Joe asks:

Aren’t You Creating Duplicate Orders?
Joe is concerned to see our controller creating Order model objects in two actions: new
and create. He’s wondering why this doesn’t lead to duplicate orders in the database.
The answer is simple: the new action creates an Order object in memory simply to give
the template code something to work with. Once the response is sent to the browser,
that particular object gets abandoned, and it will eventually be reaped by Ruby’s
garbage collector. It never gets close to the database.
The create action also creates an Order object, populating it from the form fields. This
object does get saved in the database. So, model objects perform two roles: they map
data into and out of the database, but they are also just regular objects that hold
business data. They affect the database only when you tell them to, typically by calling
save().

For each item that we transfer from the cart to the order, we need to do two
things. First we set the cart_id to nil in order to prevent the item from going
poof when we destroy the cart.
Then we add the item itself to the line_items collection for the order. Notice that
we didn’t have to do anything special with the various foreign key fields, such
as setting the order_id column in the line item rows to reference the newly
created order row. Rails does that knitting for us using the has_many() and
belongs_to() declarations we added to the Order and LineItem models. Appending
each new line item to the line_items collection hands the responsibility for key
management over to Rails.
We will also need to modify the test to reflect the new redirect:
Download rails32/depot_p/test/functional/orders_controller_test.rb
test "should create order" do
assert_difference('Order.count') do
post :create, order: @order.attributes
end
➤

assert_redirected_to store_path
end

So, as a first test of all of this, hit the Place Order button on the checkout page
without filling in any of the form fields. You should see the checkout page
redisplayed along with some error messages complaining about the empty
fields, as shown in Figure 25, Full house! Every field fails validation., on page
165.

report erratum • discuss

164

•

Chapter 12. Task G: Check Out!

If we fill in some data (as shown at the top of Figure 26, Entering order information produces a ``Thanks!'', on page 166) and click Place Order , we should
get taken back to the catalog, as shown at the bottom of the figure. But did
it work? Let’s look in the database.
depot> sqlite3 -line db/development.sqlite3
SQLite version 3.7.4
Enter ".help" for instructions
sqlite> select * from orders;
id = 1
name = Dave Thomas
address = 123 Main St
email = customer@example.com
pay_type = Check
created_at = 2011-08-07 02:31:04.964785
updated_at = 2011-08-07 02:31:04.964785
sqlite> select * from line_items;
id = 10
product_id = 2
cart_id =
created_at = 2011-08-07 02:30:26.188914
updated_at = 2011-08-07 02:31:04.966057
quantity = 1
price = 36
order_id = 1
sqlite> .quit

Although what you see will differ on details such as version numbers and
dates (and price will be present only if you completed the exercises defined in
Playtime, on page 127), you should see a single order and one or more line
items that match your selections.

One Last Ajax Change
After we accept an order, we redirect to the index page, displaying the cheery
flash message “Thank you for your order.” If the user continues to shop and
they have JavaScript enabled in their browser, we’ll fill the cart in their sidebar
without redrawing the main page. This means the flash message will continue
to be displayed. We’d rather it went away after we add the first item to the
cart (as it does when JavaScript is disabled in the browser). Fortunately, the
fix is simple: we just hide the <div> that contains the flash message when we
add something to the cart.
Download rails32/depot_p/app/views/line_items/create.js.erb
➤ $("#notice").hide();
➤
if ($('#cart tr').length == 1) { $('#cart').show('blind', 1000); }

report erratum • discuss

Iteration G1: Capturing an Order

•

165

Figure 25—Full house! Every field fails validation.

$('#cart').html("<%=j render @cart %>");
$('#current_item').css({'background-color':'#88ff88'}).
animate({'background-color':'#114411'}, 1000);

Note that when we come to the store for the first time, there’s nothing in the
flash, so the paragraph with an ID of notice isn’t displayed. Therefore, there’s
no tag with the ID of notice, and the call to jQuery matches no elements. This
is not a problem, as the call to hide() is applied to each matching element, so
nothing happens. This is exactly what we want to happen, so all is well.
Now that we’ve captured the order, it is time to alert the ordering department.
We will do that with feeds, specifically, an Atom-formatted feed of orders.

report erratum • discuss

166

•

Chapter 12. Task G: Check Out!

Figure 26—Entering order information produces a “Thanks!”

Joe asks:

Why Atom?
There are a number of different feed formats, most notably RSS 1.0, RSS 2.0, and
Atom, standardized in 2000, 2002, and 2005, respectively. These three are all widely
supported. To aid with the transition, a number of sites provide multiple feeds for
the same site, but this is no longer necessary, increases user confusion, and generally
is not recommended.
The Ruby language provides a low-level library, which can produce any of these formats, as well as a number of other less common versions of RSS. For best results,
stick with one of the three main versions.
The Rails framework is all about picking reasonable defaults and has chosen Atom
as the default for feed formats. It is specified as an Internet standards track protocol
for the Internet community by the IETF, and Rails provides a higher-level helper
named atom_feed that takes care of a number of details based on knowledge of Rails
naming conventions for things like ids and dates.

report erratum • discuss

Iteration G2: Atom Feeds

•

167

12.2 Iteration G2: Atom Feeds
Using a standard feed format, such as Atom, means you can immediately
take advantage of a wide variety of preexisting clients. Because Rails already
knows about ids, dates, and links, it can free you from having to worry about
these pesky details and let you focus on producing a human-readable summary. We start by adding a new action to the resource and include Atom to
the list of formats that we respond to:
Download rails32/depot_p/app/controllers/products_controller.rb
def who_bought
@product = Product.find(params[:id])
respond_to do |format|
format.atom
end
end

By adding format.atom, we cause Rails to look for a template named who_
bought.atom.builder. Such a template can use the generic XML functionality that
Builder provides as well as using the knowledge of the Atom feed format that
the atom_feed helper provides:
Download rails32/depot_p/app/views/products/who_bought.atom.builder
atom_feed do |feed|
feed.title "Who bought #{@product.title}"
latest_order = @product.orders.sort_by(&:updated_at).last
feed.updated( latest_order && latest_order.updated_at )
@product.orders.each do |order|
feed.entry(order) do |entry|
entry.title "Order #{order.id}"
entry.summary type: 'xhtml' do |xhtml|
xhtml.p "Shipped to #{order.address}"
xhtml.table do
xhtml.tr do
xhtml.th 'Product'
xhtml.th 'Quantity'
xhtml.th 'Total Price'
end
order.line_items.each do |item|
xhtml.tr do
xhtml.td item.product.title
xhtml.td item.quantity
xhtml.td number_to_currency item.total_price
end
end
xhtml.tr do

report erratum • discuss

168

•

Chapter 12. Task G: Check Out!
xhtml.th 'total', colspan: 2
xhtml.th number_to_currency \
order.line_items.map(&:total_price).sum
end
end

xhtml.p "Paid by #{order.pay_type}"
end
entry.author do |author|
author.name order.name
author.email order.email
end
end
end
end

More information on Builder can be found in Section 25.1, Generating XML
with Builder, on page 419.
At the overall feed level, we only need to provide two pieces of information:
the title and the latest updated date. If there are no orders, the updated_at value
will be null, and Rails will supply the current time instead.
Then we iterate over each order associated with this product. Note that there
is no direct relationship between these two models. In fact, the relationship
is indirect. Products have many line_items and line_items belong to an order. We
could iterate and traverse, but by simply declaring that there is a relationship
between products and orders through the line_items relationship, we can simplify our code:
Download rails32/depot_p/app/models/product.rb
class Product < ActiveRecord::Base
has_many :line_items
➤
has_many :orders, through: :line_items
#...
end

For each order, we provide a title, a summary, and an author. The summary
can be full XHTML, and we use this to produce a table of product titles,
quantity ordered, and total prices. We follow this table with a paragraph
containing the pay_type.
To make this work, we need to define a route. This action will respond to
HTTP GET requests and will operate on a member of the collection (in other
words, on an individual product) as opposed to the entire collection itself
(which in this case would mean all products):
Download rails32/depot_p/config/routes.rb
Depot::Application.routes.draw do

report erratum • discuss

Iteration G2: Atom Feeds

•

169

resources :orders
resources :line_items
resources :carts
get "store/index"
➤
➤
➤

resources :products do
get :who_bought, on: :member
end
# ...
# You can have the root of your site routed with "root"
# just remember to delete public/index.html.
# root :to => 'welcome#index'
root to: 'store#index', as: 'store'
# ...
end

We can try it for ourselves:
depot> curl --silent http://localhost:3000/products/3/who_bought.atom
<?xml version="1.0" encoding="UTF-8"?>
<feed xml:lang="en-US" xmlns="http://www.w3.org/2005/Atom">
<id>tag:localhost,2005:/products/3/who_bought</id>
<link type="text/html" href="http://localhost:3000" rel="alternate"/>
<link type="application/atom+xml"
href="http://localhost:3000/info/who_bought/3.atom" rel="self"/>
<title>Who bought Programming Ruby 1.9</title>
<updated>2011-08-07T02:31:04Z</updated>
<entry>
<id>tag:localhost,2005:Order/1</id>
<published>2011-08-07T02:31:04Z</published>
<updated>2011-08-07T02:31:04Z</updated>
<link rel="alternate" type="text/html"
href="http://localhost:3000/orders/1"/>
<title>Order 1</title>
<summary type="xhtml">
<div xmlns="http://www.w3.org/1999/xhtml">
<p>Shipped to 123 Main St</p>
<table>
...
</table>
<p>Paid by check</p>
</div>
</summary>
<author>
<name>Dave Thomas</name>
<email>customer@pragprog.com</email>

report erratum • discuss

170

•

Chapter 12. Task G: Check Out!

</author>
</entry>
</feed>

Looks good. Now we can subscribe to this in our favorite feed reader.

12.3 Iteration G3: Pagination
At the moment, we have a few products, a few carts at any one time, and a
few line items per cart or order, but we can have essentially an unlimited
number of orders, and we hope to have many—enough so that displaying all
of them on an orders page will quickly become unwieldy. Enter the will_paginate
plugin. This plugin extends Rails to provide this much-needed function.
Why a plugin? Back in Rails 1.0, this functionality was part of Rails itself.
But there were competing ideas on how this could be implemented and
improved, and the function was broken out in order to enable innovation to
thrive.
The first thing we need to do is to inform Rails of our intent to use the plugin.
We do that by modifying the Gemfile file. We need to specify that we want a
version that is greater than or equal to 3.0 because previous versions don’t
work with Rails 3.1.
Download rails32/depot_q/Gemfile
source 'https://rubygems.org'
gem 'rails', '3.2.0'
# Bundle edge Rails instead:
# gem 'rails', :git => 'git://github.com/rails/rails.git'
gem 'sqlite3'

# Gems used only for assets and not required
# in production environments by default.
group :assets do
gem 'sass-rails',
'~> 3.2.3'
gem 'coffee-rails', '~> 3.2.1'
# See https://github.com/sstephenson/execjs#readme for more supported runtimes
# gem 'therubyracer'
gem 'uglifier', '>= 1.0.3'
end
gem 'jquery-rails'

report erratum • discuss

Iteration G3: Pagination

•

171

# To use ActiveModel has_secure_password
# gem 'bcrypt-ruby', '~> 3.0.0'
# To use Jbuilder templates for JSON
# gem 'jbuilder'
# Use unicorn as the web server
# gem 'unicorn'
# Deploy with Capistrano
# gem 'capistrano'
# To use debugger
# gem 'ruby-debug19', :require => 'ruby-debug'
➤ gem 'will_paginate', '~> 3.0'

With this in place, we can use the bundle command to install our dependencies:
depot> bundle install

Depending on your operating system and your setup, you may need to run
this command as root.
The bundle command will actually do much more. It will cross-check gem
dependencies, find a configuration that works, and download and install
whatever components are necessary. But this needn’t concern us now; we
added only one component, and we can rest assured that this one is included
in the gems that the bundler installed.
We must do one last thing after updating or installing a new gem: restart the
server. Although Rails does a good job of detecting and keeping up with your
latest changes to your application, it is impossible to predict what needs to
be done when an entire gem is added or replaced.
Now let’s generate some test data. We could click repeatedly on the buttons
we have, but computers are good at this. This isn’t exactly seed data, simply
something done once and thrown away. Let’s create a file in the script directory.
Download rails32/depot_q/script/load_orders.rb
Order.transaction do
(1..100).each do |i|
Order.create(name: "Customer #{i}", address: "#{i} Main Street",
email: "customer-#{i}@example.com", pay_type: "Check")
end
end

This will create 100 orders with no line items in them. Feel free to modify the
script to create line items if you are so inclined. Note that this code does all

report erratum • discuss

172

•

Chapter 12. Task G: Check Out!

this work in one transaction. This isn’t precisely required for this activity but
does speed up the processing.
Note that we don’t have any require statements or initialization to open or close
the database. We will allow Rails to take care of this for us:
rails runner script/load_orders.rb

Now that the setup is done, we are ready to make the changes necessary to
our application. First, we will modify our controller to call paginate(), passing
it in the page and the order in which we want the results displayed:
Download rails32/depot_q/app/controllers/orders_controller.rb
def index
➤
@orders = Order.paginate page: params[:page], order: 'created_at desc',
➤
per_page: 10
respond_to do |format|
format.html # index.html.erb
format.json { render json: @orders }
end
end

Next, we will add links to the bottom of our index view:
Download rails32/depot_q/app/views/orders/index.html.erb
<h1>Listing orders</h1>
<table>
<tr>
<th>Name</th>
<th>Address</th>
<th>Email</th>
<th>Pay type</th>
<th></th>
<th></th>
<th></th>
</tr>
<% @orders.each do |order| %>
<tr>
<td><%= order.name %></td>
<td><%= order.address %></td>
<td><%= order.email %></td>
<td><%= order.pay_type %></td>
<td><%= link_to 'Show', order %></td>
<td><%= link_to 'Edit', edit_order_path(order) %></td>
<td><%= link_to 'Destroy', order, confirm: 'Are you sure?',
method: :delete %></td>
</tr>
<% end %>

report erratum • discuss

Iteration G3: Pagination

•

173

</table>
<br />
<%= link_to 'New Order', new_order_path %>
➤ <p><%= will_paginate @orders %></p>

And that is all there is to it! The default is to show thirty entries per page,
and the links will show up only if there are more than one page of orders.
The controller specifies the number of orders to display on a page using the
:per_page option. See Figure 27, Showing ten orders out of more than a hundred,
on page 174.
The customer likes it. We’ve implemented product maintenance, a basic
catalog, and a shopping cart, and now we have a simple ordering system.
Obviously we’ll also have to write some kind of fulfillment application, but
that can wait for a new iteration. (And that iteration is one that we’ll skip in
this book; it doesn’t have much new to say about Rails.)

What We Just Did
In a fairly short amount of time, we did the following:
• We created a form to capture details for the order and linked it to a new
order model.
• We added validation and used helper methods to display errors to the
user.
• We installed and used a plugin to paginate the list of orders.
• We provided a feed so that the administrator can monitor orders as they
come in.

Playtime
Here’s some stuff to try on your own:
• Get HTML-, XML-, and JSON-formatted views working for who_bought
requests. Experiment with including the order information in the XML
view by rendering @product.to_xml(include: :orders). Do the same thing for JSON.
• What happens if you click the Checkout button in the sidebar while the
checkout screen is already displayed? Can you find a way to disable the
button in this circumstance?

report erratum • discuss

174

•

Chapter 12. Task G: Check Out!

Figure 27—Showing ten orders out of more than a hundred

• The list of possible payment types is currently stored as a constant in the
Order class. Can you move this list into a database table? Can you still
make validation work for the field?
(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

report erratum • discuss

In this chapter, we’ll see
• sending email,
• integration testing.

CHAPTER 13

Task H: Sending Mail
At this point, we have a website that will respond to requests and will provide
feeds that allow sales of individual titles to be checked on periodically. At
times it makes sense to have something more than that. For those times,
what we need is the ability to actively target a message to somebody specific
when an event occurs. It could be wanting to notify a system administrator
when an exception occurs. It could be a user feedback form. In this chapter,
we will opt to simply send confirmation emails to people who have placed
orders. Once we complete that, we will create tests not only for the mail
support that we just added but for the entire user scenario we have created
so far.

13.1 Iteration H1: Sending Confirmation Emails
There are three basic parts to sending email in Rails: configuring how email
is to be sent, determining when to send the email, and specifying what you
want to say. We will cover each of these three in turn.

Email Configuration
Email configuration is part of a Rails application’s environment and involves
a Depot::Application.configure block. If you want to use the same configuration for
development, testing, and production, add the configuration to environment.rb
in the config directory; otherwise, add different configurations to the appropriate
files in the config/environments directory.
Inside the block, you will need to have one or more statements. You first have
to decide how you want mail delivered:
config.action_mailer.delivery_method = :smtp | :sendmail | :test

The :smtp and :sendmail options are used when you want Action Mailer to attempt
to deliver email. You’ll clearly want to use one of these methods in production.

report erratum • discuss

176

•

Chapter 13. Task H: Sending Mail

The :test setting is great for unit and functional testing, which we will make
use of in Function Testing Email, on page 181. Email will not be delivered;
instead, it will be appended to an array (accessible via the attribute ActionMailer::Base.deliveries). This is the default delivery method in the test environment.
Interestingly, though, the default in development mode is :smtp. If you want
Rails to deliver email during the development of your application, this is good.
If you’d rather disable email delivery in development mode, edit the file development.rb in the directory config/environments, and add the following lines:
Depot::Application.configure do
config.action_mailer.delivery_method = :test
end

The :sendmail setting delegates mail delivery to your local system’s sendmail
program, which is assumed to be in /usr/sbin. This delivery mechanism is not
particularly portable, because sendmail is not always installed in this directory
on different operating systems. It also relies on your local sendmail supporting
the -i and -t command options.
You achieve more portability by leaving this option at its default value of :smtp.
If you do so, you’ll need also to specify some additional configuration to tell
Action Mailer where to find an SMTP server to handle your outgoing email.
This may be the machine running your web application, or it may be a separate
box (perhaps at your ISP if you’re running Rails in a noncorporate environment). Your system administrator will be able to give you the settings for
these parameters. You may also be able to determine them from your own
mail client’s configuration.
The following are typical settings for Gmail. Adapt them as you need.
Depot::Application.configure do
config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
address:
"smtp.gmail.com",
port:
587,
domain:
"domain.of.sender.net",
authentication: "plain",
user_name:
"dave",
password:
"secret",
enable_starttls_auto: true
}
end

As with all configuration changes, you’ll need to restart your application if
you make changes to any of the environment files.

report erratum • discuss

Iteration H1: Sending Confirmation Emails

•

177

Sending Email
Now that we have everything configured, let’s write some code to send emails.
By now you shouldn’t be surprised that Rails has a generator script to create
mailers. In Rails, a mailer is a class that’s stored in the app/mailers directory.
It contains one or more methods, with each method corresponding to an email
template. To create the body of the email, these methods in turn use views
(in just the same way that controller actions use views to create HTML and
XML). So, let’s create a mailer for our store application. We’ll use it to send
two different types of email: one when an order is placed and a second when
the order ships. The rails generate mailer command takes the name of the mailer
class, along with the names of the email action methods:
depot> rails generate mailer OrderNotifier received shipped
create app/mailers/order_notifier.rb
invoke erb
create
app/views/order_notifier
create
app/views/order_notifier/received.text.erb
create
app/views/order_notifier/shipped.text.erb
invoke test_unit
create
test/functional/order_notifier_test.rb

Notice that we’ve created an OrderNotifier class in app/mailers and two template
files, one for each email type, in app/views/order_notifier. (We also created a test
file—we’ll look into this later in Function Testing Email, on page 181.)
Each method in the mailer class is responsible for setting up the environment
for sending a particular email. Let’s look at an example before going into the
details. Here’s the code that was generated for our OrderNotifier class, with one
default changed:
Download rails32/depot_q/app/mailers/order_notifier.rb
class OrderNotifier < ActionMailer::Base
➤
default from: 'Sam Ruby <depot@example.com>'
# Subject can be set in your I18n file at config/locales/en.yml
# with the following lookup:
#
#
en.order_notifier.received.subject
#
def received
@greeting = "Hi"
mail to: "to@example.org"
end
# Subject can be set in your I18n file at config/locales/en.yml
# with the following lookup:

report erratum • discuss

178

•

Chapter 13. Task H: Sending Mail

#
#
en.order_notifier.shipped.subject
#
def shipped
@greeting = "Hi"
mail to: "to@example.org"
end
end

If you are thinking to yourself that this looks like a controller, it is because
it very much does. One method per action. Instead of a call to render, there
is a call to mail. Mail accepts a number of parameters including :to (as shown),
:cc, :from, and :subject, each of which does pretty much what you would expect
them to do. Values that are common to all mail calls in the mailer can be set
as defaults by simply calling default, as is done for :from at the top of this class.
Feel free to tailor this to your needs.
The comments in this class also indicate that subject lines are already enabled
for translation, a subject we cover in Chapter 15, Task J: Internationalization,
on page 209. For now, we will simply use the :subject parameter.
As with controllers, templates contain the text to be sent, and controllers and
mailers can provide values to be inserted into those templates via instance
variables.

Email Templates
The generate script created two email templates in app/views/order_notifier, one
for each action in the Notifier class. These are regular .erb files. We’ll use them
to create plain-text emails (we’ll see later how to create HTML email). As with
the templates we use to create our application’s web pages, the files contain
a combination of static text and dynamic content. We can customize the
template in received.text.erb; this is the email that is sent to confirm an order:
Download rails32/depot_q/app/views/order_notifier/received.text.erb
Dear <%= @order.name %>
Thank you for your recent order from The Pragmatic Store.
You ordered the following items:
<%= render @order.line_items %>
We'll send you a separate e-mail when your order ships.

report erratum • discuss

Iteration H1: Sending Confirmation Emails

•

179

The partial template that renders a line item formats a single line with the
item quantity and the title. Because we’re in a template, all the regular helper
methods, such as truncate(), are available:
Download rails32/depot_q/app/views/line_items/_line_item.text.erb
<%= sprintf("%2d x %s",
line_item.quantity,
truncate(line_item.product.title, length: 50)) %>

We now have to go back and fill in the received() method in the OrderNotifier class:
Download rails32/depot_r/app/mailers/order_notifier.rb
def received(order)
@order = order
mail to: order.email, subject: 'Pragmatic Store Order Confirmation'
end

What we did here is add order as an argument to the method-received call,
add code to copy the parameter passed into an instance variable, and update
the call to mail() specifying where to send the email and what subject line to
use.

Generating Emails
Now that we have our template set up and our mailer method defined, we
can use them in our regular controllers to create and/or send emails.
Download rails32/depot_r/app/controllers/orders_controller.rb
def create
@order = Order.new(params[:order])
@order.add_line_items_from_cart(current_cart)
respond_to do |format|
if @order.save
Cart.destroy(session[:cart_id])
session[:cart_id] = nil
➤
OrderNotifier.received(@order).deliver
format.html { redirect_to store_url, notice:
'Thank you for your order.' }
format.json { render json: @order, status: :created,
location: @order }
else
@cart = current_cart
format.html { render action: "new" }
format.json { render json: @order.errors,
status: :unprocessable_entity }
end
end
end

report erratum • discuss

180

•

Chapter 13. Task H: Sending Mail

And we need to update the shipped() just like we did for received():
Download rails32/depot_r/app/mailers/order_notifier.rb
def shipped(order)
@order = order
mail to: order.email, subject: 'Pragmatic Store Order Shipped'
end

At this point, we have enough of the basics in place that you can place an
order and have a plain email sent to yourself, presuming that you didn’t disable the sending of email in development mode. Now let’s spice up the email
with a bit of formatting.

Delivering Multiple Content Types
Some people prefer receiving email in plain-text format, while others like the
look of an HTML email. Rails makes it easy to send email messages that
contain alternative content formats, allowing the user (or their email client)
to decide what they’d prefer to view.
In the preceding section, we created a plain-text email. The view file for our
received action was called received.text.erb. This is the standard Rails naming
convention. We can also create HTML-formatted emails.
Let’s try this with the order shipped notification. We don’t need to modify any
code; we simply need to create a new template:
Download rails32/depot_r/app/views/order_notifier/shipped.html.erb
<h3>Pragmatic Order Shipped</h3>
<p>
This is just to let you know that we've shipped your recent order:
</p>
<table>
<tr><th colspan="2">Qty</th><th>Description</th></tr>
<%= render @order.line_items %>
</table>

We don’t even need to modify the partial, because the existing one we already
have will do just fine:
Download rails32/depot_r/app/views/line_items/_line_item.html.erb
<% if line_item == @current_item %>
<tr id="current_item">
<% else %>
<tr>
<% end %>
<td><%= line_item.quantity %>&times;</td>
<td><%= line_item.product.title %></td>

report erratum • discuss

Iteration H1: Sending Confirmation Emails

•

181

<td class="item_price"><%= number_to_currency(line_item.total_price) %></td>
</tr>

But, for email templates, there’s a little bit more naming magic. If you create
multiple templates with the same name but with different content types
embedded in their filenames, Rails will send all of them in one email, arranging
the content so that the email client will be able to distinguish each.
This means you will want to either update or delete the plain-text template
that Rails provided for the shipped notifier.

Function Testing Email
When we used the generate script to create our order mailer, it automatically
constructed a corresponding order_notifier_test.rb file in the application’s
test/functional directory. It is pretty straightforward; it simply calls each action
and verifies selected portions of the email produced. As we have tailored the
email, let’s update the test case to match:
Download rails32/depot_r/test/functional/order_notifier_test.rb
require 'test_helper'

➤
➤
➤
➤
➤

➤
➤
➤
➤
➤
➤

class OrderNotifierTest < ActionMailer::TestCase
test "received" do
mail = OrderNotifier.received(orders(:one))
assert_equal "Pragmatic Store Order Confirmation", mail.subject
assert_equal ["dave@example.org"], mail.to
assert_equal ["depot@example.com"], mail.from
assert_match /1 x Programming Ruby 1.9/, mail.body.encoded
end
test "shipped" do
mail = OrderNotifier.shipped(orders(:one))
assert_equal "Pragmatic Store Order Shipped", mail.subject
assert_equal ["dave@example.org"], mail.to
assert_equal ["depot@example.com"], mail.from
assert_match /<td>1&times;<\/td>\s*<td>Programming Ruby 1.9<\/td>/,
mail.body.encoded
end
end

The test method instructs the mail class to create (but not to send) an email,
and we use assertions to verify that the dynamic content is what we expect.
Note the use of assert_match() to validate just part of the body content. Your
results may differ depending on how you tailored the default :from line in your
Notifier.

report erratum • discuss

182

•

Chapter 13. Task H: Sending Mail

Joe asks:

Can I Also Receive Email?
Action Mailer makes it easy to write Rails applications that handle incoming email.
Unfortunately, you need to find a way to retrieve appropriate emails from your server
environment and inject them into the application; this requires a bit more work.
The easy part is handling an email within your application. In your Action Mailer
class, write an instance method called receive() that takes a single parameter. This
parameter will be a Mail::Message object corresponding to the incoming email. You can
extract fields, the body text, and/or attachments and use them in your application.
All the normal techniques for intercepting incoming email end up running a command,
passing that command the content of the email as standard input. If we make the
Rails runner script the command that’s invoked whenever an email arrives, we can
arrange to pass that email into our application’s email-handling code. For example,
using procmail-based interception, we could write a rule that looks something like
the example that follows. Using the arcane syntax of procmail, this rule copies any
incoming email whose subject line contains Bug Report through our runner script:
RUBY=/opt/local/bin/ruby
TICKET_APP_DIR=/Users/dave/Work/depot
HANDLER='IncomingTicketHandler.receive(STDIN.read)'
:0 c
* ^Subject:.*Bug Report.*
| cd $TICKET_APP_DIR && $RUBY script/runner $HANDLER

The receive() class method is available to all Action Mailer classes. It takes the email
text, parses it into a Mail object, creates a new instance of the receiver’s class, and
passes the Mail object to the receive() instance method in that class.

At this point, we have verified that the message we intend to create is formatted
correctly, but we haven’t verified that it is sent when the customer completes
the ordering process. For that, we employ integration tests.

13.2 Iteration H2: Integration Testing of Applications
Rails organizes tests into unit, functional, and integration tests. Before
explaining integration tests, let’s have a brief recap of what we have covered
so far:
Unit testing of models
Model classes contain business logic. For example, when we add a product
to a cart, the cart model class checks to see whether that product is
already in the cart’s list of items. If so, it increments the quantity of that
item; if not, it adds a new item for that product.

report erratum • discuss

Iteration H2: Integration Testing of Applications

•

183

Functional testing of controllers
Controllers direct the show. They receive incoming web requests (typically
user input), interact with models to gather application state, and then
respond by causing the appropriate view to display something to the user.
So when we’re testing controllers, we’re making sure that a given request
is answered with an appropriate response. We still need models, but we
already have them covered with unit tests.
The next level of testing is to exercise the flow through our application. In
many ways, this is like testing one of the stories that our customer gave us
when we first started to code the application. For example, we might have
been told the following: A user goes to the store index page. They select a
product, adding it to their cart. They then check out, filling in their details on
the checkout form. When they submit, an order is created in the database
containing their information, along with a single line item corresponding to the
product they added to their cart. Once the order has been received, an email
is sent confirming their purchase.
This is ideal material for an integration test. Integration tests simulate a
continuous session between one or more virtual users and our application.
You can use them to send in requests, monitor responses, follow redirects,
and so on.
When you create a model or controller, Rails creates the corresponding unit
or functional tests. Integration tests are not automatically created, however,
but you can use a generator to create one.
depot> rails generate integration_test user_stories
invoke test_unit
create
test/integration/user_stories_test.rb

Notice that Rails automatically adds _test to the name of the test.
Let’s look at the generated file:
require 'test_helper'
class UserStoriesTest < ActionController::IntegrationTest
fixtures :all
# Replace this with your real tests.
test "the truth" do
assert true
end
end

Let’s launch straight in and implement the test of our story. Because we’ll
only be testing the purchase of a product, we’ll need only our products fixture.

report erratum • discuss

184

•

Chapter 13. Task H: Sending Mail

So instead of loading all the fixtures, let’s load only this one:
fixtures :products

Now let’s build a test named buying a product. By the end of the test, we know
we’ll want to have added an order to the orders table and a line item to the
line_items table, so let’s empty them out before we start. And, because we’ll be
using the Ruby book fixture data a lot, let’s load it into a local variable:
Download rails32/depot_r/test/integration/user_stories_test.rb
LineItem.delete_all
Order.delete_all
ruby_book = products(:ruby)

Let’s attack the first sentence in the user story: A user goes to the store index
page.
Download rails32/depot_r/test/integration/user_stories_test.rb
get "/"
assert_response :success
assert_template "index"

This almost looks like a functional test. The main difference is the get method.
In a functional test, we check just one controller, so we specify just an action
when calling get(). In an integration test, however, we can wander all over the
application, so we need to pass in a full (relative) URL for the controller and
action to be invoked.
The next sentence in the story goes They select a product, adding it to their
cart. We know that our application uses an Ajax request to add things to the
cart, so we’ll use the xml_http_request() method to invoke the action. When it
returns, we’ll check that the cart now contains the requested product:
Download rails32/depot_r/test/integration/user_stories_test.rb
xml_http_request :post, '/line_items', product_id: ruby_book.id
assert_response :success
cart = Cart.find(session[:cart_id])
assert_equal 1, cart.line_items.size
assert_equal ruby_book, cart.line_items[0].product

In a thrilling plot twist, the user story continues: They then check out…. That’s
easy in our test:
Download rails32/depot_r/test/integration/user_stories_test.rb
get "/orders/new"
assert_response :success
assert_template "new"

report erratum • discuss

Iteration H2: Integration Testing of Applications

•

185

At this point, the user has to fill in their details on the checkout form. Once
they do and they post the data, our application creates the order and redirects
to the index page. Let’s start with the HTTP side of the world by posting the
form data to the save_order action and verifying we’ve been redirected to the
index. We’ll also check that the cart is now empty. The test helper method
post_via_redirect() generates the post request and then follows any redirects
returned until a nonredirect response is returned.
Download rails32/depot_r/test/integration/user_stories_test.rb
post_via_redirect "/orders",
order: { name:
"Dave Thomas",
address: "123 The Street",
email:
"dave@example.com",
pay_type: "Check" }
assert_response :success
assert_template "index"
cart = Cart.find(session[:cart_id])
assert_equal 0, cart.line_items.size

Next, we’ll wander into the database and make sure we’ve created an order
and corresponding line item and that the details they contain are correct.
Because we cleared out the orders table at the start of the test, we’ll simply
verify that it now contains just our new order:
Download rails32/depot_r/test/integration/user_stories_test.rb
orders = Order.all
assert_equal 1, orders.size
order = orders[0]
assert_equal
assert_equal
assert_equal
assert_equal

"Dave Thomas",
"123 The Street",
"dave@example.com",
"Check",

order.name
order.address
order.email
order.pay_type

assert_equal 1, order.line_items.size
line_item = order.line_items[0]
assert_equal ruby_book, line_item.product

Finally, we’ll verify that the mail itself is correctly addressed and has the
expected subject line:
Download rails32/depot_r/test/integration/user_stories_test.rb
mail = ActionMailer::Base.deliveries.last
assert_equal ["dave@example.com"], mail.to
assert_equal 'Sam Ruby <depot@example.com>', mail[:from].value
assert_equal "Pragmatic Store Order Confirmation", mail.subject

And that’s it.
Here’s the full source of the integration test:

report erratum • discuss

186

•

Chapter 13. Task H: Sending Mail

Download rails32/depot_r/test/integration/user_stories_test.rb
require 'test_helper'
class UserStoriesTest < ActionDispatch::IntegrationTest
fixtures :products
#
#
#
#

A user goes to the index page. They select a product, adding it to their
cart, and check out, filling in their details on the checkout form. When
they submit, an order is created containing their information, along with a
single line item corresponding to the product they added to their cart.

test "buying a product" do
LineItem.delete_all
Order.delete_all
ruby_book = products(:ruby)
get "/"
assert_response :success
assert_template "index"
xml_http_request :post, '/line_items', product_id: ruby_book.id
assert_response :success
cart = Cart.find(session[:cart_id])
assert_equal 1, cart.line_items.size
assert_equal ruby_book, cart.line_items[0].product
get "/orders/new"
assert_response :success
assert_template "new"
post_via_redirect "/orders",
order: { name:
address:
email:
pay_type:
assert_response :success
assert_template "index"
cart = Cart.find(session[:cart_id])
assert_equal 0, cart.line_items.size

"Dave Thomas",
"123 The Street",
"dave@example.com",
"Check" }

orders = Order.all
assert_equal 1, orders.size
order = orders[0]
assert_equal
assert_equal
assert_equal
assert_equal

"Dave Thomas",
"123 The Street",
"dave@example.com",
"Check",

order.name
order.address
order.email
order.pay_type

report erratum • discuss

What We Just Did

•

187

assert_equal 1, order.line_items.size
line_item = order.line_items[0]
assert_equal ruby_book, line_item.product
mail = ActionMailer::Base.deliveries.last
assert_equal ["dave@example.com"], mail.to
assert_equal 'Sam Ruby <depot@example.com>', mail[:from].value
assert_equal "Pragmatic Store Order Confirmation", mail.subject
end
end

Taken together, unit, functional, and integration tests give you the flexibility
to test aspects of your application either in isolation or in combination with
each other. In Section 26.3, Finding More at RailsPlugins.org, on page 441, we
will tell you where you can find add-ons that take this to the next level and
allow you to write plain-text descriptions of behaviors that can be read by
your customer and be verified automatically.
Speaking of our customer, it is time to wrap this iteration up and see what
functionality is next in store for Depot.

13.3 What We Just Did
Without much code and with just a few templates, we have managed to pull
off the following:
• We configured our development, test, and production environments for
our Rails application to enable the sending of outbound emails.
• We created and tailored a mailer that will send confirmation emails in
both plain-text and HTML formats to people who order our products.
• We created both a functional test for the emails produced, as well as an
integration test that covers the entire order scenario.

Playtime
• Add a ship_date column to the orders table, and send a notification when
this value is updated by the OrdersController.
• Update the application to send an email to the system administrator,
namely, yourself, when there is an application failure such as the one we
handled in Section 10.2, Iteration E2: Handling Errors, on page 119.
• Add integration tests for both of the previous items.

report erratum • discuss

In this chapter, we’ll see
• adding secure passwords to models,
• using more validations,
• adding authentication to a session,
• using rails console,
• using database transactions, and
• writing an Active Record hook.

CHAPTER 14

Task I: Logging In
We have a happy customer—in a very short time we’ve jointly put together a
basic shopping cart that she can start showing to her users. There’s just one
more change that she’d like to see. Right now, anyone can access the administrative functions. She’d like us to add a basic user administration system
that would force you to log in to get into the administration parts of the site.
Chatting with our customer, it seems as if we don’t need a particularly sophisticated security system for our application. We just need to recognize a
number of people based on usernames and passwords. Once recognized,
these folks can use all of the administration functions.

14.1 Iteration I1: Adding Users
Let’s start by creating a model and database table to hold our administrators’
usernames and passwords. Rather than store passwords in plain text, we
will store a digest hash value of the password. By doing so we ensure that
even if our database is compromised, the hash won’t reveal the original
password, so it can’t be used to log in as this user using the forms.
depot> rails generate scaffold User name:string password_digest:string

Now run the migration as usual:
depot> rake db:migrate

Now we have to flesh out the user model:

report erratum • discuss

190

•

Chapter 14. Task I: Logging In

Download rails32/depot_r/app/models/user.rb
class User < ActiveRecord::Base
validates :name, presence: true, uniqueness: true
has_secure_password
end

We check that the name is present and unique (that is, no two users can have
the same name in the database). Then there’s the mysterious has_secure_password.
You know those forms that prompt you to enter a password and then make
you reenter it in a separate field so they can validate that you typed what you
thought you typed? Well, Rails can automatically validate that the two passwords match. We’ll see how that works in a minute. For now, we just have
to know how to enable this support in Rails.
The first step is to uncomment out the bcrypt-ruby gem in your Gemfile:
Download rails32/depot_r/Gemfile
# To use ActiveModel has_secure_password
➤ gem 'bcrypt-ruby', '~> 3.0.0'

Next, you need to install the gem:
depot> bundle install

Finally, you need to restart your server.
With this code in place, we have the ability to present both a password and
a password confirmation field in a form, as well as the ability to authenticate
a user given a name and a password.

Administering Our Users
In addition to the model and table we set up, we already have some scaffolding
generated to administer the model. However, this scaffolding needs some
tweaks to make use of the new password fields we just defined.
Let’s start with the controller. It defines the standard methods: index(), show(),
new(), edit(), update(), and delete(). But in the case of users, there isn’t really much
to show(), except a name and an unintelligible password hash. So, let’s avoid
the redirect to showing the user after a create operation. Instead, let’s redirect
to the user’s index and add the username to the flash notice.

String interpolation
↪ on page 40

Download rails32/depot_r/app/controllers/users_controller.rb
def create
@user = User.new(params[:user])

➤

respond_to do |format|
if @user.save
format.html { redirect_to users_url,

report erratum • discuss

Iteration I1: Adding Users
➤

•

191

notice: "User #{@user.name} was successfully created." }
format.json { render json: @user,
status: :created, location: @user }
else
format.html { render action: "new" }
format.json { render json: @user.errors,
status: :unprocessable_entity }
end
end
end

Let’s do the same for an update operation:
Download rails32/depot_r/app/controllers/users_controller.rb
def update
@user = User.find(params[:id])
respond_to do |format|
if @user.update_attributes(params[:user])
➤
format.html { redirect_to users_url,
➤
notice: "User #{@user.name} was successfully updated." }
format.json { head :no_content }
else
format.html { render action: "edit" }
format.json { render json: @user.errors,
status: :unprocessable_entity }
end
end
end

While we are here, let’s also order the users returned in the index by name:
Download rails32/depot_r/app/controllers/users_controller.rb
def index
➤
@users = User.order(:name)
respond_to do |format|
format.html # index.html.erb
format.json { render json: @users }
end
end

Now that the controller changes are done, let’s attend to the view. As it stands
now, the view doesn’t display notice information, and the table contains too
much information. Specifically, the table shows the digest password. We
proceed to add the notice and delete both the th and td lines for the digest
password field:
Download rails32/depot_r/app/views/users/index.html.erb
<h1>Listing users</h1>
➤
<% if notice %>
➤
<p id="notice"><%= notice %></p>

report erratum • discuss

192
➤

•

Chapter 14. Task I: Logging In

<% end %>
<table>
<tr>
<th>Name</th>
<th></th>
<th></th>
<th></th>
</tr>
<% @users.each do |user| %>
<tr>
<td><%= user.name %></td>
<td><%= link_to 'Show', user %></td>
<td><%= link_to 'Edit', edit_user_path(user) %></td>
<td><%= link_to 'Destroy', user, confirm: 'Are you sure?',
method: :delete %></td>
</tr>
<% end %>
</table>
<br />
<%= link_to 'New User', new_user_path %>

Finally, we need to update the form used both to create a new user and to
update an existing user. First, we replace the digest password with password
and password confirmation fields. Then we add legend and fieldset tags. And
finally we wrap the output in a <div> tag with a class that we previously defined
in our stylesheet.
Download rails32/depot_r/app/views/users/_form.html.erb
<div class="depot_form">
<%= form_for @user do |f| %>
<% if @user.errors.any? %>
<div id="error_explanation">
<h2><%= pluralize(@user.errors.count, "error") %>
prohibited this user from being saved:</h2>
<ul>
<% @user.errors.full_messages.each do |msg| %>
<li><%= msg %></li>
<% end %>
</ul>
</div>
<% end %>
<fieldset>
<legend>Enter User Details</legend>

report erratum • discuss

Iteration I1: Adding Users

•

193

<div>
<%= f.label :name %>:
<%= f.text_field :name, size: 40 %>
</div>
<div>
<%= f.label :password, 'Password' %>:
<%= f.password_field :password, size: 40 %>
</div>
<div>
<%= f.label :password_confirmation, 'Confirm' %>:
<%= f.password_field :password_confirmation, size: 40 %>
</div>
<div>
<%= f.submit %>
</div>
</fieldset>
<% end %>
</div>

Let’s try it. Navigate to http://localhost:3000/users/new. For a stunning example of
page design, see Figure 28, Entering user details, on page 194.
After clicking Create User , the index is redisplayed with a cheery flash notice.
If we look in our database, you’ll see that we’ve stored the user details.
depot> sqlite3 -line db/development.sqlite3 "select * from users"
id = 1
name = dave
password_digest = $2a$10$lki6/oAcOW4AWg4A0e0T8uxtri2Zx5g9taBXrd4mDSDVl3rQRWRNi
created_at = 2011-08-07 12:05:20.445775
updated_at = 2011-08-07 12:05:20.445775

Like we have done before, we need to update our tests to reflect the validation
and redirection changes we have made:
Download rails32/depot_r/test/functional/users_controller_test.rb
require 'test_helper'

➤
➤
➤
➤
➤

class UsersControllerTest < ActionController::TestCase
setup do
@input_attributes = {
name:
"sam",
password:
"private",
password_confirmation: "private"
}

report erratum • discuss

194

•

Chapter 14. Task I: Logging In

Figure 28—Entering user details

➤

@user = users(:one)
end
#...
test "should create user" do
assert_difference('User.count') do
post :create, user: @input_attributes
end

➤

assert_redirected_to users_path
end
#...
test "should update user" do
➤
put :update, id: @user, user: @input_attributes
➤
assert_redirected_to users_path
end
end

At this point, we can administer our users; we need to first authenticate users,
then restrict administrative functions to be accessible only by administrators.

14.2 Iteration I2: Authenticating Users
What does it mean to add login support for administrators of our store?
• We need to provide a form that allows them to enter their username and
password.

report erratum • discuss

Iteration I2: Authenticating Users

•

195

• Once they are logged in, we need to record that fact somehow for the rest
of their session (or until they log out).
• We need to restrict access to the administrative parts of the application,
allowing only people who are logged in to administer the store.
We’ll need a session controller to support logging in and out, and we’ll need
a controller to welcome administrators.
depot> rails generate controller Sessions new create destroy
depot> rails generate controller Admin index

The SessionsController#create action will need to record something in session to say
that an administrator is logged in. Let’s have it store the id of their User object
using the key :user_id. The login code looks like this:

➤
➤
➤
➤
➤
➤
➤

Download rails32/depot_r/app/controllers/sessions_controller.rb
def create
user = User.find_by_name(params[:name])
if user and user.authenticate(params[:password])
session[:user_id] = user.id
redirect_to admin_url
else
redirect_to login_url, alert: "Invalid user/password combination"
end
end

We are also doing something new here: using a form that isn’t directly associated with a model object. To see how that works, let’s look at the template
for the sessions#new action:
Download rails32/depot_r/app/views/sessions/new.html.erb
<div class="depot_form">
<% if flash[:alert] %>
<p id="notice"><%= flash[:alert] %></p>
<% end %>
<%= form_tag do %>
<fieldset>
<legend>Please Log In</legend>
<div>
<%= label_tag :name, 'Name:' %>
<%= text_field_tag :name, params[:name] %>
</div>
<div>
<%= label_tag :password, 'Password:' %>
<%= password_field_tag :password, params[:password] %>
</div>

report erratum • discuss

196

•

Chapter 14. Task I: Logging In

<div>
<%= submit_tag "Login" %>
</div>
</fieldset>
<% end %>
</div>

This form is different from ones we saw earlier. Rather than using form_for, it
uses form_tag, which simply builds a regular HTML <form>. Inside that form,
it uses text_field_tag and password_field_tag, two helpers that create HTML <input>
tags. Each helper takes two parameters. The first is the name to give to the
field, and the second is the value with which to populate the field. This style
of form allows us to associate values in the params structure directly with form
fields—no model object is required. In our case, we chose to use the params
object directly in the form. An alternative would be to have the controller set
instance variables.
We also make use of the label_tag helpers to create HTML <label> tags. This
helper also accepts two parameters. The first contains the name of the field,
and the second contains the label to be displayed.
See Figure 29, Parameters flow between controllers, templates, and browsers,
on page 197. Note how the value of the form field is communicated between
the controller and the view using the params hash: the view gets the value to
display in the field from params[:name], and when the user submits the form,
the new field value is made available to the controller the same way.
If the user successfully logs in, we store the id of the user record in the session
data. We’ll use the presence of that value in the session as a flag to indicate
that an admin user is logged in.
As you might expect, the controller actions for logging out are considerably
simpler:
Download rails32/depot_r/app/controllers/sessions_controller.rb
def destroy
➤
session[:user_id] = nil
➤
redirect_to store_url, notice: "Logged out"
end

Finally, it’s about time to add the index page, the first screen that administrators see when they log in. Let’s make it useful—we’ll have it display the total
number of orders in our store. Create the template in the file index.html.erb in
the directory app/views/admin. (This template uses the pluralize() helper, which in

report erratum • discuss

Iteration I2: Authenticating Users

•

197

Template
<% form_tag do %>
Name:
<%= text_ﬁeld_tag :name, params[:name] %>
...
<% end %>

Controller
def login
name = params[:name]
...
end

Figure 29—Parameters flow between controllers, templates, and browsers

this case generates the string order or orders depending on the cardinality of
its first parameter.)
Download rails32/depot_r/app/views/admin/index.html.erb
<h1>Welcome</h1>
It's <%= Time.now %>
We have <%= pluralize(@total_orders, "order") %>.

The index() action sets up the count:
Download rails32/depot_r/app/controllers/admin_controller.rb
class AdminController < ApplicationController
def index
➤
@total_orders = Order.count
end
end

report erratum • discuss

198

•

Chapter 14. Task I: Logging In

We have one more task to do before we can use this. Whereas previously we
relied on the scaffolding generator to create our model and routes for us, this
time we simply generated a controller because there is no database-backed
model for this controller. Unfortunately, without the scaffolding conventions
to guide it, Rails has no way of knowing which actions are to respond to GET
requests, which are to respond to POST requests, and so on, for this controller.
We need to provide this information by editing our config/routes.rb file:
Download rails32/depot_r/config/routes.rb
Depot::Application.routes.draw do
➤
get 'admin' => 'admin#index'
➤
➤
➤
➤
➤

controller :sessions do
get 'login' => :new
post 'login' => :create
delete 'logout' => :destroy
end
resources :users
resources :orders
resources :line_items
resources :carts
get "store/index"
resources :products do
get :who_bought, on: :member
end
# ...
# You can have the root of your site routed with "root"
# just remember to delete public/index.html.
# root :to => 'welcome#index'
root to: 'store#index', as: 'store'
# ...
end

We’ve touched this before, when we added a root statement in Section 8.1, Iteration C1: Creating the Catalog Listing, on page 91. What the generate
command will add to this file are fairly generic get statements for each of the
actions specified. You can (and should) delete the routes provided for sessions/new, sessions/create, and sessions/destroy.

report erratum • discuss

Iteration I2: Authenticating Users

•

199

In the case of admin, we will shorten the URL that the user has to enter (by
removing the /index part) and map it to the full action. In the case of session
actions, we will completely change the URL (replacing things like session/create
with simply login) as well as tailoring the HTTP action that we will match. Note
that login is mapped to both the new and create actions, the difference being
whether the request was an HTTP GET or HTTP POST.
We also make use of a shortcut: wrapping the session route declarations in
a block and passing it to a controller() class method. This saves us a bit of typing
as well as making the routes easier to read. We will describe all that you can
do in this file in Section 20.1, Dispatching Requests to Controllers, on page
307.
With these routes in place, we can experience the joy of logging in as an
administrator. See Figure 30, Administrative interface, on page 200.
We need to replace the functional tests in the session controller to match
what we just implemented:
Download rails32/depot_r/test/functional/sessions_controller_test.rb
require 'test_helper'
class SessionsControllerTest < ActionController::TestCase
test "should get new" do
get :new
assert_response :success
end
➤
➤
➤
➤
➤
➤

test "should login" do
dave = users(:one)
post :create, name: dave.name, password: 'secret'
assert_redirected_to admin_url
assert_equal dave.id, session[:user_id]
end

➤
➤
➤
➤
➤

test "should fail login" do
dave = users(:one)
post :create, name: dave.name, password: 'wrong'
assert_redirected_to login_url
end

➤
➤
➤
➤

test "should logout" do
delete :destroy
assert_redirected_to store_url
end
end

And we need to update the test fixtures to match:

report erratum • discuss

200

•

Chapter 14. Task I: Logging In

Figure 30—Administrative interface

Download rails32/depot_r/test/fixtures/users.yml
# Read about fixtures at
# http://api.rubyonrails.org/classes/ActiveRecord/Fixtures.html
one:
name: dave
password_digest: <%= BCrypt::Password.create('secret') %>
two:
name: MyString
password_digest: MyString

Note the use of dynamically computed values in the fixture, specifically for
the value of hashed_password. To make things match up, we use the same function that Rails itself1 uses to compute the password.
We show our customer where we are, but she points out that we still haven’t
controlled access to the administrative pages (which was, after all, the point
of this exercise).

14.3 Iteration I3: Limiting Access
We want to prevent people without an administrative login from accessing
our site’s admin pages. It turns out that it’s easy to implement using the Rails
filter facility.

1.

https://github.com/rails/rails/blob/3-1-stable/activemodel/lib/active_model/secure_password.rb

report erratum • discuss

Iteration I3: Limiting Access

•

201

Rails filters allow you to intercept calls to action methods, adding your own
processing before they are invoked, after they return, or both. In our case,
we’ll use a before filter to intercept all calls to the actions in our admin controller. The interceptor can check session[:user_id]. If it’s set and if it corresponds
to a user in the database, the application knows an administrator is logged
in, and the call can proceed. If it’s not set, the interceptor can issue a redirect,
in this case to our login page.
Where should we put this method? It could sit directly in the admin controller,
but, for reasons that will become apparent shortly, let’s put it instead in
ApplicationController, the parent class of all our controllers. This is in the file application_controller.rb in the directory app/controllers. Note too that we chose to restrict
access to this method. This prevents it from ever being exposed to end users
as an action.
Download rails32/depot_r/app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
➤
before_filter :authorize
# ...
➤
➤
➤
➤
➤
➤
➤
➤

protected
def authorize
unless User.find_by_id(session[:user_id])
redirect_to login_url, notice: "Please log in"
end
end
end

The before_filter() line causes the authorization() to be invoked before every action
in our application.
This is going too far. We have just limited access to the store itself to administrators. That’s not good.
We could go back and change things so that we mark only those methods
that specifically need authorization. Such an approach is called blacklisting
and is prone to errors of omission. A much better approach is to “whitelist”
or list methods or controllers for which authorization is not required. We do
this simply by inserting a skip_before_filter() call within the StoreController:
Download rails32/depot_r/app/controllers/store_controller.rb
class StoreController < ApplicationController
➤
skip_before_filter :authorize

And again for the SessionsController class:

report erratum • discuss

202

•

Chapter 14. Task I: Logging In

Download rails32/depot_r/app/controllers/sessions_controller.rb
class SessionsController < ApplicationController
➤
skip_before_filter :authorize

We’re not done yet; now we need to allow people to create, update, and delete
carts:
Download rails32/depot_r/app/controllers/carts_controller.rb
class CartsController < ApplicationController
➤
skip_before_filter :authorize, only: [:create, :update, :destroy]
➤

Create line items:
Download rails32/depot_r/app/controllers/line_items_controller.rb
class LineItemsController < ApplicationController
➤
skip_before_filter :authorize, only: :create
➤

And create orders (which includes access to the new form):
Download rails32/depot_r/app/controllers/orders_controller.rb
class OrdersController < ApplicationController
➤
skip_before_filter :authorize, only: [:new, :create]
➤

With the authorization logic in place, we can now navigate to http://localhost:3000/products. The filter method intercepts us on the way to the product
listing and shows us the login screen instead.
Unfortunately, this change pretty much invalidates most of our functional
tests because most operations will now redirect to the login screen instead
of doing the function desired. Fortunately, we can address this globally by
creating a setup() method in the test_helper. While we are there, we also define
some helper methods to login_as() and logout() a user.
Download rails32/depot_r/test/test_helper.rb
class ActiveSupport::TestCase
# ...
# Add more helper methods to be used by all tests here...
def login_as(user)
session[:user_id] = users(user).id
end
def logout
session.delete :user_id
end
def setup
login_as :one if defined? session

report erratum • discuss

Iteration I4: Adding a Sidebar, More Administration

•

203

end
end

Note that the setup() method will call login_as() only if session is defined. This
prevents the login from being executed in tests that do not involve a controller.
We show our customer and are rewarded with a big smile and a request:
could we add a sidebar and put links to the user and product administration
stuff in it? And while we’re there, could we add the ability to list and delete
administrative users? You betcha!

14.4 Iteration I4: Adding a Sidebar, More Administration
Let’s start with adding links to various administration functions to the sidebar
in the layout and have them show up only if there is :user_id in the session:
Download rails32/depot_r/app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
<title>Pragprog Books Online Store</title>
<%= stylesheet_link_tag "application" %>
<%= javascript_include_tag "application" %>
<%= csrf_meta_tag %>
</head>
<body class="<%= controller.controller_name %>">
<div id="banner">
<%= image_tag("logo.png") %>
<%= @page_title || "Pragmatic Bookshelf" %>
</div>
<div id="columns">
<div id="side">
<% if @cart %>
<%= hidden_div_if(@cart.line_items.empty?, id: 'cart') do %>
<%= render @cart %>
<% end %>
<% end %>
<ul>
<li><a
<li><a
<li><a
<li><a
</ul>
➤
➤
➤
➤
➤
➤

href="http://www....">Home</a></li>
href="http://www..../faq">Questions</a></li>
href="http://www..../news">News</a></li>
href="http://www..../contact">Contact</a></li>

<% if session[:user_id] %>
<ul>
<li><%= link_to 'Orders',
orders_path
%></li>
<li><%= link_to 'Products', products_path %></li>
<li><%= link_to 'Users',
users_path
%></li>

report erratum • discuss

204
➤
➤
➤

•

Chapter 14. Task I: Logging In

</ul>
<%= button_to 'Logout', logout_path, method: :delete
<% end %>
</div>
<div id="main">
<%= yield %>
</div>
</div>
</body>
</html>

%>

Now it is all starting to come together. We can log in, and by clicking a link
on the sidebar, we can see a list of users. Let’s see whether we can break
something.

Would the Last Admin to Leave…
We bring up the user list screen that looks something like Figure 31, Listing
our users, on page 205; then we click the Destroy link next to dave to delete
that user. Sure enough, our user is removed. But to our surprise, we’re then
presented with the login screen instead. We just deleted the only administrative
user from the system. When the next request came in, the authentication
failed, so the application refused to let us in. We have to log in again before
using any administrative functions.
But now we have an embarrassing problem: there are no administrative users
in the database, so we can’t log in.
Fortunately, we can quickly add a user to the database from the command
line. If you invoke the command rails console, Rails invokes Ruby’s irb utility,
but it does so in the context of your Rails application. That means you can
interact with your application’s code by typing Ruby statements and looking
at the values they return.
We can use this to invoke our user model directly, having it add a user into
the database for us:
depot> rails console
Loading development environment.
>> User.create(name: 'dave', password: 'secret',
password_confirmation: 'secret')
=> #<User:0x2933060 @attributes={...} ... >
>> User.count
=> 1

The >> sequences are prompts. After the first, we call the User class to create
a new user, and after the second, we call it again to show that we do indeed
have a single user in our database. After each command we enter, rails console

report erratum • discuss

Iteration I4: Adding a Sidebar, More Administration

•

205

Figure 31—Listing our users

displays the value returned by the code (in the first case, it’s the model object,
and in the second case, it’s the count).
Panic over. We can now log back in to the application. But how can we stop
this from happening again? There are several ways. For example, we could
write code that prevents you from deleting your own user. That doesn’t quite
work—in theory, A could delete B at just the same time that B deletes A.
Instead, let’s try a different approach. We’ll delete the user inside a database
transaction. If after we’ve deleted the user there are then no users left in the
database, we’ll roll the transaction back, restoring the user we just deleted.
To do this, we’ll use an Active Record hook method. We’ve already seen one
of these: the validate hook is called by Active Record to validate an object’s
state. It turns out that Active Record defines sixteen or so hook methods,
each called at a particular point in an object’s life cycle. We’ll use the after_destroy() hook, which is called after the SQL delete is executed. If a method by
this name is publicly visible, it will conveniently be called in the same transaction as the delete, so if it raises an exception, the transaction will be rolled
back. The hook method looks like this:
Download rails32/depot_s/app/models/user.rb
after_destroy :ensure_an_admin_remains

report erratum • discuss

206

•

Chapter 14. Task I: Logging In

private
def ensure_an_admin_remains
if User.count.zero?
raise "Can't delete last user"
end
end

The key concept here is the use of an exception to indicate an error when
deleting the user. This exception serves two purposes. First, because it is
raised inside a transaction, it causes an automatic rollback. By raising the
exception if the users table is empty after the deletion, we undo the delete and
restore that last user.
Second, the exception signals the error back to the controller, where we use
a begin/end block to handle it and report the error to the user in the flash. If
you want only to abort the transaction but not otherwise signal an exception,
raise an ActiveRecord::Rollback exception instead, because this is the only exception
that won’t be passed on by ActiveRecord::Base.transaction.

➤
➤
➤
➤
➤
➤

Download rails32/depot_s/app/controllers/users_controller.rb
def destroy
@user = User.find(params[:id])
begin
@user.destroy
flash[:notice] = "User #{@user.name} deleted"
rescue Exception => e
flash[:notice] = e.message
end
respond_to do |format|
format.html { redirect_to users_url }
format.json { head :no_content }
end

This code still has a potential timing issue—it is still possible for two administrators each to delete the last two users if their timing is right. Fixing this
would require more database wizardry than we have space for here.
In fact, the login system described in this chapter is rather rudimentary. Most
applications these days use a plugin to do this. A number of plugins are
available that provide ready-made solutions that not only are more comprehensive than the authentication logic shown here but generally require less
code and effort on your part to use. See Section 26.3, Finding More at RailsPlugins.org, on page 441 for a couple of examples.

14.5 What We Just Did
By the end of this iteration, we’ve done the following:

report erratum • discuss

What We Just Did

•

207

• We used has_secure_password to store an encrypted version of the password
into the database.
• We controlled access to the administration functions using before filters
to invoke an authorize() method.
• We saw how to use rails console to interact directly with a model (and dig
us out of a hole after we deleted the last user).
• We saw how a transaction can help prevent deleting the last user.

Playtime
Here’s some stuff to try on your own:
• Modify the user update function to require and validate the current
password before allowing a user’s password to be changed.
• When the system is freshly installed on a new machine, there are no
administrators defined in the database, and hence no administrator can
log on. But, if no administrator can log on, then no one can create an
administrative user. Change the code so that if no administrator is defined
in the database, any username works to log on (allowing you to quickly
create a real administrator).
• Experiment with rails console. Try creating products, orders, and line items.
Watch for the return value when you save a model object—when validation
fails, you’ll see false returned. Find out why by examining the errors:
>> prd = Product.new
=> #<Product id: nil, title: nil, description: nil, image_url:
nil, created_at: nil, updated_at: nil, price:
#<BigDecimal:246aa1c,'0.0',4(8)>>
>> prd.save
=> false
>> prd.errors.full_messages
=> ["Image url must be a URL for a GIF, JPG, or PNG image",
"Image url can't be blank", "Price should be at least 0.01",
"Title can't be blank", "Description can't be blank"]

• Look up the authenticate_or_request_with_http_basic() method and utilize it in your
:authorize filter if the request.format is not Mime::HTML. Test that it works by
accessing an Atom feed:
curl --silent --user dave:secret \
http://localhost:3000/products/2/who_bought.xml

report erratum • discuss

208

•

Chapter 14. Task I: Logging In

• While we have gotten our tests working by performing a login, we haven’t
yet written tests that verify that access to sensitive data requires login.
Write at least one test that verifies this by calling logout() and then attempting to fetch or update some data which requires authentication.
(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

report erratum • discuss

In this chapter, we’ll see
• localizing templates, and
• database design considerations for I18n.

CHAPTER 15

Task J: Internationalization
Now we have a basic cart working, and our customer starts to inquire about
languages other than English, noting that her company has a big push on
for expansion in emerging markets. Unless we can present something in a
language that visitors to our customer’s website will understand, our customer
will be leaving money on the table. We can’t have that.
The first problem is that none of us is a professional translator. The customer
reassures us that this is not something that we need to concern ourselves
with because that part of the effort will be outsourced. All we need to worry
about is enabling translation. Furthermore, we don’t have to worry about the
administration pages just yet, because all the administrators speak English.
What we have to focus on is the store.
That’s a relief—but is still a tall order. We are going to need to define a way
to enable the user to select a language, we are going to have to provide the
translations themselves, and we are going to have to change the views to use
these translations. But we are up to the task, and armed with a bit of memory
of high-school Spanish, we set off to work.

15.1 Iteration J1: Selecting the Locale
We start by creating a new configuration file that encapsulates our knowledge
of what locales are available and which one is to be used as the default.
Download rails32/depot_s/config/initializers/i18n.rb
#encoding: utf-8
I18n.default_locale = :en
LANGUAGES = [
['English',
'en'],
["Espa&ntilde;ol".html_safe, 'es']
]

report erratum • discuss

210

•

Chapter 15. Task J: Internationalization

Joe asks:

If I Stick to One Language, Do I Need to Read This
Chapter?
The short answer is no. In fact, many Rails applications are for a small or homogeneous group and never need translating. That being said, pretty much everybody that
does find that they need translation agrees that it is best if this is done early. So,
unless you are sure that translation will not ever be needed, it is our recommendation
that you at least understand what would be involved so that you can make an informed
decision.

This code is doing two things.
The first thing it does is use the I18n module to set the default locale. I18n is
a funny name, but it sure beats typing out internationalization all the time.
Internationalization, after all, starts with an i, ends with an n, and has eighteen
letters in between.
Then it defines a list of associations between display names and locale names.
Unfortunately, all we have available at the moment is a U.S. keyboard, and
español has a character that can’t be directly entered via our keyboard. Different operating systems have different ways of dealing with this, and often
the easiest way is to simply copy and paste the correct text from a website.
If you do this, just make sure your editor is configured for UTF-8. Meanwhile,
we’ve opted to use the HTML equivalent of “n con tilde” character in Spanish.
If we didn’t do anything else, the markup itself would be shown. But by calling
html_safe, we inform Rails that the string is safe to be interpreted as containing
HTML.
To get Rails to pick up this configuration change, the server needs to be
restarted.
Since each page that is translated will have an en and es version (for now,
more will be added later), it makes sense to include this in the URL. Let’s
plan to put the locale up front, make it optional, and have it default to the
current locale, which in turn will default to English.
To implement this cunning plan, let’s start with modifying config/routes.rb:
Download rails32/depot_s/config/routes.rb
Depot::Application.routes.draw do
get 'admin' => 'admin#index'
controller :sessions do
get 'login' => :new

report erratum • discuss

Iteration J1: Selecting the Locale

•

211

post 'login' => :create
delete 'logout' => :destroy
end
➤
scope '(:locale)' do
resources :users
resources :orders
resources :line_items
resources :carts
resources :products do
get :who_bought, on: :member
end
root to: 'store#index', as: 'store'
➤
end
end

What we have done is nested our resources and root declarations inside a
scope declaration for :locale. Furthermore, :locale is in parentheses, which is
the way to say that it is optional. Note that we did not choose to put the
administrative and session functions inside this scope, because it is not our
intent to translate them at this time.
What this means is that both http://localhost:3000/ will use the default locale, namely, English, and therefore be routed exactly the same as http://
localhost:3000/en. http://localhost:3000/es will route to the same controller
and action, but we will want this to cause the locale to be set differently.
To do this, we need to create a before_filter and to set the default_url_options. The
logical place to do both is in the common base class for all of our controllers,
which is ApplicationController:

➤

➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤
➤

Download rails32/depot_s/app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
before_filter :set_i18n_locale_from_params
# ...
protected
def set_i18n_locale_from_params
if params[:locale]
if I18n.available_locales.include?(params[:locale].to_sym)
I18n.locale = params[:locale]
else
flash.now[:notice] =
"#{params[:locale]} translation not available"
logger.error flash.now[:notice]
end
end
end
def default_url_options
{ locale: I18n.locale }

report erratum • discuss

212

•

Chapter 15. Task J: Internationalization

Figure 32—English version of the front page

➤

end
end

This set_i18n_locale_from_params does pretty much what it says: it sets the locale
from the params, but only if there is a locale in the params; otherwise, it
leaves the current locale alone. Care is taken to provide a message for both
the user and the administrator when there is a failure.
And default_url_options also does pretty much what it says, in that it provides a
hash of URL options that are to be considered as present whenever they aren’t
otherwise provided. In this case, we are providing a value for the :locale parameter. This is needed when a view on a page that does not have the locale
specified attempts to construct a link to a page that does. We will see that in
use soon.
With this in place, we can see the results in Figure 32, English version of the
front page, on page 212.
At this point, the English version of the page is available both at the root of
the website and at pages that start with /en. Additionally, a message on the
screen says that the translation is not available (as we can see in Figure 33,
Translation not available, on page 213), which will also leave a message in the
log indicating that the file wasn’t found. It might not look like it, but that’s
progress.

report erratum • discuss

Iteration J2: Translating the Storefront

•

213

Figure 33—Translation not available

15.2 Iteration J2: Translating the Storefront
Now it is time to begin providing the translated text. Let’s start with the layout,
because it is pretty visible. We replace any text that needs to be translated
with calls to I18n.translate. Not only is this method conveniently aliased as I18n.t,
but there also is a helper provided named t.
The parameter to the translate function is a unique dot-qualified name. We
can choose any name we like, but if we use the t helper function provided,
names that start with a dot will first be expanded using the name of the
template. So, let’s do that.
Download rails32/depot_s/app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
<title>Pragprog Books Online Store</title>
<%= stylesheet_link_tag "application" %>
<%= javascript_include_tag "application" %>
<%= csrf_meta_tag %>
</head>
<body class="<%= controller.controller_name %>">
<div id="banner">
<%= image_tag("logo.png") %>
➤
<%= @page_title || t('.title') %>
</div>

report erratum • discuss

214

•

Chapter 15. Task J: Internationalization

<div id="columns">
<div id="side">
<% if @cart %>
<%= hidden_div_if(@cart.line_items.empty?, id: 'cart') do %>
<%= render @cart %>
<% end %>
<% end %>

➤
➤
➤
➤

<ul>
<li><a
<li><a
<li><a
<li><a
</ul>

href="http://www...."><%= t('.home') %></a></li>
href="http://www..../faq"><%= t('.questions') %></a></li>
href="http://www..../news"><%= t('.news') %></a></li>
href="http://www..../contact"><%= t('.contact') %></a></li>

<% if session[:user_id] %>
<ul>
<li><%= link_to 'Orders',
orders_path
%></li>
<li><%= link_to 'Products', products_path %></li>
<li><%= link_to 'Users',
users_path
%></li>
</ul>
<%= button_to 'Logout', logout_path, method: :delete
<% end %>
</div>
<div id="main">
<%= yield %>
</div>
</div>
</body>
</html>

%>

Since this view is named layouts/application.html.erb, the English mappings will
expand to en.layouts.application. Here’s the corresponding locale file:
Download rails32/depot_s/config/locales/en.yml
en:
layouts:
application:
title:
home:
questions:
news:
contact:

"Pragmatic Bookshelf"
"Home"
"Questions"
"News"
"Contact"

and next in Spanish:
Download rails32/depot_s/config/locales/es.yml
es:
layouts:

report erratum • discuss

Iteration J2: Translating the Storefront
application:
title:
home:
questions:
news:
contact:

•

215

"Publicaciones de Pragmatic"
"Inicio"
"Preguntas"
"Noticias"
"Contacto"

The format is YAML, the same as the one used to configure the databases.
YAML simply consists of indented names and values, where the indentation
in this case matches the structure that we created in our names.

YAML
↪ on page 48

To get Rails to recognize that there are new YAML files, the server needs to
be restarted.
At this point, we can see in Figure 34, Baby steps: translated titles and sidebar,
on page 216 the actual translated text appearing in our browser window.
Next to be updated is the main title as well as the Add to Cart button. Both
can be found in the store index template:
Download rails32/depot_s/app/views/store/index.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
➤ <h1><%= t('.title_html') %></h1>

<% @products.each do |product| %>
<div class="entry">
<%= image_tag(product.image_url) %>
<h3><%= product.title %></h3>
<%= sanitize(product.description) %>
<div class="price_line">
<span class="price"><%= number_to_currency(product.price) %></span>
➤
<%= button_to t('.add_html'), line_items_path(product_id: product),
remote: true %>
</div>
</div>
<% end %>

And here’s the corresponding updates to the locales files, first in English:
Download rails32/depot_s/config/locales/en.yml
en:
store:
index:
title_html:
add_html:

"Your Pragmatic Catalog"
"Add to Cart"

and then in Spanish:

report erratum • discuss

216

•

Chapter 15. Task J: Internationalization

Figure 34—Baby steps: translated titles and sidebar

Download rails32/depot_s/config/locales/es.yml
es:
store:
index:
title_html:
add_html:

"Su Cat&aacute;logo de Pragmatic"
"A&ntilde;adir al Carrito"

Note that since title_html and add_html end in the characters _html, we are free to
use HTML entity names for characters that do not appear on our keyboard.
If we did not name the translation key this way, what you would end up seeing
on the page is the markup itself. This is yet another convention that Rails
has adopted to make your coding life easier. Rails will also treat names that
contain html as a component (in other words, the string .html.) as HTML key
names.
By refreshing the page in the browser window, we see the results shown in
Figure 35, Translated heading and button, on page 217.
Feeling confident, we move onto the cart partial:
Download rails32/depot_s/app/views/carts/_cart.html.erb
➤ <div class="cart_title"><%= t('.title') %></div>
<table>
<%= render(cart.line_items) %>
<tr class="total_line">
<td colspan="2">Total</td>

report erratum • discuss

Iteration J2: Translating the Storefront

•

217

Figure 35—Translated heading and button

<td class="total_cell"><%= number_to_currency(cart.total_price) %></td>
</tr>
</table>
➤ <%= button_to t('.checkout'), new_order_path, method: :get %>
➤ <%= button_to t('.empty'), cart, method: :delete,
confirm: 'Are you sure?' %>

And again, the translations:
Download rails32/depot_s/config/locales/en.yml
en:
carts:
cart:
title:
empty:
checkout:

"Your Cart"
"Empty cart"
"Checkout"

Download rails32/depot_s/config/locales/es.yml
es:
carts:
cart:
title:
empty:
checkout:

"Carrito de la Compra"
"Vaciar Carrito"
"Comprar"

Refreshing the page, and we see cart title and buttons have been translated:

report erratum • discuss

218

•

Chapter 15. Task J: Internationalization

We now notice our first problem. Languages are not the only thing that varies
from locale to locale; currencies do too. And the customary way that numbers
are presented varies too.
So, first we check with our customer, and we verify that we are not worrying
about exchange rates at the moment (whew!), because that will be taken care
of by the credit card and/or wire companies, but we do need to display the
string “USD” or “$US” after the value when we are showing the result in
Spanish.
Another variation is the way that numbers themselves are displayed. Decimal
values are delimited by a comma, and separators for the thousands place are
indicated by a dot.
Currency is a lot more complicated than it first appears, and that’s a lot of
decisions to be made. Fortunately, Rails knows to look in your translations
file for this information; all we need to do is supply it. First for en:
Download rails32/depot_s/config/locales/en.yml
en:
number:
currency:
format:
unit:
precision:
separator:
delimiter:
format:

"$"
2
"."
","
"%u%n"

report erratum • discuss

Iteration J3: Translating Checkout

•

219

And then for es:
Download rails32/depot_s/config/locales/es.yml
es:
number:
currency:
format:
unit:
precision:
separator:
delimiter:
format:

"$US"
2
","
"."
"%n&nbsp;%u"

We’ve specified the unit, precision, separator, and delimiter for number.currency.
format. That much is pretty self-explanatory. The format is a bit more involved:
%n is a placeholder for the number itself; &nbsp; is a nonbreaking space character, preventing this value from being split across multiple lines; and %u is
a placeholder for the unit.

15.3 Iteration J3: Translating Checkout
Now we feel that we are in the home stretch. The new order page is next:
Download rails32/depot_s/app/views/orders/new.html.erb
<div class="depot_form">
<fieldset>
➤
<legend><%= t('.legend') %></legend>
<%= render 'form' %>
</fieldset>
</div>

report erratum • discuss

220

•

Chapter 15. Task J: Internationalization

Then the form that is used by this page:
Download rails32/depot_s/app/views/orders/_form.html.erb
<%= form_for(@order) do |f| %>
<% if @order.errors.any? %>
<div id="error_explanation">
<h2><%= pluralize(@order.errors.count, "error") %>
prohibited this order from being saved:</h2>
<ul>
<% @order.errors.full_messages.each do |msg| %>
<li><%= msg %></li>
<% end %>
</ul>
</div>
<% end %>
<div class="field">
<%= f.label :name %><br />
<%= f.text_field :name, size: 40 %>
</div>
<div class="field">
➤
<%= f.label :address, t('.address_html') %><br />
<%= f.text_area :address, rows: 3, cols: 40 %>
</div>
<div class="field">
<%= f.label :email %><br />
<%= f.email_field :email, size: 40 %>
</div>
<div class="field">
<%= f.label :pay_type %><br />
<%= f.select :pay_type, Order::PAYMENT_TYPES,
➤
prompt: t('.pay_prompt_html') %>
</div>
<div class="actions">
➤
<%= f.submit t('.submit') %>
</div>
<% end %>

Note that we do not normally have to explicitly call I18n functions on labels,
unless we want to do something special like allowing HTML entities. Here are
the corresponding locale definitions:
Download rails32/depot_s/config/locales/en.yml
en:
orders:
new:
legend:
form:
name:

"Please Enter Your Details"
"Name"

report erratum • discuss

Iteration J3: Translating Checkout

•

221

address_html: "Address"
email:
"E-mail"
pay_type:
"Pay with"
pay_prompt_html: "Select a payment method"
submit:
"Place Order"
Download rails32/depot_s/config/locales/es.yml
es:
orders:
new:
legend:
"Por favor, introduzca sus datos"
form:
name:
"Nombre"
address_html: "Direcci&oacute;n"
email:
"E-mail"
pay_type:
"Forma de pago"
pay_prompt_html: "Seleccione un m&eacute;todo de pago"
submit:
"Realizar Pedido"

See Figure 36, Ready to take your money—in Spanish, on page 222 for the
completed form.
All looks good until we hit the Realizar Pedido button prematurely and see Figure
37, Translation missing, on page 223. The error messages that Active Record
produces can also be translated; what we need to do is supply the translations:
Download rails32/depot_s/config/locales/es.yml
es:
activerecord:
errors:
messages:
inclusion:
blank:
errors:
template:
body:
header:
one:
other:

"no est&aacute; incluido en la lista"
"no puede quedar en blanco"

"Hay problemas con los siguientes campos:"
"1 error ha impedido que este %{model} se guarde"
"%{count} errores han impedido que este %{model} se guarde"

Note that messages with counts typically have two forms: errors.template.header.
one is the message that is produced when there is one error, and errors.template.
header.other is produced otherwise. This gives the translators the opportunity
to provide the correct pluralization of nouns and to match the verbs with the
nouns.

report erratum • discuss

222

•

Chapter 15. Task J: Internationalization

Figure 36—Ready to take your money—in Spanish

Since we once again made use of HTML entities, we will want these error
messages to be displayed as is (or in Rails parlance, raw). We will also need
to translate the error messages. So again, we modify the form:
Download rails32/depot_t/app/views/orders/_form.html.erb
<%= form_for(@order) do |f| %>
<% if @order.errors.any? %>
<div id="error_explanation">
➤
<h2><%=raw t('errors.template.header', count: @order.errors.count,
➤
model: t('activerecord.models.order')) %>.</h2>
➤
<p><%= t('errors.template.body') %></p>
<ul>
<% @order.errors.full_messages.each do |msg| %>
➤
<li><%=raw msg %></li>
<% end %>
</ul>
</div>
<% end %>
<!-- ... -->

Note that we are passing the count and model name (which is, itself, enabled
for translation) on the translate call for the error template header.

report erratum • discuss

Iteration J3: Translating Checkout

•

223

Figure 37—Translation missing

With these changes in place, we try again and see improvement in Figure 38,
English nouns in Spanish sentences, on page 224.
Better, but the names of the model and attributes bleed through the interface.
This is OK in English, because the names we picked work for English. We
need to provide translations for each.
This, too, goes into the YAML file:
Download rails32/depot_t/config/locales/es.yml
es:
activerecord:
models:
order:
attributes:
order:
address:
name:
email:
pay_type:

"pedido"

"Direcci&oacute;n"
"Nombre"
"E-mail"
"Forma de pago"

Note that there is no need to provide English equivalents for this, because
those messages are built in to Rails.
We are pleased to see the model and attribute names translated in Figure 39,
Model names are now translated too., on page 225; we fill out the form, we
submit the order, and we get a “Thank you for your order” message.

report erratum • discuss

224

•

Chapter 15. Task J: Internationalization

Figure 38—English nouns in Spanish sentences

We need to update the flash messages:
Download rails32/depot_t/app/controllers/orders_controller.rb
def create
@order = Order.new(params[:order])
@order.add_line_items_from_cart(current_cart)
respond_to do |format|
if @order.save
Cart.destroy(session[:cart_id])
session[:cart_id] = nil
OrderNotifier.received(@order).deliver
format.html { redirect_to store_url, notice:
➤
I18n.t('.thanks') }
format.json { render json: @order, status: :created,
location: @order }
else
@cart = current_cart
format.html { render action: "new" }
format.json { render json: @order.errors,
status: :unprocessable_entity }
end
end
end

Finally, we provide the translations:
Download rails32/depot_t/config/locales/en.yml
en:
thanks:

"Thank you for your order"

report erratum • discuss

Iteration J4: Add a Locale Switcher

•

225

Figure 39—Model names are now translated too.

Download rails32/depot_t/config/locales/es.yml
es:
thanks:

"Gracias por su pedido"

See the cheery message in Figure 40, Thanking the customer in Spanish, on
page 226.

15.4 Iteration J4: Add a Locale Switcher
We’ve completed the task, but we really need to advertise its availability more.
We spy some unused area in the top-right side of the layout, so we add a form
immediately before the image_tag:

➤
➤
➤
➤
➤
➤
➤

Download rails32/depot_t/app/views/layouts/application.html.erb
<div id="banner">
<%= form_tag store_path, class: 'locale' do %>
<%= select_tag 'set_locale',
options_for_select(LANGUAGES, I18n.locale.to_s),
onchange: 'this.form.submit()' %>
<%= submit_tag 'submit' %>
<%= javascript_tag "$('.locale input').hide()" %>
<% end %>
<%= image_tag("logo.png") %>
<%= @page_title || t('.title') %>
</div>

report erratum • discuss

226

•

Chapter 15. Task J: Internationalization

Figure 40—Thanking the customer in Spanish

The form_tag specifies the path to the store as the page to be redisplayed when
the form is submitted. A class attribute lets us associate the form with some
CSS.
The select_tag is used to define the one input field for this form, namely, locale.
It is an options list based on the LANGUAGES array that we set up in the configuration file, with the default being the current locale (also made available via
the I18n module). We also set up an onchange event handler, which will submit
this form whenever the value changes. This works only if JavaScript is enabled,
but it is handy.
Then we add a submit_tag for the cases when JavaScript is not available. To
handle the case where JavaScript is available and the submit button is
unnecessary, we add a tiny bit of JavaScript that will hide each of the input
tags in the locale form, even though we know that there is only one.
Next, we modify the store controller to redirect to the store path for a given
locale if the :set_locale form is used:
Download rails32/depot_t/app/controllers/store_controller.rb
def index
➤
if params[:set_locale]
➤
redirect_to store_path(locale: params[:set_locale])

report erratum • discuss

Iteration J4: Add a Locale Switcher

•

227

Figure 41—Locale selector in top right

➤

else
@products = Product.order(:title)
➤
@cart = current_cart
➤
end
end

Finally, we add a bit of CSS:
Download rails32/depot_t/app/assets/stylesheets/application.css.scss
.locale {
float: right;
margin: -0.25em 0.1em;
}

For the actual selector, see Figure 41, Locale selector in top right, on page 227.
We can now switch back and forth between languages with a single mouse
click.
At this point, we can now place orders in two languages, and our thoughts
turn to actual deployment. But because it has been a busy day, it is time to
put down our tools and relax. We will start on deployment in the morning.

What We Just Did
By the end of this iteration, we’ve done the following:
• We set the default locale for our application and provided a means for the
user to select an alternate locale.

report erratum • discuss

228

•

Chapter 15. Task J: Internationalization

• We created translation files for text fields, currency amounts, errors, and
model names.
• We altered layouts and views to call out to the I18n module by way of the
t() helper in order to translate textual portions of the interface.

Playtime
Here’s some stuff to try on your own:
• Add a locale column to the products database, and adjust the index view
to select only the products that match the locale. Adjust the products
view so that you can view, enter, and alter this new column. Enter a few
products in each locale, and test the resulting application.
• Determine the current exchange rate between U.S. dollars and euros, and
localize the currency display to display euros when ES_es is selected.
• Translate the Order::PAYMENT_TYPES shown in the drop-down. You will need
to keep the option value (which is sent to the server) the same. Only
change what is displayed.
(You’ll find hints at http://www.pragprog.com/wikis/wiki/RailsPlayTime.)

report erratum • discuss

In this chapter, we’ll see
• running our application in a production web server,
• configuring the database for MySQL,
• using Bundler and Git for version control, and
• deploying our application using Capistrano.

CHAPTER 16

Task K: Deployment and Production
Deployment is supposed to mark a happy point in the lifetime of our application. It’s when we take the code that we’ve so carefully crafted and upload it
to a server so that other people can use it. It’s when the beer, champagne,
and hors d’oeuvres are supposed to flow. Shortly thereafter, our application
will be written about in Wired magazine, and we’ll be overnight names in the
geek community.
The reality, however, is that it often takes quite a bit of up-front planning in
order to pull off a smooth and repeatable deployment of your application.
By the time we are through with this chapter, our setup will look like Figure
42, Application deployment road map, on page 230.
At the moment, we’ve been doing all of our work on one machine, though
user interaction with our web server could be done on a separate machine.
In the figure, the user’s machine is in the center, and the WEBRick web
server is on the left. This server makes use of SQLite3, various gems you have
installed, and your application code. Your code may or may not have also
been placed in Git by this point; either way, it will be by the end of the chapter,
as will be the gems you are using.
This Git repository will be replicated on the production server, which again
could be another machine but need not be. This server will be running a
combination of Apache httpd and Phusion Passenger. This code will access
a MySQL database on what may yet be a fourth machine.
Capistrano will be the tool we use to update the deployment server(s) remotely,
safely, and repeatably from the comfort of our development machine.
That’s a lot of moving parts!

report erratum • discuss

230

•

Chapter 16. Task K: Deployment and Production

git

git

Code

Gems

User

Apache /
Passenger

WEBrick

SQLite3

MySQL

Figure 42—Application deployment road map

Instead of doing it all at once, we will do it in three iterations. Iteration K1
will get the Depot application up and running with Apache, MySQL, and
Passenger—a truly production-quality web server environment.
We will leave Git, Bundler, and Capistrano to a second iteration. These tools
will enable us to separate our development activities from our deployment
environment. This means that by the time we are done, we will be deploying
twice; but that’s only this first time and only to ensure that each of the parts
are working independently. It also allows us to focus on a smaller set of
variables at any one time, which will simplify the process of untangling any
problems that we might encounter.
In a third iteration, we will cover various administrative and cleanup tasks.
Let’s get started!

16.1 Iteration K1: Deploying with Phusion Passenger and MySQL
So far, as we’ve been developing a Rails application on our local machine,
we’ve probably been using WEBrick or Mongrel when we run our server. For
the most part, it doesn’t matter. The rails server command will sort out the most
appropriate way to get our application running in development mode on port
3000. However, a deployed Rails application works a bit differently. We can’t
just fire up a single Rails server process and let it do all the work. Well, we
could, but it’s far from ideal. The reason for this is that Rails is singlethreaded. It can work on only one request at a time.

report erratum • discuss

Iteration K1: Deploying with Phusion Passenger and MySQL

•

231

Joe asks:

Can I Deploy to Microsoft Windows?
Although you can deploy applications to Windows environments, the overwhelming
amount of Rails tools and shared knowledge assumes a Unix-based operating system
such as Linux or Mac OS X. One such tool, Phusion Passenger, is highly recommended
by the Ruby on Rails development team and covered in this chapter.
The techniques described in this chapter can be used by those developing on Windows
and deploying to Linux or Mac OS X.

The Web, however, is an extremely concurrent environment. Production web
servers, such as Apache, Lighttpd, and Zeus, can work on several requests
—even tens or hundreds of requests—at the same time. A single-process,
single-threaded Ruby-based web server can’t possibly keep up. Luckily, it
doesn’t have to keep up. Instead, the way that we deploy a Rails application
into production is to use a front-end server, such as Apache, to handle requests from the client. Then, you use the HTTP proxying of Passenger to send
requests that should be handled by Rails to one of any number of back-end
application processes.

Installing Passenger
The first step is to ensure that the Apache web server is installed and running.
For Mac OS X users it is already installed with the operating system, but
you’ll need to enable it by going into System Preferences / Sharing and
enabling Web Sharing. Linux users should have already installed Apache in
in Section 1.3, Installing on Linux, on page 6.
The next step is to install Passenger:
$ gem install passenger
$ passenger-install-apache2-module

If the necessary dependencies are not met, the latter command will tell you
what you need to do. For example, on a Ubuntu 11.10 (Oneiric Ocelot), you
will find that you need to install libcurl4-openssl-dev, apache2-prefork-dev, libapr1-dev,
and libaprutil1-dev. If this happens, follow the provided instructions, and try the
passenger install command again.
Once the dependencies are satisfied, this command causes a number of
sources to be compiled and the configuration files to be updated. During the
process, it will ask us to update our Apache configuration. The first will be
to enable your freshly built module and will involve adding lines such as the

report erratum • discuss

232

•

Chapter 16. Task K: Deployment and Production

following to our Apache configuration. (Note: Passenger will tell you the exact
lines to copy and paste into this file, so use those, not these. Also, we’ve had
to elide the path specification in the LoadModule line to make it fit the page. Be
sure to use the path specification that Passenger provided for you.)
LoadModule passenger_module /home/rubys/.rvm/.../ext/apache2/mod_passenger.so
PassengerRoot /home/rubys/.rvm/gems/ruby-1.9.3-p0/gems/passenger-3.0.8
PassengerRuby /home/rubys/.rvm/wrappers/ruby-1.9.3-p0/ruby

To find out where your Apache configuration file is, try issuing the following
command:
$ apachectl -V | grep HTTPD_ROOT
$ apachectl -V | grep SERVER_CONFIG_FILE

On some systems, the command name is apache2ctl; on others, it’s httpd. Experiment until you find the correct command.
If we want to serve multiple applications with the same Apache web server,
we will first need to verify that the following line is present in the configuration
files already:
NameVirtualHost *:80

If this line is not present, add it before a line that contains the text Listen 80.

Deploying our Application Locally
The next step is to deploy our application. Whereas the previous step needs
to be done only once per server, this step is actually once per application.
Substitute your host’s name in the following ServerName line:
<VirtualHost *:80>
ServerName depot.yourhost.com
DocumentRoot /home/rubys/work/depot/public/
<Directory /somewhere/public>
AllowOverride all
Options -MultiViews
</Directory>
</VirtualHost>

Note that the DocumentRoot is set to our public directory in our Rails application.
Once this is in place, repeat this VirtualHost block once per application, adjusting
the ServerName and DocumentRoot in each block. We will also need to mark the
public directory as readable. The final version will look something like the
following:

report erratum • discuss

Iteration K1: Deploying with Phusion Passenger and MySQL

•

233

<VirtualHost *:80>
ServerName depot.yourhost.com
DocumentRoot /home/rubys/work/depot/public/
<Directory /home/rubys/work/depot/public>
AllowOverride all
Options -MultiViews
Order allow,deny
Allow from all
</Directory>
</VirtualHost>

The final step is to restart our Apache web server:
$ sudo apachectl restart

You will now need to configure your client so that it maps the host name you
chose to the correct machine. This is done in a file named /etc/hosts. On Windows machines, this file can be found in C:\windows\system32\drivers\etc\. To edit
this file, you will need to open the file as an administrator.
A typical /etc/hosts line will look like the following:
127.0.0.1 depot.yourhost.com

That’s it! We can now access our application using the host (or virtual host)
we specified. Unless we used a port number other than 80, there is no longer
any need for us to specify a port number on our URL.
There are a few things to be aware of:
• If, when restarting your server you see a message that The address or port is
invalid, this means the NameVirtualHost line is already present, perhaps in
another configuration file in the same directory. If so, remove the line you
added because this directive needs to be present only once.
• If we want to run in an environment other than production, we can include
a RailsEnv directive in each VirtualHost in our Apache configuration:
RailsEnv development

• We can restart our application without restarting Apache at any time by
updating or creating a file named restart.txt in the tmp of our application:
$ touch tmp/restart.txt

• The output of the passenger-install-apache2-module command will tell us where
we can find additional documentation.

report erratum • discuss

234

•

Chapter 16. Task K: Deployment and Production

Using MySQL for the Database
The SQLite website1 is refreshingly honest when it comes to describing what
this database is good at and what it is not good at. In particular, SQLite is
not recommended for high-volume, high-concurrency websites with large
datasets. And, of course, we want our website to be such a website.
There are plenty of alternatives to SQLite, both free and commercial. We will
go with MySQL. It is available via your native packaging tool in Linux, and
an installer is provided for OS X on the MySQL website.2 We recommend that
you download MySQL 5.1, as MySQL 5.5 is known not to work with Rails 3.1.
In addition to installing the MySQL database, you will also need to add the
mysql gem to the Gemfile:
Download rails32/depot_t/Gemfile
group :production do
gem 'mysql2'
end

By putting this gem in group production, it will not be loaded when running in
development or test. If you like, you can put sqlite3 gem into (separate) development and test groups.
Install the gem using bundle install. You may need to locate and install the
MySQL database development files for your operating system first. On
Ubuntu, for example, you will need to install libmysqlclient-dev.
You can use the mysql command-line client to create your database, or if you’re
more comfortable with tools such as phpmyadmin or CocoaMySQL, go for it:
depot>
mysql>
mysql>
->
mysql>

mysql -u root
CREATE DATABASE depot_production;
GRANT ALL PRIVILEGES ON depot_production.*
TO 'username'@'localhost' IDENTIFIED BY 'password';
EXIT;

If you picked a different database name, remember it, because you will need
to adjust the configuration file to match the name you picked. Let’s look at
that configuration file now.
The config/database.yml contains information on database connections. It contains
three sections, one each for the development, test, and production databases.
The current production section contains the following:

1.
2.

http://www.sqlite.org/whentouse.html
http://dev.mysql.com/downloads/mysql/

report erratum • discuss

Iteration K1: Deploying with Phusion Passenger and MySQL

•

235

production:
adapter: sqlite3
database: db/production.sqlite3
pool: 5
timeout: 5000

We replace that section with something like the following:
production:
adapter: mysql2
encoding: utf8
reconnect: false
database: depot_production
pool: 5
username: username
password: password
host: localhost

Change the username, password, and database fields as necessary.

Loading the Database
Next, we apply our migrations:
depot> rake db:setup RAILS_ENV="production"

One of two things will happen. If all is set up correctly, you will see output
like the following:
-- create_table("carts", {:force=>true})
-> 0.1722s
-- create_table("line_items", {:force=>true})
-> 0.1255s
-- create_table("orders", {:force=>true})
-> 0.1171s
-- create_table("products", {:force=>true})
-> 0.1172s
-- create_table("users", {:force=>true})
-> 0.1255s
-- initialize_schema_migrations_table()
-> 0.0006s
-- assume_migrated_upto_version(20110711000008, "db/migrate")
-> 0.0008s

If, instead, you see an error of some sort, don’t panic! It’s probably a simple
configuration issue. Here are some things to try:
• Check the name you gave for the database in the production: section of
database.yml. It should be the same as the name of the database you created
(using mysqladmin or some other database administration tool).

report erratum • discuss

236

•

Chapter 16. Task K: Deployment and Production

• Check that the username and password in database.yml match what you
used when you created the database on page 234.
• Check that your database server is running.
• Check that you can connect to it from the command line. If using MySQL,
run the following command:
depot> mysql depot_production
mysql>

• If you can connect from the command line, can you create a dummy table?
(This tests that the database user has sufficient access rights to the
database.)
mysql> create table dummy(i int);
mysql> drop table dummy;

• If you can create tables from the command line but rake db:migrate fails,
double-check the database.yml file. If there are socket: directives in the file,
try commenting them out by putting a hash character (#) in front of each.
• If you see an error saying No such file or directory… and the filename in the
error is mysql.sock, your Ruby MySQL libraries can’t find your MySQL
database. This might happen if you installed the libraries before you
installed the database or if you installed the libraries using a binary distribution and that distribution made the wrong assumption about the
location of the MySQL socket file. To fix this, the best idea is to reinstall
your Ruby MySQL libraries. If this isn’t an option, double-check that the
socket: line in your database.yml file contains the correct path to the MySQL
socket on your system.
• If you get the error Mysql not loaded, it means you’re running an old version
of the Ruby MySQL library. Rails needs at least version 2.5.
• Some readers also report getting the error message Client does not support authentication protocol requested by server; consider upgrading MySQL client. To resolve this
incompatibility between the installed version of MySQL and the libraries
used to access it, follow the instructions at http://dev.mysql.
com/doc/mysql/en/old-client.html and issue a MySQL command such
as set password for 'some_user'@'some_host' = OLD_PASSWORD('newpwd');.
• If you’re using MySQL under Cygwin on Windows, you may have problems
if you specify a host of localhost. Try using 127.0.0.1 instead.
• Finally, you might have problems in the format of the database.yml file. The
YAML library that reads this file is strangely sensitive to tab characters.

report erratum • discuss

Iteration K2: Deploying Remotely with Capistrano

•

237

If your file contains tab characters, you’ll have problems. (And you thought
you’d chosen Ruby over Python because you didn’t like Python’s significant
whitespace, eh?)
Rerun the rake db:setup as many times as you need to in order to correct any
configuration issues you may have.
If all this sounds scary, don’t worry. In reality, database connections work
like a charm most of the time. And once you have Rails talking to the database,
you don’t have to worry about it again.
At this point, you are up and running. Nothing looks any different when you
are running as a single user. The differences become apparent only when you
have a large number of concurrent users or a large database.
The next step is to split our development from our production machine.

16.2 Iteration K2: Deploying Remotely with Capistrano
If you are a large shop, having a pool of dedicated servers that you administer
so that you can ensure that they are running the same version of the necessary
software is the way to go. For more modest needs, a shared server will do,
but we will have to take additional care to deal with the fact that the versions
of software installed may not always match the version that we have installed
on our development machine.
Don’t worry, we’ll talk you through it.

Prepping Your Deployment Server
Although putting our software under version control is a really, really, really
good idea during development, not putting our software under version control
when it comes to deployment is downright foolhardy—enough so that the
software that we have selected to manage your deployment, namely, Capistrano, all but requires it.
Plenty of software configuration management (SCM) systems are available.
Subversion, for example, is a particularly good one. But if you haven’t yet
chosen one, go with Git, which is easy to set up and doesn’t require a separate
server process. The examples that follow will be based on Git, but if you
picked a different SCM system, don’t worry. Capistrano doesn’t much care
which one you pick, just so long as you pick one.
The first step is to create an empty repository on a machine accessible by
your deployment servers. In fact, if we have only one deployment server, there

report erratum • discuss

238

•

Chapter 16. Task K: Deployment and Production

is no reason that it can’t do double duty as your Git server. So, log onto that
server, and issue the following commands:
$ mkdir -p ~/git/depot.git
$ cd ~/git/depot.git
$ git --bare init

The next thing to be aware of is that even if the SCM server and our web
server are the same physical machine, Capistrano will be accessing our SCM
software as if it were remote. We can make this smoother by generating a
public key (if you don’t already have one) and then using it to give ourselves
permission to access our own server:
$ test -e ~/.ssh/id_dsa.pub || ssh-keygen -t dsa
$ cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys

Test this by ssh’ing into your own server. Among other things, this will ensure
that your known_hosts file is updated.
While we are here, we have one last thing to attend to. Capistrano will insert
a directory named current between our application directory name and the
Rails subdirectories, including the public subdirectory. This means you will
have to adjust your DocumentRoot in your httpd.conf if you control your own
server or in a control panel for your shared host:
DocumentRoot /home/rubys/work/depot/current/public/

That’s it for the server! From here on out, we will be doing everything from
your development machine.

Getting an Application Under Control
The first thing we are going to do is update our Gemfile to indicate that we are
using Capistrano.
Download rails32/depot_t/Gemfile
source 'https://rubygems.org'
gem 'rails', '3.2.0'
# Bundle edge Rails instead:
# gem 'rails', :git => 'git://github.com/rails/rails.git'
gem 'sqlite3'
group :production do
gem 'mysql2'
end

report erratum • discuss

Iteration K2: Deploying Remotely with Capistrano

•

239

# Gems used only for assets and not required
# in production environments by default.
group :assets do
gem 'sass-rails',
'~> 3.2.3'
gem 'coffee-rails', '~> 3.2.1'
# See https://github.com/sstephenson/execjs#readme for more supported runtimes
# gem 'therubyracer'
gem 'uglifier', '>= 1.0.3'
end
gem 'jquery-rails'
# To use ActiveModel has_secure_password
gem 'bcrypt-ruby', '~> 3.0.0'
# To use Jbuilder templates for JSON
# gem 'jbuilder'
# Use unicorn as the web server
# gem 'unicorn'
# Deploy with Capistrano
➤ gem 'capistrano'
# To use debugger
# gem 'ruby-debug19', :require => 'ruby-debug'
gem 'will_paginate', '~> 3.0'

We can now install Capistrano using bundle install. We used this command in
Iteration G3 on page 171 to install the will_paginate gem.
If you haven’t already put your application under configuration control, do
so now:
$
$
$
$

cd your_application_directory
git init
git add .
git commit -m "initial commit"

This next step is optional but might be a good idea if either you don’t have
full control of the deployment server or you have many deployment servers
to manage. We are going to use a second feature of Bundler, namely, the pack
command. What it does is put the version of the software that you are dependent on into the repository:
$ bundle pack
$ git add Gemfile.lock vendor/cache

report erratum • discuss

240

•

Chapter 16. Task K: Deployment and Production

$ git commit -m "bundle gems"

We will explain more of the features of Bundler in Section 25.3, Managing
Dependencies with Bundler, on page 423.
From here, it is a simple matter to push all your code out to the server:
$ git remote add origin ssh://user@host/~/git/depot.git
$ git push origin master

With these few steps, you have gained control over what is being deployed.
You control what is being committed to your local repository. You control
when this is being pushed out to your server. Next up, you will control putting
this code into production.

Deploying the Application Remotely
We previously deployed the application locally on a server. Now we are going
to do a second deployment, this time remotely.
The prep work is now done. Our code is now on the SCM server where it can
be accessed by the app server. Again, it matters not whether these two servers
are the same; what is important here is the roles that are being performed.
To add the necessary files to the project for Capistrano to do its magic, execute
the following command:
$ capify .
[add] writing './Capfile'
[add] writing './config/deploy.rb'
[done] capified!

From the output, we can see that Capistrano set up two files. The first, Capfile,
is Capistrano’s analog to a Rakefile. We won’t need to touch this file further.
The second, config/deploy.rb, contains the recipes needed to deploy our application. Capistrano will provide us with a minimal version of this file, but the
following is a somewhat more complete version that you can download and
use as a starting point:
Download rails32/depot_t/Capfile
load 'deploy' if respond_to?(:namespace) # cap2 differentiator
# Uncomment if you are using Rails' asset pipeline
➤ load 'deploy/assets'
Dir['vendor/gems/*/recipes/*.rb','vendor/plugins/*/recipes/*.rb'].
each { |plugin| load(plugin) }
load 'config/deploy' # remove this line to skip loading any of the default tasks

report erratum • discuss

Iteration K2: Deploying Remotely with Capistrano

•

241

Download rails32/depot_t/config/deploy.rb
# be sure to change these
set :user, 'rubys'
set :domain, 'depot.pragprog.com'
set :application, 'depot'
# adjust if you are using RVM, remove if you are not
$:.unshift(File.expand_path('./lib', ENV['rvm_path']))
require "rvm/capistrano"
set :rvm_ruby_string, '1.9.2'
set :rvm_type, :user
# file paths
set :repository, "#{user}@#{domain}:git/#{application}.git"
set :deploy_to, "/home/#{user}/#{domain}"
# distribute your applications across servers (the instructions below put them
# all on the same server, defined above as 'domain', adjust as necessary)
role :app, domain
role :web, domain
role :db, domain, :primary => true
# you might need to set this if you aren't seeing password prompts
# default_run_options[:pty] = true
#
#
#
#
#
#
#

As Capistrano executes in a non-interactive mode and therefore doesn't cause
any of your shell profile scripts to be run, the following might be needed
if (for example) you have locally installed gems or applications. Note:
this needs to contain the full values for the variables set, not simply
the deltas.
default_environment['PATH']='<your paths>:/usr/local/bin:/usr/bin:/bin'
default_environment['GEM_PATH']='<your paths>:/usr/lib/ruby/gems/1.8'

# miscellaneous options
set :deploy_via, :remote_cache
set :scm, 'git'
set :branch, 'master'
set :scm_verbose, true
set :use_sudo, false
set :rails_env, :production
namespace :deploy do
desc "cause Passenger to initiate a restart"
task :restart do
run "touch #{current_path}/tmp/restart.txt"
end
desc "reload the database with seed data"
task :seed do
run "cd #{current_path}; rake db:seed RAILS_ENV=#{rails_env}"

report erratum • discuss

242

•

Chapter 16. Task K: Deployment and Production

end
end
after "deploy:update_code", :bundle_install
desc "install the necessary prerequisites"
task :bundle_install, :roles => :app do
run "cd #{release_path} && bundle install"
end

We will need to edit several properties to match our application. We certainly
will need to change the :user, :domain, and :application. The :repository matches
where we put our Git file earlier. The :deploy_to may need to be tweaked to
match where we told Apache it could find the config/public directory for the
application.
We’ve also included a few lines to show how to instruct Capistrano to make
use of RVM.3 If RVM was installed as root on your deployment machine,
remove the set :rvm_type line. Adjust the :rvm_ruby_string to match the version of
the Ruby interpreter that you have installed and wish to use. If you are not
using RVM at all, remove these lines.
The default_run_options and default_environment are to be used only if you have specific problems. The “miscellaneous options” provided are based on Git.
Two tasks are defined. One tells Capistrano how to restart Passenger. The
other installs the gems from the copy that we previously placed on the Git
repository. Feel free to adjust these tasks as you see fit.
The first time we deploy our application, we have to perform an additional
step to set up the basic directory structure to deploy into on the server:
$ cap deploy:setup

When we execute this command, Capistrano will prompt us for our server’s
password. If it fails to do so and fails to log in, we might need to uncomment
out the default_run_options line in our deploy.rb file and try again. Once it can
connect successfully, it will make the necessary directories. After this command is done, we can check out the configuration for any other problems:
$ cap deploy:check

As before, we might need to uncomment out and adjust the default_environment
lines in our deploy.rb. We can repeat this command until it completes successfully, addressing any issues it may identify.

3.

http://beginrescueend.com/integration/capistrano/

report erratum • discuss

Iteration K3: Checking Up on a Deployed Application

•

243

Now we’re ready to do the deployment. Since we have done all of the necessary
prep work and checked the results, it should go smoothly:
$ cap deploy:migrations

At this point, we should be off to the races.

Rinse, Wash, Repeat
Once we’ve gotten this far, our server is ready to have new versions of our
application deployed to it any time we want. All we need to do is check our
changes into the repository and then redeploy. At this point, we have two
Capistrano files that haven’t been checked in. Although they aren’t needed
by the app server, we can still use them to test the deployment process:
$
$
$
$

git
git
git
cap

add .
commit -m "add cap files"
push
deploy

The first three commands will update the SCM server. Once you become more
familiar with Git, you may want to have finer control over when and which
files are added, you may want to incrementally commit multiple changes before
deployment, and so on. It is only the final command that will update our app,
web, and database servers.
If for some reason we need to step back in time and go back to a previous
version of our application, we can use this:
$ cap deploy:rollback

We now have a fully deployed application and can deploy as needed to update
the code running on the server. Each time we deploy our application, a new
version of it is checked out onto the server, some symlinks are updated, and
the Passenger processes are restarted.

16.3 Iteration K3: Checking Up on a Deployed Application
Once we have our application deployed, we’ll no doubt need to check up on
how it’s running from time to time. We can do this in two primary ways. The
first is to monitor the various log files output by both our front-end web
server and the Apache server running our application. The second is to connect
to our application using rails console.

Looking at Log Files
To get a quick look at what’s happening in our application, we can use the
tail command to examine log files as requests are made against our application.

report erratum • discuss

244

•

Chapter 16. Task K: Deployment and Production

The most interesting data will usually be in the log files from the application
itself. Even if Apache is running multiple applications, the logged output for
each application is placed in the production.log file for that application.
Assuming that our application is deployed into the location we showed earlier,
here’s how we look at our running log file:
# On your server
$ cd /home/rubys/work/depot/current
$ tail -f log/production.log

Sometimes, we need lower-level information—what’s going on with the data
in our application? When this is the case, it’s time to break out the most
useful live server debugging tool.

Using Console to Look at a Live Application
We’ve already created a large amount of functionality in our application’s
model classes. Of course, we created these to be used by our application’s
controllers. But we can also interact with them directly. The gateway to this
world is the rails console script. We can launch it on our server with this:
# On your server
$ cd /home/rubys/work/depot/
$ rails console production
Loading production environment.
irb(main):001:0> p = Product.find_by_title("CoffeeScript")
=> #<Product:0x24797b4 @attributes={. . .}
irb(main):002:0> p.price = 29.00
=> 29.0
irb(main):003:0> p.save
=> true

Once we have a console session open, we can poke and prod all the various
methods on our models. We can create, inspect, and delete records. In a way,
it’s like having a root console to your application.
Once you put an application into production, we need to take care of a few
chores to keep your application running smoothly. These chores aren’t automatically taken care of for us, but, luckily, we can automate them.

Dealing with Log Files
As an application runs, it will constantly add data to its log file. Eventually,
the log files can grow extremely large. To overcome this, most logging solutions
can roll over log files to create a progressive set of log files of increasing age.
This will break up our log files into manageable chunks that can be archived
or even deleted after a certain amount of time has passed.

report erratum • discuss

Iteration K3: Checking Up on a Deployed Application

•

245

The Logger class supports rollover. We need to specify how many (or how often)
log files we want and the size of each, using a line like one of the following in
the file config/environments/production.rb:
config.logger = Logger.new(config.paths['log'].first, 'daily')

Or perhaps this:
require 'active_support/core_ext/numeric/bytes'
config.logger = Logger.new(config.paths['log'].first, 10, 10.megabytes)

Note that in this case an explicit require of active_support is needed because
this statement is processed early in the initialization of your application—before the Active Support libraries have been included. In fact, one of
the configuration options that Rails provides is to not include Active Support
libraries at all:
config.active_support.bare = true

Alternately, we can direct our logs to the system logs for our machine:
config.logger = SyslogLogger.new

Find more options at http://rubyonrails.org/deploy.

Moving On to Launch and Beyond
Once we’ve set up our initial deployment, we’re ready to finish the development
of our application and launch it into production. We’ll likely set up additional
deployment servers, and the lessons we learn from our first deployment will
tell us a lot about how we should structure later deployments. For example,
we’ll likely find that Rails is one of the slower components of our system—more
of the request time will be spent in Rails than in waiting on the database or
filesystem. This indicates that the way to scale up is to add machines to split
up the Rails load across.
However, we might find that the bulk of the time a request takes is in the
database. If this is the case, we’ll want to look at how to optimize our database
activity. Maybe we’ll want to change how we access data. Or maybe we’ll need
to custom craft some SQL to replace the default Active Record behaviors.
One thing is for sure: every application will require a different set of tweaks
over its lifetime. The most important activity to do is to listen to it over time
and discover what needs to be done. Our job isn’t done when we launch our
application. It’s actually just starting.
While our job is just starting when we first deploy our application to production, we have completed our tour of the Depot application. After we recap

report erratum • discuss

246

•

Chapter 16. Task K: Deployment and Production

what we did in this chapter, let’s look back at what we have accomplished in
remarkably few lines of code.

What We Just Did
We covered a lot of ground in this chapter. We took our code that ran locally
on our development machine for a single user and placed it on a different
machine, running a different web server, accessing a different database, and
possibly even running a different operating system.
To accomplish this, we used a number of different products:
• We installed and configured Phusion Passenger and Apache httpd, a
production-quality web server.
• We installed and configured MySQL, a production-quality database server.
• We got our application’s dependencies under control using Bundler and
Git.
• We installed and configured Capistrano, which enables us to confidently
and repeatably deploy our application.

Playtime
Here’s some stuff to try on your own:
• If we have multiple developers collaborating on development, we might
feel uncomfortable putting the details of the configuration of our database
(potentially including passwords!) into our configuration management
system. To address this, copy the completed database.yml into the shared
directory, and write a task instructing Capistrano to copy this file into
your current directory each time you deploy.

report erratum • discuss

In this chapter, we’ll see
• reviewing Rails concepts: model, view, controller, configuration, testing, and deployment; and
• documenting what we have done.

CHAPTER 17

Depot Retrospective
Congratulations! By making it this far, you have obtained a solid understanding of the basics of every Rails application. There is much more to learn,
which we will pick back up again in Part III. For now, relax, and let’s recap
what we’ve seen in Part II.

17.1 Rails Concepts
In Chapter 3, The Architecture of Rails Applications, on page 29 we introduced
models, views, and controllers. Now let’s see how we applied each of these
concepts in the Depot application. Then let’s explore how we used configuration, testing, and deployment.

Model
Models are where all of the persistent data retained by your application is
managed. In developing the Depot application, we created five models: Cart,
LineItem, Order, Product, and User.
By default, all models have id, created_at, and updated_at attributes. To our
models, we added attributes of type string (examples: title, name), integer (quantity),
text (description, address), decimal (price), and foreign keys (product_id, cart_id). We even
created a virtual attribute that is never stored in the database, namely, a
password.
We created has_many and belongs_to relationships that we can use to navigate
between our model objects, such as from Carts to LineItems to Products.
We employed migrations to update the databases, not only to introduce new
schema information but also to modify existing data. We demonstrated that
they can be applied in a fully reversible manner.

report erratum • discuss

248

•

Chapter 17. Depot Retrospective

The models we created were not merely passive receptacles for our data. For
starters, they actively validate the data, preventing errors from propagating.
We created validations for presence, inclusion, numericality, range, uniqueness, format, and confirmation. (And length too, if you completed the
exercises). We created custom validations for ensuring that deleted products
are not referenced by any line item. We used an Active Record hook to ensure
that an administrator always remains and a transaction to roll back incomplete
updates on failure.
We also created logic to add a product to a cart, add all line items from a cart
to an order, encrypt and authenticate a password, and compute various totals.
Finally, we created a default sort order for products for display purposes.

View
Views control the way our application presents itself to the external world.
By default, Rails scaffolding provides edit, index, new, and show, as well as a
partial named form that is shared between edit and new. We modified a number
of these, as well as creating new partials for carts and line items.
In addition to the model backed resource views, we created entirely new views
for admin, sessions, and the store itself.
We updated an overall layout to establish a common look and feel for the
entire site. We linked in a stylesheet. We made use of templates to generate
JavaScript that takes advantage of Web 2.0 technologies to make our website
more interactive.
We made use of a helper to determine when to hide the cart from the main
view.
We localized the customer views for display both in English and in Spanish.
While we focused primarily on HTML views, we also created plain-text views
and Atom views. Not all of the views were designed for browsers: we created
views for email too, and those views were able to share partials for displaying
line items.

Controller
By the time we were done, we created eight controllers: one each for the five
models and the three additional ones in order to support the views for admin,
sessions, and the store itself.
These controllers interacted with the models in a number of ways: from
finding and fetching data and putting it into instance variables to updating

report erratum • discuss

Rails Concepts

•

249

models and saving data entered via forms. When done, we either redirected
to another action or rendered a view. We rendered views in HTML, JSON, and
Atom.
We created filters that were run before selected actions to authorize requests.
We placed logic common to a number of controllers into the common base
class for all controllers, namely, ApplicationController.
We managed sessions, keeping track of the logged-in user (for administrators)
and carts (for customers). We kept track of the current locale used for internationalization of our output. We captured errors, logged them, and informed
the user via notices. We paginated orders through the use of the will_paginate
plugin.
We also sent confirmation emails on receipt of an order.

Configuration
While conventions keep to a minimum the amount of configuration required
for a Rails application, we did do a bit of customization.
We modified our database configuration in order to use MySQL in production.
We defined routes for our resources, our admin and session controllers, and
the root of our website, namely, our storefront. We defined a who_bought member
of our products resource in order to access Atom feeds that contain this
information.
We created an initializer for i18n purposes and updated the locales information
for both English (en) and Spanish (es).
We created seed data for our database.
We created a Capistrano script for deployment, including the definition of a
few custom tasks.

Testing
We maintained and enhanced tests throughout.
We employed unit tests to validation methods. We also tested increasing the
quantity on a given line item.
Rails provided basic tests for all our scaffolded controllers, which we maintained as we made changes. We added tests along the way for things such as
Ajax and ensuring that a cart has items before we create an order.
We used fixtures to provide test data to fuel our tests.

report erratum • discuss

250

•

Chapter 17. Depot Retrospective

Finally, we created an integration test to test an end-to-end scenario involving
a user adding a product to a cart, entering an order, and receiving a confirmation email.

Deployment
We deployed our application to a production-quality web server (Apache httpd)
using a production-quality database server (MySQL). Along the way, we
installed and configured Phusion Passenger to run our application, Bundler
to track dependencies, and Git to configuration manage our code. Capistrano
was employed to orchestrate updating the deployed web server in production
from our development machine.
We made use of test and production environments to prevent our experimentation
during development from affecting production. Our development environment
made use of the lightweight SQLite database server and a lightweight web
server, most likely WEBrick. Our tests were run in a controlled environment
with test data provided by fixtures.

17.2 Documenting What We Have Done
To complete our retrospective, let’s take a look at the code from two new
perspectives.
Rails makes it easy to run Ruby’s RDoc1 utility on all the source files in an
application to create good-looking programmer documentation. But before
we generate that documentation, we should probably create a nice introductory page so that future generations of developers will know what our application does.
To do this, edit the file doc/README_FOR_APP, and enter anything you think might
be useful. This file will be processed using RDoc, so you have a fair amount
of formatting flexibility.
You can generate the documentation in HTML format using the rake command:
depot> rake doc:app

This generates documentation into the directory doc/app. See Figure 43, Our
application's internal documentation, on page 251.
Finally, we might be interested to see how much code we’ve written. There’s
a Rake task for that, too.

1.

http://rdoc.sourceforge.net/

report erratum • discuss

Documenting What We Have Done

•

251

Figure 43—Our application’s internal documentation

depot> rake stats
(in /Users/dave/Work/depot)
+----------------------+-------+-------+---------+---------+-----+-------+
| Name
| Lines |
LOC | Classes | Methods | M/C | LOC/M |
+----------------------+-------+-------+---------+---------+-----+-------+
| Controllers
|
636 |
409 |
9 |
45 |
5 |
7 |
| Helpers
|
24 |
24 |
0 |
1 |
0 |
22 |
| Models
|
192 |
101 |
5 |
12 |
2 |
6 |
| Libraries
|
0 |
0 |
0 |
0 |
0 |
0 |
| Integration tests
|
201 |
138 |
2 |
9 |
4 |
13 |
| Functional tests
|
424 |
285 |
9 |
0 |
0 |
0 |
| Unit tests
|
163 |
123 |
13 |
2 |
0 |
59 |
+----------------------+-------+-------+---------+---------+-----+-------+
| Total
| 1640 | 1080 |
38 |
69 |
1 |
13 |
+----------------------+-------+-------+---------+---------+-----+-------+
Code LOC: 534
Test LOC: 546
Code to Test Ratio: 1:1.0

If you think about it, you have accomplished a lot and with not all that much
code. Furthermore, much of that code was generated for you. This is the
magic of Rails.

report erratum • discuss

Part III

Rails in Depth

In this chapter, we’ll see
• the directory structure of a Rails application,
• naming conventions,
• generating documentation for Rails itself,
• adding Rake tasks, and
• configuration.

CHAPTER 18

Finding Your Way Around Rails
Having survived our Depot project, you are now prepared to dig deeper into
Rails. For the rest of the book, we’ll go through Rails topic by topic (which
pretty much means module by module). You have seen most of these modules
in action before. We will cover not only what each module does but also how
to extend or even replace the module and why you might want to do so.
The chapters in Part III cover all the major subsystems of Rails: Active Record,
Active Resource, Action Pack (including both Action Controller and Action
View), and Active Support. This is followed by an in-depth look at migrations.
Then we are going to delve into the interior of Rails and show how the components are put together, how they start up, and how they can be replaced.
Having shown how the parts of Rails can be put together, we’ll complete this
book with a survey of a number of popular replacement parts, many of which
can be used outside of Rails.
But first, we need to set the scene. This chapter covers all the high-level stuff
you need to know to understand the rest: directory structures, configuration,
and environments.

18.1 Where Things Go
Rails assumes a certain runtime directory layout and provides application
and scaffold generators, which will create this layout for you. For example, if
we generate my_app using the command rails new my_app, the top-level directory
for our new application appears as shown in Figure 44, All Rails applications
have this top-level directory structure., on page 257. Let’s start with the text
files in the top of the application directory:

report erratum • discuss

256

•

Chapter 18. Finding Your Way Around Rails

Joe asks:

So, Where’s Rails?
One of the interesting aspects of Rails is how componentized it is. From a developer’s
perspective, you spend all your time dealing with high-level modules such as Active
Record and Action View. There is a component called Rails, but it sits below the
other components, silently orchestrating what they do and making them all work
together seamlessly. Without the Rails component, not much would happen. But at
the same time, only a small part of this underlying infrastructure is relevant to developers in their day-to-day work. We’ll cover the parts that are relevant in the rest of
this chapter.

• config.ru configures the Rack Webserver Interface, either to create Rails
Metal applications or to use Rack Middlewares in your Rails application.
These are discussed further in the Rails Guides.1
• Gemfile specifies the dependencies of your Rails application. You have
already seen this in use when the will_paginate plugin was added to the
Depot application. Application dependencies also include the database,
web server, and even scripts used for deployment.
Technically, this file is not used by Rails itself but rather by your application. You can find calls to the Bundler2 in the config/application.rb and
config/boot.rb files.
• Gemfile.lock records the specific versions for each of your Rails application’s
dependencies. This file is maintained by Bundler, and should be checked
into your repository.
• Rakefile defines tasks to run tests, create documentation, extract the current
structure of your schema, and more. Type rake -T at a prompt for the full
list. Type rake -D task to see a more complete description of a specific task.
• README contains general information about the Rails framework itself.
Now let’s look at what goes into each directory (although not necessarily in
order).

A Place for Our Application
Most of our work takes place in the app directory. The main code for the application lives below the app directory, as shown in Figure 45, The main code for
1.
2.

http://guides.rubyonrails.org/rails_on_rack.html
https://github.com/carlhuda/bundler

report erratum • discuss

Where Things Go

•

257

my_app/
app/
Model, view, and controller files go here.
config/
Configuration and database connection parameters.
config.ru - Rack server configuration.
db/
Schema and migration information.
doc/
Autogenerated documentation.
Gemfile - Gem Dependencies.
lib/
Shared code.
log/
Log files produced by your application.
public/
Web-accessible directory. Your application runs from here.
Rakefile - Build script.
README - Installation and usage information.
script/
Utility scripts.
test/
Unit, functional, and integration tests, fixtures, and mocks.
tmp/
Runtime temporary files.
vendor/
Imported code.
Figure 44—All Rails applications have this top-level directory structure.

our application lives in the app directory., on page 258. We’ll talk more about
the structure of the app directory as we look at the various Rails modules such
as Active Record, Action Controller, and Action View in more detail later in
the book.

report erratum • discuss

258

•

Chapter 18. Finding Your Way Around Rails

app/
assets/
images/
rails.png
javascripts/
application.js
products.js.coffee
stylesheets/
application.css
products.css.scss
scaffolds.css.scss
controllers/
application_controller.rb
products_controller.rb
helpers/
application_helper.rb
products_helper.rb
mailers/
notifier.rb
models/
product.rb
views/
layouts/
application.html.erb
who_bought.atom.builder
products/
index.html.erb
line_items/
create.js.rjs
_line_item.html.erb
Figure 45—The main code for our application lives in the app directory.

report erratum • discuss

Where Things Go

•

259

A Place for our Tests
As we have seen in Section 7.2, Iteration B2: Unit Testing of Models, on page
82, Section 8.4, Iteration C4: Functional Testing of Controllers, on page 100,
and Section 13.2, Iteration H2: Integration Testing of Applications, on page 182,
Rails has ample provisions for testing your application, and the test directory
is the home for all testing-related activities, including fixtures that define
data used by our tests.

A Place for Documentation
As we saw in Section 17.2, Documenting What We Have Done, on page 250,
Rails provides the doc:app Rake task to generate documentation, which it places
in the doc/ directory. In addition to this command, Rails provides other tasks
that generate documentation: doc:rails will provide documentation for the version
of Rails you are running, and doc:guides will provide usage guides. Before you
build the guides, you will need to add the gem RedCloth (note: case is significant)
to your Gemfile and run bundle install.
Rails also provides other document-related tasks. To see them all, enter the
command rake -T doc.

A Place for Supporting Libraries
The lib directory holds application code that doesn’t fit neatly into a model,
view, or controller. For example, you may have written a library that creates
PDF receipts that your store’s customers can download.3 These receipts are
sent directly from the controller to the browser (using the send_data() method).
The code that creates these PDF receipts will sit naturally in the lib directory.
The lib directory is also a good place to put code that’s shared among models,
views, or controllers. Maybe you need a library that validates a credit card
number’s checksum, that performs some financial calculation, or that works
out the date of Easter. Anything that isn’t directly a model, view, or controller
should be slotted into lib.
Don’t feel that you have to stick a bunch of files directly into the lib directory.
Feel free to create subdirectories in which you group related functionality
under lib. For example, on the Pragmatic Programmer site, the code that
generates receipts, customs documentation for shipping, and other PDF-formatted documentation is in the directory lib/pdf_stuff.

3.

...which we did in the Pragmatic Programmer store.

report erratum • discuss

260

require
↪ on page 51

•

Chapter 18. Finding Your Way Around Rails

In previous versions of Rails, the files in the lib directory were automatically
included in the load path used to resolve require statements. This is now an
option that you need to explicitly enable. To do so, place the following in
config/application.rb:
config.autoload_paths += %W(#{Rails.root}/lib)

Once you have files in the lib directory and the lib added to your autoload
paths, you can use them in the rest of your application. If the files contain
classes or modules and the files are named using the lowercase form of the
class or module name, then Rails will load the file automatically. For example,
we might have a PDF receipt writer in the file receipt.rb in the directory lib/pdf_stuff.
As long as our class is named PdfStuff::Receipt, Rails will be able to find and load
it automatically.

↪ on page 51

For those times where a library cannot meet these automatic loading conditions, you can use Ruby’s require mechanism. If the file is in the lib directory,
you can require it directly by name. For example, if our Easter calculation
library is in the file lib/easter.rb, we can include it in any model, view, or controller using this:
require "easter"

If the library is in a subdirectory of lib, remember to include that directory’s
name in the require statement. For example, to include a shipping calculation
for airmail, we might add the following line:
require "shipping/airmail"

A Place for Our Rake Tasks
You’ll also find an empty tasks directory under lib. This is where you can write
your own Rake tasks, allowing you to add automation to your project. This
isn’t a book about Rake, so we won’t go into it deeply here, but here’s a simple
example. Rails provides a Rake task to tell you the latest migration that has
been performed.
But it may be helpful to see a list of all the migrations that have been performed. We’ll write a Rake task that prints out the versions listed in the
schema_migration table. These tasks are Ruby code, but they need to be placed
into files with the extension .rake. We’ll call ours db_schema_migrations.rake:
Download rails32/depot_t/lib/tasks/db_schema_migrations.rake
namespace :db do
desc "Prints the migrated versions"
task :schema_migrations => :environment do
puts ActiveRecord::Base.connection.select_values(

report erratum • discuss

Where Things Go

•

261

'select version from schema_migrations order by version' )
end
end

We can run this from the command line just like any other Rake task:
depot> rake db:schema_migrations
(in /Users/rubys/Work/...)
20110711000001
20110711000002
20110711000003
20110711000004
20110711000005
20110711000006
20110711000007

Consult the Rake documentation at http://rubyrake.org/ for more information
on writing Rake tasks.

A Place for Our Logs
As Rails runs, it produces a bunch of useful logging information. This is stored
(by default) in the log directory. Here you’ll find three main log files, called
development.log, test.log, and production.log. The logs contain more than just simple
trace lines; they also contain timing statistics, cache information, and expansions of the database statements executed.
Which file is used depends on the environment in which your application is
running (and we’ll have more to say about environments when we talk about
the config directory in A Place for Configuration, on page 263).

A Place for Static Web Pages
Thepublic directory is the external face of your application. The web server
takes this directory as the base of the application. In here you place static (in
other words, unchanging) files, such as stylesheets, JavaScript, and perhaps
even some web pages.

A Place for Scripts
If you find it helpful to write scripts that are run from the command line and
perform various maintenance tasks for your application, the script directory
is the place to put them.
This directory also holds the Rails script. This is the script that is run when
you run the rails command from the command line. The first argument you
pass to that script determines the function Rails will perform:

report erratum • discuss

262

•

Chapter 18. Finding Your Way Around Rails

benchmarker

Generates performance numbers on one or more methods in your
application.
console

Allows you to interact with your Rails application methods.
dbconsole

Allows you to directly interact with your database via the command line.
destroy

Removes autogenerated files created by generate.
generate

A code generator. Out of the box, it will create controllers, mailers, models,
scaffolds, and web services. You can also download additional generator
modules from the Rails website.4 Run generate with no arguments for usage
information on a particular generator, for example: railsgenerate migration.
new

Generates Rails application code.
plugin

Helps you install and administer plugins—pieces of functionality that
extend the capabilities of Rails.
profiler

Creates a runtime-profile summary of a URI request processed by your
application.
runner

Executes a method in your application outside the context of the Web.
This is the noninteractive equivalent of rails console. You could use this to
invoke cache expiry methods from a cron job or handle incoming email.
server

Runs your Rails application in a self-contained web server, using Mongrel
(if it is available on your box) or WEBrick. We’ve been using this in our
Depot application during development.

A Place for Temporary Files
It probably isn’t a surprise that Rails keeps its temporary files tucked in the
tmp directory. You’ll find subdirectories for cache contents, sessions, and
4.

http://wiki.rubyonrails.org/rails/pages/AvailableGenerators

report erratum • discuss

Where Things Go

•

263

sockets in here. Generally these files are cleaned up automatically by Rails,
but occasionally if things go wrong, you might need to look in here and delete
old files.

A Place for Third-Party Code
The vendor directory is where third-party code lives. Nowadays, this code will
typically come from two sources.
First, Rails installs plugins into the directories below vendor/plugins. Plugins are
ways of extending Rails functionality, both during development and at runtime.
Second, you can install Rails and all of its dependencies into the vendor directory, as we saw in Getting an Application Under Control, on page 238
If you want to go back to using the system-wide version of gems, you can
delete the vendor/cache directory.

A Place for Configuration
The config directory contains files that configure Rails. In the process of developing Depot, we configured a few routes, configured the database, created
an initializer, modified some locales, and defined deployment instructions.
The rest of the configuration was done via Rails conventions.
Before running your application, Rails loads and executes config/environment.rb
and config/application.rb. The standard environment that these files set up automatically includes the following directories (relative to your application’s base
directory) in your application’s load path:
•
•
•
•

The
The
The
The

app/controllers directory and its subdirectories
app/models directory
vendor directory and the lib contained in each plugin subdirectory

directories app, app/helpers, app/mailers, app/services, and lib

Each of these directories is added to the load path only if it exists.
In addition, Rails will load a per environment configuration file. This file lives
in the environments directory and is where you place configuration options that
vary depending on the environment.
This is done because Rails recognizes that your needs, as a developer, are
very different when writing code, testing code, and running that code in production. When writing code, you want lots of logging, convenient reloading
of changed source files, in-your-face notification of errors, and so on. In
testing, you want a system that exists in isolation so you can have repeatable

report erratum • discuss

264

•

Chapter 18. Finding Your Way Around Rails

results. In production, your system should be tuned for performance, and
users should be kept away from errors.
The switch that dictates the runtime environment is external to your application. This means that no application code needs to be changed as you move
from development through testing to production. In Chapter 16, Task K: Deployment and Production, on page 229, you specified the environment on the
rake command using a RAILS_ENV parameter and to Phusion Passenger using a
RailsEnv line in your Apache configuration file. When starting WEBrick with
the rails server command, you use the -e option:
depot> rails server -e development
depot> rails server -e test
depot> rails server -e production

If you have special requirements, for example, if you favor having a staging
environment, you can create your own environments. You’ll need to add a
new section to the database configuration file and a new file to the config/environments directory.
What you put into these configuration files is entirely up to you. You can find
a list of configuration parameters you can set in the Configuring Rails Applications guide you generated with the rake doc:guides command in A Place for
Documentation, on page 259. This information is also available online.5

18.2 Naming Conventions
Newcomers to Rails are sometimes puzzled by the way it automatically handles
the naming of things. They’re surprised that they call a model class Person and
Rails somehow knows to go looking for a database table called people. In this
section, you’ll learn how this implicit naming works.
The rules here are the default conventions used by Rails. You can override
all of these conventions using configuration options.

Mixed Case, Underscores, and Plurals
We often name variables and classes using short phrases. In Ruby, the convention is to have variable names where the letters are all lowercase and
words are separated by underscores. Classes and modules are named differently: there are no underscores, and each word in the phrase (including the
first) is capitalized. (We’ll call this mixed case, for fairly obvious reasons.)
These conventions lead to variable names such as order_status and class names
such as LineItem.
5.

http://guides.rubyonrails.org/configuring.html

report erratum • discuss

Naming Conventions

•

265

Rails takes this convention and extends it in two ways. First, it assumes that
database table names, such as variable names, have lowercase letters and
underscores between the words. Rails also assumes that table names are
always plural. This leads to table names such as orders and third_parties.
On another axis, Rails assumes that files are named using lowercase with
underscores.
Rails uses this knowledge of naming conventions to convert names automatically. For example, your application might contain a model class that handles
line items. You’d define the class using the Ruby naming convention, calling
it LineItem. From this name, Rails would automatically deduce the following:
• That the corresponding database table will be called line_items. That’s the
class name, converted to lowercase, with underscores between the words
and pluralized.
• Rails would also know to look for the class definition in a file called
line_item.rb (in the app/models directory).
Rails controllers have additional naming conventions. If our application has
a store controller, then the following happens:
• Rails assumes the class is called StoreController and that it’s in a file named
store_controller.rb in the app/controllers directory.
• It also assumes there’s a helper module named StoreHelper in the file
store_helper.rb located in the app/helpers directory.
• It will look for view templates for this controller in the app/views/store
directory.
• It will by default take the output of these views and wrap them in the
layout template contained in the file store.html.erb or store.xml.erb in the directory app/views/layouts.
All these conventions are shown in Figure 46, How naming conventions work
across a Rails application, on page 266.
There’s one extra twist. In normal Ruby code you have to use the require keyword to include Ruby source files before you reference the classes and modules
in those files. Because Rails knows the relationship between filenames and
class names, require is normally not necessary in a Rails application. The first
time you reference a class or module that isn’t known, Rails uses the naming
conventions to convert the class name to a filename and tries to load that file
behind the scenes. The net effect is that you can typically reference (say) the

report erratum • discuss

266

•

Chapter 18. Finding Your Way Around Rails

Figure 46—How naming conventions work across a Rails application

name of a model class, and that model will be automatically loaded into your
application.

Grouping Controllers into Modules
So far, all our controllers have lived in the app/controllers directory. It is sometimes convenient to add more structure to this arrangement. For example,
our store might end up with a number of controllers performing related but
disjoint administration functions. Rather than pollute the top-level namespace,
we might choose to group them into a single admin namespace.
Rails does this using a simple naming convention. If an incoming request has
a controller named (say) admin/book, Rails will look for the controller called
book_controller in the directory app/controllers/admin. That is, the final part of the
controller name will always resolve to a file called name_controller.rb, and any
leading path information will be used to navigate through subdirectories,
starting in the app/controllers directory.

report erratum • discuss

Naming Conventions

•

267

David says:

Why Plurals for Tables?
Because it sounds good in conversation. Really. “Select a Product from products.”
And “Order has_many :line_items.”
The intent is to bridge programming and conversation by creating a domain language
that can be shared by both. Having such a language means cutting down on the
mental translation that otherwise confuses the discussion of a product description
with the client when it’s really implemented as merchandise body. These communications gaps are bound to lead to errors.
Rails sweetens the deal by giving you most of the configuration for free if you follow
the standard conventions. Developers are thus rewarded for doing the right thing, so
it’s less about giving up “your ways” and more about getting productivity for free.

Imagine that our program has two such groups of controllers (say, admin/xxx
and content/xxx) and that both groups define a book controller. There’d be a
file called book_controller.rb in both the admin and content subdirectories of
app/controllers. Both of these controller files would define a class named BookController. If Rails took no further steps, these two classes would clash.
To deal with this, Rails assumes that controllers in subdirectories of the
directory app/controllers are in Ruby modules named after the subdirectory.
Thus, the book controller in the admin subdirectory would be declared like
this:
class Admin::BookController < ActionController::Base
# ...
end

The book controller in the content subdirectory would be in the Content module:
class Content::BookController < ActionController::Base
# ...
end

The two controllers are therefore kept separate inside your application.
The templates for these controllers appear in subdirectories of app/views. Thus,
the view template corresponding to this request:
http://my.app/admin/book/edit/1234

will be in this file:
app/views/admin/book/edit.html.erb

report erratum • discuss

268

•

Chapter 18. Finding Your Way Around Rails

You’ll be pleased to know that the controller generator understands the concept of controllers in modules and lets you create them with commands such
as this:
myapp> rails generate controller Admin::Book action1 action2 ...

What We Just Did
Everything in Rails has a place, and we systematically explored each of those
nooks and crannies. In each place, files and the data contained in them follow
naming conventions, and we covered that too. Along the way, we filled in a
few missing pieces:
• We generated both API and user guide documentation for Rails itself.
• We added a Rake task to print the migrated versions.
• We showed how to configure each of the Rails execution environments.
Next up is the major subsystems of Rails, starting with the largest, Active
Record.

report erratum • discuss

In this chapter, we’ll see
• the establish_connection method;
• tables, classes, columns, and attributes;
• ids and relationships;
• create, read, update and delete operations; and
• callbacks and transactions.

CHAPTER 19

Active Record
Active Record is the object-relational mapping (ORM) layer supplied with Rails.
It is the part of Rails that implements your application’s model.
In this chapter, we’ll build on the mapping data to rows and columns that
we did in Depot. Then we’ll look at using Active Record to manage table relationships and in the process cover create, read, update, and delete operations
(commonly referred to in the industry as CRUD methods). Finally, we will dig
into the Active Record object life cycle (including callbacks and transactions).

19.1 Defining Your Data
In Depot, we defined a number of models, including one for an Order. This
particular model has a number of attributes, such as an email address of type
String. In addition to the attributes that we defined, Rails provided an attribute
named id that contains the primary key for the record. Rails also provides
several additional attributes, including attributes that track when each row
was last updated. Finally, Rails supports relationships between models, such
as the relationship between orders and line items.
When you think about it, Rails provides a lot of support for models. Let’s
examine each in turn.

Organizing Using Tables and Columns
Each subclass of ActiveRecord::Base, such as our Order class, wraps a separate
database table. By default, Active Record assumes that the name of the table
associated with a given class is the plural form of the name of that class. If
the class name contains multiple capitalized words, the table name is assumed
to have underscores between these words.

report erratum • discuss

270

•

Chapter 19. Active Record

Class Name

Table Name

Class Name

Table Name

Order

orders

LineItem

line_items

TaxAgency

tax_agencies

Person

people

Batch

batches

Datum

data

Diagnosis

diagnoses

Quantity

quantities

These rules reflect DHH’s philosophy that class names should be singular
while the names of tables should be plural.
Although Rails handles most irregular plurals correctly, occasionally you may
stumble across one that is not handled correctly. If you encounter such a
case, you can add to Rails’ understanding of the idiosyncrasies and inconsistencies of the English language by modifying the inflection file provided:
Download rails32/depot_t/config/initializers/inflections.rb
# Be sure to restart your server when you modify this file.
#
#
#
#
#
#
#
#
#
#
#
#
#

Add new inflection rules using the following format
(all these examples are active by default):
ActiveSupport::Inflector.inflections do |inflect|
inflect.plural /^(ox)$/i, '\1en'
inflect.singular /^(ox)en/i, '\1'
inflect.irregular 'person', 'people'
inflect.uncountable %w( fish sheep )
end
These inflection rules are supported but not enabled by default:
ActiveSupport::Inflector.inflections do |inflect|
inflect.acronym 'RESTful'
end

ActiveSupport::Inflector.inflections do |inflect|
inflect.irregular 'tax', 'taxes'
end

If you have legacy tables you have to deal with or don’t like this behavior, you
can control the table name associated with a given model by setting the
table_name for a given class:
class Sheep < ActiveRecord::Base
self.table_name = "sheep"
end

Instances of Active Record classes correspond to rows in a database table.
These objects have attributes corresponding to the columns in the table. You
probably noticed that our definition of class Order didn’t mention any of the
columns in the orders table. That’s because Active Record determines them

report erratum • discuss

Defining Your Data

•

271

dynamically at runtime. Active Record reflects on the schema inside the
database to configure the classes that wrap tables.
In the Depot application, our orders table is defined by the following migration:
Download rails32/depot_r/db/migrate/20110711000007_create_orders.rb
class CreateOrders < ActiveRecord::Migration
def change
create_table :orders do |t|
t.string :name
t.text :address
t.string :email
t.string :pay_type
t.timestamps
end
end
end

Let’s use the handy-dandy rails console command to play with this model. First,
we’ll ask for a list of column names:
depot> rails console
Loading development environment (Rails 3.2.0)
>> Order.column_names
=> ["id", "name", "address", "email", "pay_type", "created_at", "updated_at"]

Then we’ll ask for the details of the pay_type column:
>> Order.columns_hash["pay_type"]
=> #<ActiveRecord::ConnectionAdapters::SQLiteColumn:0x7fe673f7da80
@name="pay_type", @null=true, @default=nil, @sql_type="varchar(10)",
@type=:string, @scale=nil, @precision=nil, @primary=false,
@limit=10>

Notice that Active Record has gleaned a fair amount of information about the
pay_type column. It knows that it’s a string of at most ten characters, it has
no default value, it isn’t the primary key, and it may contain a null value.
Rails obtained this information by asking the underlying database the first
time we tried to use the Order class.
The attributes of an Active Record instance generally correspond to the data
in the corresponding row of the database table. For example, our orders table
might contain the following data:
depot> sqlite3 -line db/development.sqlite3 "select * from orders limit 1"
id = 1
name = Dave Thomas
address = 123 Main St
email = customer@example.com

report erratum • discuss

272

•

Chapter 19. Active Record

David says:

Where Are Our Attributes?
The notion of a database administrator (DBA) as a separate role from programmer
has led some developers to see strict boundaries between code and schema. Active
Record blurs that distinction, and no other place is that more apparent than in the
lack of explicit attribute definitions in the model.
But fear not. Practice has shown that it makes little difference whether we’re looking
at a database schema, a separate XML mapping file, or inline attributes in the model.
The composite view is similar to the separations already happening in the ModelView-Control pattern—just on a smaller scale.
Once the discomfort of treating the table schema as part of the model definition has
dissipated, you’ll start to realize the benefits of keeping DRY. When you need to add
an attribute to the model, you simply have to create a new migration and reload the
application.
Taking the “build” step out of schema evolution makes it just as agile as the rest of
the code. It becomes much easier to start with a small schema and extend and change
it as needed.

pay_type = Check
created_at = 2010-06-18 00:36:57.355069
updated_at = 2010-06-18 00:36:57.355069

If we fetched this row into an Active Record object, that object would have
seven attributes. The id attribute would be 1 (a Fixnum), the name attribute would
be the string "Dave Thomas", and so on.
We access these attributes using accessor methods. Rails automatically
constructs both attribute readers and attribute writers when it reflects on
the schema:
o = Order.find(1)
puts o.name
o.name = "Fred Smith"

#=> "Dave Thomas"
# set the name

Setting the value of an attribute does not change anything in the database—we
must save the object for this change to become permanent.
The value returned by the attribute readers is cast by Active Record to an
appropriate Ruby type if possible (so, for example, if the database column is
a timestamp, a Time object will be returned). If we want to get the raw value
of an attribute, we append _before_type_cast to its name, as shown in the following
code:
product.price_before_type_cast

#=> "29.95", a string

report erratum • discuss

Defining Your Data

•

273

product.updated_at_before_type_cast #=> "2008-05-13 10:13:14"

Inside the code of the model, we can use the read_attribute() and write_attribute()
private methods. These take the attribute name as a string parameter.
We can see the mapping between SQL types and their Ruby representation
in Figure 47, Mapping SQL types to Ruby types, on page 274. Decimal and
Boolean columns are slightly tricky.
Rails maps columns with Decimals with no decimal places to Fixnum objects;
otherwise, it maps them to BigDecimal objects, ensuring that no precision is
lost.
In the case of Boolean, a convenience method is provided with a question
mark appended to the column name:
user = User.find_by_name("Dave")
if user.superuser?
grant_privileges
end

In addition to the attributes we define, there are a number of attributes that
Rails either provides automatically or have special meaning.

Additional Columns Provided by Active Record
A number of column names have special significance to Active Record. Here’s
a summary:
created_at, created_on, updated_at, updated_on

This is automatically updated with the timestamp of a row’s creation or
last update. Make sure the underlying database column is capable of
receiving a date, datetime, or string. Rails applications conventionally use
the _on suffix for date columns and the _at suffix for columns that include
a time.
lock_version

Rails will track row version numbers and perform optimistic locking if a
table contains lock_version.
type

Active Record can be subclassed. When you do so, all of the attributes
for all of the subclasses are kept in the same table. The type attribute is
used to name the column that will be used to track the type of a row.

report erratum • discuss

274

•

Chapter 19. Active Record

SQL Type

Ruby Class

SQL Type

Ruby Class

int, integer

Fixnum

float, double

Float

decimal, numeric

BigDecimal¹

char, varchar, string

String

interval, date

Date

datetime, time

Time

clob, blob, text

String

boolean

see text

¹ Decimal and numeric columns are mapped to integers when their scale is 0

Figure 47—Mapping SQL types to Ruby types

id

This is the default name of a table’s primary key column (in Identifying
Individual Rows, on page 274).
xxx_id

This is the default name of a foreign key reference to a table named with
the plural form of xxx.
xxx_count

This maintains a counter cache for the child table xxx.
Additional plugins, such as acts_as_list,1 may define additional columns.
Both primary keys and foreign keys play a vital role in database operations
and merit additional discussion.

19.2 Locating and Traversing Records
In the Depot application, LineItems have direct relationships to three other
models: Cart, Order, and Product. Additionally, models can have indirect relationships mediated by resource objects. The relationship between Orders and
Products through LineItems is an example of such a relationship.
All of this is made possible through ids.

Identifying Individual Rows
Active Record classes correspond to tables in a database. Instances of a class
correspond to the individual rows in a database table. Calling Order.find(1), for
instance, returns an instance of an Order class containing the data in the row
with the primary key of 1.

1.

https://github.com/rails/acts_as_list

report erratum • discuss

Locating and Traversing Records

•

275

If you’re creating a new schema for a Rails application, you’ll probably want
to go with the flow and let it add the id primary key column to all your tables.
However, if you need to work with an existing schema, Active Record gives
you a simple way of overriding the default name of the primary key for a table.
For example, we may be working with an existing legacy schema that uses
the ISBN as the primary key for the books table.
We specify this in our Active Record model using something like the following:
class LegacyBook < ActiveRecord::Base
self.primary_key = "isbn"
end

Normally, Active Record takes care of creating new primary key values for
records that we create and add to the database—they’ll be ascending integers
(possibly with some gaps in the sequence). However, if we override the primary
key column’s name, we also take on the responsibility of setting the primary
key to a unique value before we save a new row. Perhaps surprisingly, we still
set an attribute called id to do this. As far as Active Record is concerned, the
primary key attribute is always set using an attribute called id. The primary_key=
declaration sets the name of the column to use in the table. In the following
code, we use an attribute called id even though the primary key in the database
is isbn:
book = LegacyBook.new
book.id = "0-12345-6789"
book.title = "My Great American Novel"
book.save
# ...
book = LegacyBook.find("0-12345-6789")
puts book.title
# => "My Great American Novel"
p book.attributes #=> {"isbn" =>"0-12345-6789",
#
"title"=>"My Great American Novel"}

Just to make life more confusing, the attributes of the model object have the
column names isbn and title—id doesn’t appear. When you need to set the primary key, use id. At all other times, use the actual column name.
Model objects also redefine the Ruby id() and hash() methods to reference the
model’s primary key. This means that model objects with valid ids may be
used as hash keys. It also means that unsaved model objects cannot reliably
be used as hash keys (because they won’t yet have a valid id).
One final note: Rails considers two model objects as equal (using ==) if they
are instances of the same class and have the same primary key. This means
that unsaved model objects may compare as equal even if they have different

report erratum • discuss

276

•

Chapter 19. Active Record

attribute data. If you find yourself comparing unsaved model objects (which
is not a particularly frequent operation), you might need to override the ==
method.
As we will see, ids also play an important role in relationships.

Specifying Relationships in Models
Active Record supports three types of relationship between tables: one-to-one,
one-to-many, and many-to-many. You indicate these relationships by adding
declarations to your models: has_one, has_many, belongs_to, and the wonderfully
named has_and_belongs_to_many.

One-to-One Relationships
A one-to-one association (or, more accurately, a one-to-zero-or-one relationship) is implemented using a foreign key in one row in one table to reference
at most a single row in another table. A one-to-one relationship might exist
between orders and invoices: for each order there’s at most one invoice.
invoices

orders

id

id

order_id

name

...

...

class Invoice < ActiveRecord::Base
belongs_to :order
#...
end

class Order < ActiveRecord::Base
has_one :invoice
#...
end

As the example shows, we declare this in Rails by adding a has_one declaration
to the Order model and by adding a belongs_to declaration to the Invoice model.
There’s an important rule illustrated here: the model for the table that contains
the foreign key always has the belongs_to declaration.

One-to-Many Relationships
A one-to-many association allows you to represent a collection of objects. For
example, an order might have any number of associated line items. In the
database, all the line item rows for a particular order contain a foreign key
column referring to that order.

report erratum • discuss

Locating and Traversing Records

line_items

•

277

orders

id

id

order_id

name

...

...
class Order < ActiveRecord::Base
has_many :line_items
#...
end

class LineItem < ActiveRecord::Base
belongs_to :order
#...
end

In Active Record, the parent object (the one that logically contains a collection
of child objects) uses has_many to declare its relationship to the child table,
and the child table uses belongs_to to indicate its parent. In our example, class
LineItem belongs_to :order, and the orders table has_many :line_items.
Note that again, because the line item contains the foreign key, it has the
belongs_to declaration.

Many-to-Many Relationships
Finally, we might categorize our products. A product can belong to many
categories, and each category may contain multiple products. This is an
example of a many-to-many relationship. It’s as if each side of the relationship
contains a collection of items on the other side.
categories

categories_products

products

id

category_id

id

name

product_id

name

...
class Category< ActiveRecord::Base
has_and_belongs_to_many :products
#...
end

...
class Product< ActiveRecord::Base
has_and_belongs_to_many :categories
#...
end

In Rails we can express this by adding the has_and_belongs_to_many declaration
to both models.
Many-to-many associations are symmetrical—both of the joined tables declare
their association with each other using “habtm.”
Rails implements many-to-many associations using an intermediate join table.
This contains foreign key pairs linking the two target tables. Active Record
assumes that this join table’s name is the concatenation of the two target
table names in alphabetical order. In our example, we joined the table categories
to the table products, so Active Record will look for a join table named categories_products.

report erratum • discuss

278

•

Chapter 19. Active Record

We can also define join tables directly. In the Depot application, we defined
a LineItems join, which joined Products to either Carts or Orders. Defining it ourselves
also gave us a place to store an additional attribute, namely, a quantity.
Now that we have covered data definitions, the next thing you would naturally
want to do is access the data contained within the database, so let’s do that.

19.3 Creating, Reading, Updating, and Deleting (CRUD)
Names such as SQLite and MySQL emphasize that all access to a database
is via the Structured Query Language (SQL). In most cases, Rails will take
care of this for you, but that is completely up to you. As you will see, you can
provide clauses or even entire SQL statements for the database to execute.
If you are familiar with SQL already, as you read this section take note of how
Rails provides places for familiar clauses such as select, from, where, group by,
and so on. If you are not already familiar with SQL, one of the strengths of
Rails is that you can defer knowing more about such things until you actually
need to access the database at this level.
In this section, we’ll continue to work with the Order model from the Depot
application for an example. We will be using Active Record methods to apply
the four basic database operations: create, read, update, and delete.

Creating New Rows
Given that Rails represents tables as classes and rows as objects, it follows
that we create rows in a table by creating new objects of the appropriate class.
We can create new objects representing rows in our orders table by calling
Order.new(). We can then fill in the values of the attributes (corresponding to
columns in the database). Finally, we call the object’s save() method to store
the order back into the database. Without this call, the order would exist
only in our local memory.
Download rails32/e1/ar/new_examples.rb
an_order = Order.new
an_order.name
= "Dave Thomas"
an_order.email
= "dave@example.com"
an_order.address = "123 Main St"
an_order.pay_type = "check"
an_order.save

Active Record constructors take an optional block. If present, the block is
invoked with the newly created order as a parameter. This might be useful if
you wanted to create and save away an order without creating a new local
variable.

report erratum • discuss

Creating, Reading, Updating, and Deleting (CRUD)

•

279

Download rails32/e1/ar/new_examples.rb
Order.new do |o|
o.name
= "Dave Thomas"
# . . .
o.save
end

Finally, Active Record constructors accept a hash of attribute values as an
optional parameter. Each entry in this hash corresponds to the name and
value of an attribute to be set. This is useful for doing things like storing
values from HTML forms into database rows.
Download rails32/e1/ar/new_examples.rb
an_order = Order.new(
name:
"Dave Thomas",
email:
"dave@example.com",
address: "123 Main St",
pay_type: "check")
an_order.save

Note that in all of these examples we did not set the id attribute of the new
row. Because we used the Active Record default of an integer column for the
primary key, Active Record automatically creates a unique value and sets the
id attribute as the row is saved. We can subsequently find this value by
querying the attribute.
Download rails32/e1/ar/new_examples.rb
an_order = Order.new
an_order.name = "Dave Thomas"
# ...
an_order.save
puts "The ID of this order is #{an_order.id}"

The new() constructor creates a new Order object in memory; we have to remember to save it to the database at some point. Active Record has a convenience
method, create(), that both instantiates the model object and stores it into the
database.
Download rails32/e1/ar/new_examples.rb
an_order = Order.create(
name:
"Dave Thomas",
email:
"dave@example.com",
address: "123 Main St",
pay_type: "check")

You can pass create() an array of attribute hashes; it’ll create multiple rows in
the database and return an array of the corresponding model objects:
Download rails32/e1/ar/new_examples.rb
orders = Order.create(

report erratum • discuss

280

•

Chapter 19. Active Record

[ { name:
email:
address:
pay_type:
},

"Dave Thomas",
"dave@example.com",
"123 Main St",
"check"

{ name:
email:
address:
pay_type:
} ] )

"Andy Hunt",
"andy@example.com",
"456 Gentle Drive",
"po"

The real reason that new() and create() take a hash of values is that you can
construct model objects directly from form parameters:
@order = Order.new(params[:order])

If you think this line looks familiar, it is because you have seen it before. It
appears in orders_controller.rb in the Depot application.

Reading Existing Rows
Reading from a database involves first specifying which particular rows of
data you are interested in—you’ll give Active Record some kind of criteria,
and it will return objects containing data from the row(s) matching the criteria.
The simplest way of finding a row in a table is by specifying its primary key.
Every model class supports the find() method, which takes one or more primary
key values. If given just one primary key, it returns an object containing data
for the corresponding row (or throws a ActiveRecord::RecordNotFound exception). If
given multiple primary key values, find() returns an array of the corresponding
objects. Note that in this case a RecordNotFound exception is raised if any of the
ids cannot be found (so if the method returns without raising an error, the
length of the resulting array will be equal to the number of ids passed as
parameters):
an_order = Order.find(27)

# find the order with id == 27

# Get a list of product ids from a form, then
# sum the total price
product_list = params[:product_ids]
total = Product.find(product_list).sum(&:price)

Often, though, you need to read in rows based on criteria other than their
primary key value. Active Record provides a range of options for performing
these queries. We’ll start by looking at an alternate way to express simple
where clauses and then look at additional ways to modify the queries Rails
generates for you.

report erratum • discuss

Creating, Reading, Updating, and Deleting (CRUD)

•

281

David says:

To Raise, or Not to Raise?
When you use a finder driven by primary keys, you’re looking for a particular record.
You expect it to exist. A call to Person.find(5) is based on our knowledge of the people table.
We want the row with an id of 5. If this call is unsuccessful—if the record with the
id of 5 has been destroyed—we’re in an exceptional situation. This mandates the
raising of an exception, so Rails raises RecordNotFound.
On the other hand, finders that use criteria to search are looking for a match. So,
Person.where(name: 'Dave').first is the equivalent of telling the database (as a black box)
“Give me the first person row that has the name Dave.” This exhibits a distinctly different approach to retrieval; we’re not certain up front that we’ll get a result. It’s
entirely possible the result set may be empty. Thus, returning nil in the case of finders
that search for one row and an empty array for finders that search for many rows is
the natural, nonexceptional response.

Dynamic Finders
Probably the most common search performed on databases is to return the
row or rows where a column matches a given value. A query might be return
all the orders for Dave or get all the blog postings with a subject of “Rails Rocks.”
In many other languages and frameworks, you’d construct SQL queries to
perform these searches. Active Record uses Ruby’s dynamic power to do this
for you.
For example, our Order model has attributes such as name, email, and address.
We can use these names in finder methods to return rows where the corresponding columns match some value:
Download rails32/e1/ar/find_examples.rb
order = Order.find_by_name("Dave Thomas")
orders = Order.find_all_by_name("Dave Thomas")
orders = Order.find_all_by_email(params['email'])

If you invoke a model’s class method where the method name starts find_by_(),
find_last_by_(), or find_all_by_(), Active Record converts it to a finder, using the rest
of the method’s name to determine the column to be checked. Thus, the call
to this:
order = Order.find_by_name("Dave Thomas")

is (effectively) converted by Active Record into this:
order = Order.where(name: "Dave Thomas").first

report erratum • discuss

282

•

Chapter 19. Active Record

Similarly, calls to find_all_by_xxx and to find_last_by_xxx substitute calls to all()
and last(), respectively, for the implicit call to first().
Appending a bang (!) character to the find_by_ call will cause a ActiveRecord::
RecordNotFound exception to be raised instead of returning nil if it can’t find a
matching record:
order = Order.find_by_name!("Dave Thomas")

The magic doesn’t stop there. Active Record will also create finders that search
on multiple columns. For example, you could write this:
user = User.find_by_name_and_password(name, pw)

This is equivalent to the following:
user = User.where(name: name, password: pw).first

To determine the names of the columns to check, Active Record simply splits
the name that follows the find_by_ or find_all_by_ around the string _and_. This is
good enough most of the time but breaks down if you ever have a column
name such as tax_and_shipping. In these cases, you’ll have to use other methods
to construct the where clause.
There are times when you want to ensure you always have a model object to
work with. If there isn’t one in the database, you want to create one. Dynamic
finders can handle this. Calling a method whose name starts find_or_initialize_by_()
or find_or_create_by_() will call either new() or create() on the model class if the
finder would otherwise return nil. The new model object will be initialized so
that its attributes corresponding to the finder criteria have the values passed
to the finder method, and it will have been saved to the database if the create
variant is used.
cart = Cart.find_or_initialize_by_user_id(user.id)
cart.items << new_item
cart.save

And, no, there isn’t a find_by_ form that lets you use _or_ rather than _and_
between column names.

SQL and Active Record
To illustrate how Active Record works with SQL, let’s pass a simple string to
the where() method call corresponding to a SQL where clause. For example, to
return a list of all orders for Dave with a payment type of “po,” we could use
this:
pos = Order.where("name = 'Dave' and pay_type = 'po'")

report erratum • discuss

Creating, Reading, Updating, and Deleting (CRUD)

•

283

The result will be an ActiveRecord::Relation object containing all the matching
rows, each neatly wrapped in an Order object.
That’s fine if our condition is predefined, but how do we handle it when the
name of the customer is set externally (perhaps coming from a web form)?
One way is to substitute the value of that variable into the condition string:
# get the name from the form
name = params[:name]
# DON'T DO THIS!!!
pos = Order.where("name = '#{name}' and pay_type = 'po'")

As the comment suggests, this really isn’t a good idea. Why? It leaves the
database wide open to something called a SQL injection attack, which we
describe in more detail in the Rails Guides that you generated in A Place for
Documentation, on page 259. For now, take it as a given that substituting a
string from an external source into a SQL statement is effectively the same
as publishing your entire database to the whole online world.
Instead, the safe way to generate dynamic SQL is to let Active Record handle
it. Doing this allows Active Record to create properly escaped SQL, which is
immune from SQL injection attacks. Let’s see how this works.
If we pass multiple parameters to a where() call, Rails treats the first parameter
as a template for the SQL to generate. Within this SQL, we can embed
placeholders, which will be replaced at runtime by the values in the rest of
the array.
One way of specifying placeholders is to insert one or more question marks
in the SQL. The first question mark is replaced by the second element of the
array, the next question mark by the third, and so on. For example, we could
rewrite the previous query as this:
name = params[:name]
pos = Order.where(["name = ? and pay_type = 'po'", name])

We can also use named placeholders. We do that by placing placeholders of
the form :name into the string and by providing corresponding values in a
hash, where the keys correspond to the names in the query:
name
= params[:name]
pay_type = params[:pay_type]
pos = Order.where("name = :name and pay_type = :pay_type",
pay_type: pay_type, name: name)

report erratum • discuss

284

•

Chapter 19. Active Record

We can take this a step further. Because params is effectively a hash, we can
simply pass it all to the condition. If we have a form that can be used to enter
search criteria, we can use the hash of values returned from that form directly:
pos = Order.where("name = :name and pay_type = :pay_type",
params[:order])

We can take this even further. If we pass just a hash as the condition, Rails
generates a where clause using the hash keys as column names and the hash
values as the values to match. Thus, we could have written the previous code
even more succinctly:
pos = Order.where(params[:order])

Be careful with this latter form of condition: it takes all the key/value pairs
in the hash you pass in when constructing the condition. An alternative would
be to specify which parameters to use explicitly:
pos = Order.where(name: params[:name],
pay_type: params[:pay_type])

Regardless of which form of placeholder you use, Active Record takes great
care to quote and escape the values being substituted into the SQL. Use these
forms of dynamic SQL, and Active Record will keep you safe from injection
attacks.

Using Like Clauses
We might be tempted to do something like the code on the next page to use
parameterized like clauses in conditions.
# Doesn't work
User.where("name like '?%'", params[:name])

Rails doesn’t parse the SQL inside a condition and so doesn’t know that the
name is being substituted into a string. As a result, it will go ahead and add
extra quotes around the value of the name parameter. The correct way to do
this is to construct the full parameter to the like clause and pass that parameter into the condition:
# Works
User.where("name like ?", params[:name]+"%")

Of course, if we do this, we need to consider that characters such as percent
signs, should they happen to appear in the value of the name parameter, will
be treated as wildcards.

report erratum • discuss

Creating, Reading, Updating, and Deleting (CRUD)

•

285

Subsetting the Records Returned
Now that we know how to specify conditions, let’s turn our attention to the
various methods supported by ActiveRecord::Relation, starting with first() and all().
As you may have guessed, first() returns the first row in the relation. It returns
nil if the relation is empty. Similarly, all() returns all the rows as an array.
ActiveRecord::Relation also supports many of the methods of Array objects, such
as each() and map(). It does so by implicitly calling the all() first.
It’s important to understand that the query is not evaluated until one of these
methods is used. This enables us to modify the query in a number of ways,
namely, by calling additional methods, prior to making this call. Let’s look at
these methods now.

order
SQL that rows will be returned in any particular order unless we explicitly
add an order by clause to the query. The order() method lets us specify the criteria
we’d normally add after the order by keywords. For example, the following query
would return all of Dave’s orders, sorted first by payment type and then by
shipping date (the latter in descending order):
orders = Order.where(name: 'Dave').
order("pay_type, shipped_at DESC")

limit
We can limit the number of rows returned by calling the limit() method. Generally when we use the limit method, we’ll probably also want to specify the
sort order to ensure consistent results. For example, the following returns
the first ten matching orders:
orders = Order.where(name: 'Dave').
order("pay_type, shipped_at DESC").
limit(10)

offset
The offset() method goes hand in hand with the limit() method. It allows us to
specify the offset of the first row in the result set that will be returned.
# The view wants to display orders grouped into pages,
# where each page shows page_size orders at a time.
# This method returns the orders on page page_num (starting
# at zero).
def Order.find_on_page(page_num, page_size)
order(:id).limit(page_size).offset(page_num*page_size)
end

report erratum • discuss

286

•

Chapter 19. Active Record

We can use offset in conjunction with limit to step through the results of a query
n rows at a time.

select
By default, ActiveRecord::Relation fetches all the columns from the underlying
database table—it issues a select * from... to the database. Override this with
the select() method, which takes a string that will appear in place of the * in
the select statement.
This method allows us to limit the values returned in cases where we need
only a subset of the data in a table. For example, our table of podcasts might
contain information on the title, speaker, and date and might also contain a
large BLOB containing the MP3 of the talk. If you just wanted to create a list
of talks, it would be inefficient to also load up the sound data for each row.
The select() method lets us choose which columns to load.
list = Talk.select("title, speaker, recorded_on")

joins
The joins() method lets us specify a list of additional tables to be joined to the
default table. This parameter is inserted into the SQL immediately after the
name of the model’s table and before any conditions specified by the first
parameter. The join syntax is database-specific. The following code returns
a list of all line items for the book called Programming Ruby:
LineItem.select('li.quantity').
where("pr.title = 'Programming Ruby 1.9'").
joins("as li inner join products as pr on li.product_id = pr.id")

readonly
The readonly() method causes ActiveRecord::Resource to return Active Record objects
that cannot be stored back into the database.
If we use the joins() or select() methods, objects will automatically be marked
readonly.

group
The group() method adds a group by clause to the SQL generated by find():
summary = LineItem.select("sku, sum(amount) as amount").
group("sku")

lock
The lock() method takes an optional string as a parameter. If we pass it a
string, it should be a SQL fragment in our database’s syntax that specifies a

report erratum • discuss

Creating, Reading, Updating, and Deleting (CRUD)

•

287

kind of lock. With MySQL, for example, a share mode lock gives us the latest
data in a row and guarantees that no one else can alter that row while we
hold the lock. We could write code that debits an account only if there are
sufficient funds using something like the following:
Account.transaction do
ac = Account.where(id: id).lock("LOCK IN SHARE MODE").first
ac.balance -= amount if ac.balance > amount
ac.save
end

If we don’t specify a string value or we give lock() a value of true, the database’s
default exclusive lock is obtained (normally this will be "for update"). We can
often eliminate the need for this kind of locking using transactions (discussed
starting in Section 19.5, Transactions, on page 301).
Databases can do more than simply find and reliably retrieve data, they can
also do a bit of data reduction analysis. Rails provides access to these methods
too.

Getting Column Statistics
Rails has the ability to perform statistics on the values in a column. For
example, given a table of orders, we can calculate the following:
average
max
min
total
number

=
=
=
=
=

Order.average(:amount)
Order.maximum(:amount)
Order.minimum(:amount)
Order.sum(:amount)
Order.count

# average amount of orders

These all correspond to aggregate functions in the underlying database, but
they work in a database-independent manner.
As before, methods can be combined:
Order.where("amount > 20").minimum(:amount)

These functions aggregate values. By default, they return a single result,
producing, for example, the minimum order amount for orders meeting some
condition. However, if you include the group method, the functions instead
produce a series of results, one result for each set of records where the
grouping expression has the same value. For example, the following calculates
the maximum sale amount for each state:
result = Order.group(:state).maximum(:amount)
puts result #=> {"TX"=>12345, "NC"=>3456, ...}

report erratum • discuss

288

•

Chapter 19. Active Record

This code returns an ordered hash. You index it using the grouping element
("TX", "NC", … in our example). You can also iterate over the entries in order
using each(). The value of each entry is the value of the aggregation function.
The order and limit methods come into their own when using groups.
For example, the following returns the three states with the highest orders,
sorted by the order amount:
result = Order.group(:state).
order("max(amount) desc").
limit(3)

This code is no longer database independent—in order to sort on the aggregated column, we had to use the SQLite syntax for the aggregation function
(max, in this case).

Scopes
As these chains of method calls grow longer, making the chains themselves
available for reuse becomes a concern. Once again, Rails delivers. An Active
Record scope can be associated with a Proc and therefore may have arguments:
lambda
↪ on page 51

class Order < ActiveRecord::Base
scope :last_n_days, lambda { |days| where('updated < ?' , days) }
end

Such a named scope would make finding the last week’s worth of orders a
snap:
orders = Order.last_n_days(7)

Simpler scopes can simply be a set of method calls:
class Order < ActiveRecord::Base
scope :checks, where(pay_type: :check)
end

Scopes can also be combined. Finding the last week’s worth of orders that
were paid by check is just as easy:
orders = Order.checks.last_n_days(7)

In addition to making your application code easier to write and easier to read,
scopes can make your code more efficient. The previous statement, for example, is implemented as a single SQL query.
ActiveRecord::Relation objects are equivalent to an anonymous scope:
in_house = Order.where('email LIKE "%@pragprog.com"')

report erratum • discuss

Creating, Reading, Updating, and Deleting (CRUD)

•

289

Of course, relations can also be combined:
in_house.checks.last_n_days(7)

Scopes aren’t limited to where conditions; we can do pretty much anything
we can do in a method call: limit, order, join, and so on. Just be aware that Rails
doesn’t know how to handle multiple order or limit clauses, so be sure to use
these only once per call chain.
In nearly every case, the methods we have been describing are sufficient. But
Rails is not satisfied with only being able to handle nearly every case, so for
cases that require a human-crafted query, there is an API for that too.

Writing Our Own SQL
Each of the methods we have been looking at contributes to the construction
of a full SQL query string. The method find_by_sql() lets our application take
full control. It accepts a single parameter containing a SQL select statement
(or an array containing SQL and placeholder values, as for find()) and returns
a (potentially empty) array of model objects from the result set. The attributes
in these models will be set from the columns returned by the query. We’d
normally use the select * form to return all columns for a table, but this isn’t
required.
Download rails32/e1/ar/find_examples.rb
orders = LineItem.find_by_sql("select line_items.* from line_items, orders " +
" where order_id = orders.id
" +
"
and orders.name = 'Dave Thomas'
")

Only those attributes returned by a query will be available in the resulting
model objects. We can determine the attributes available in a model object
using the attributes(), attribute_names(), and attribute_present?() methods. The first
returns a hash of attribute name/value pairs, the second returns an array
of names, and the third returns true if a named attribute is available in this
model object.
Download rails32/e1/ar/find_examples.rb
orders = Order.find_by_sql("select name, pay_type from orders")
first = orders[0]
p first.attributes
p first.attribute_names
p first.attribute_present?("address")

This code produces the following:
{"name"=>"Dave Thomas", "pay_type"=>"check"}
["name", "pay_type"]
false

report erratum • discuss

290

•

Chapter 19. Active Record

find_by_sql() can also be used to create model objects containing derived column

data. If we use the as xxx SQL syntax to give derived columns a name in the
result set, this name will be used as the name of the attribute.
Download rails32/e1/ar/find_examples.rb
items = LineItem.find_by_sql("select *,
" products.price as unit_price,
" quantity*products.price as total_price,
" products.title as title
" from line_items, products
" where line_items.product_id = products.id
li = items[0]
puts "#{li.title}: #{li.quantity}x#{li.unit_price} => #{li.total_price}"

" +
" +
" +
" +
" +
")

As with conditions, we can also pass an array to find_by_sql(), where the first
element is a string containing placeholders. The rest of the array can be either
a hash or a list of values to be substituted.
Order.find_by_sql(["select * from orders where amount > ?",
params[:amount]])

In the old days of Rails, people frequently resorted to using find_by_sql(). Since
then, all the options added to the basic find() method mean that you can avoid
resorting to this low-level method.

Reloading Data
In an application where the database is potentially being accessed by multiple
processes (or by multiple applications), there’s always the possibility that a
fetched model object has become stale—someone may have written a more
recent copy to the database.
To some extent, this issue is addressed by transactional support (which we
describe in Section 19.5, Transactions, on page 301). However, there’ll still be
times where you need to refresh a model object manually. Active Record makes
this easy—simply call its reload() method, and the object’s attributes will be
refreshed from the database:
stock = Market.find_by_ticker("RUBY")
loop do
puts "Price = #{stock.price}"
sleep 60
stock.reload
end

In practice, reload() is rarely used outside the context of unit tests.

report erratum • discuss

Creating, Reading, Updating, and Deleting (CRUD)

•

291

David says:

But Isn’t SQL Dirty?
Ever since developers first wrapped relational databases with an object-oriented layer,
they’ve debated the question of how deep to run the abstraction. Some object-relational
mappers seek to eliminate the use of SQL entirely, hoping for object-oriented purity
by forcing all queries through an OO layer.
Active Record does not. It was built on the notion that SQL is neither dirty nor bad,
just verbose in the trivial cases. The focus is on removing the need to deal with the
verbosity in those trivial cases (writing a ten-attribute insert by hand will leave any
programmer tired) but keeping the expressiveness around for the hard queries—the
type SQL was created to deal with elegantly.
Therefore, you shouldn’t feel guilty when you use find_by_sql() to handle either performance bottlenecks or hard queries. Start out using the object-oriented interface for
productivity and pleasure, and then dip beneath the surface for a close-to-the-metal
experience when you need to do so.

Updating Existing Rows
After such a long discussion of finder methods, you’ll be pleased to know that
there’s not much to say about updating records with Active Record.
If you have an Active Record object (perhaps representing a row from our orders
table), you can write it to the database by calling its save() method. If this
object had previously been read from the database, this save will update the
existing row; otherwise, the save will insert a new row.
If an existing row is updated, Active Record will use its primary key column
to match it with the in-memory object. The attributes contained in the Active
Record object determine the columns that will be updated—a column will be
updated in the database only if its value has been changed. In the following
example, all the values in the row for order 123 can be updated in the database
table:
order = Order.find(123)
order.name = "Fred"
order.save

However, in the following example, the Active Record object contains just the
attributes id, name, and paytype—only these columns can be updated when the
object is saved. (Note that you have to include the id column if you intend to
save a row fetched using find_by_sql().)
orders = Order.find_by_sql("select id, name, pay_type from orders where id=123")

report erratum • discuss

292

•

Chapter 19. Active Record

first = orders[0]
first.name = "Wilma"
first.save

In addition to the save() method, Active Record lets us change the values of
attributes and save a model object in a single call to update_attribute():
order = Order.find(123)
order.update_attribute(:name, "Barney")
order = Order.find(321)
order.update_attributes(name: "Barney",
email: "barney@bedrock.com")

The update_attributes() method is most commonly used in controller actions
where it merges data from a form into an existing database row:
def save_after_edit
order = Order.find(params[:id])
if order.update_attributes(params[:order])
redirect_to action: :index
else
render action: :edit
end
end

We can combine the functions of reading a row and updating it using the
class methods update() and update_all(). The update() method takes an id parameter
and a set of attributes. It fetches the corresponding row, updates the given
attributes, saves the result to the database, and returns the model object.
order = Order.update(12, name: "Barney", email: "barney@bedrock.com")

We can pass update() an array of ids and an array of attribute value hashes,
and it will update all the corresponding rows in the database, returning an
array of model objects.
Finally, the update_all() class method allows us to specify the set and where
clauses of the SQL update statement. For example, the following increases the
prices of all products with Java in their title by 10 percent:
result = Product.update_all("price = 1.1*price", "title like '%Java%'")

The return value of update_all() depends on the database adapter; most (but
not Oracle) return the number of rows that were changed in the database.

save, save!, create, and create!
It turns out that there are two versions of the save and create methods. The
variants differ in the way they report errors:

report erratum • discuss

Creating, Reading, Updating, and Deleting (CRUD)

•

293

• save returns true if the record was saved; it returns nil otherwise.
• save! returns true if the save succeeded; it raises an exception otherwise.
• create returns the Active Record object regardless of whether it was successfully saved. You’ll need to check the object for validation errors if you
want to determine whether the data was written.
• create! returns the Active Record object on success; it raises an exception
otherwise.
Let’s look at this in a bit more detail.
Plain old save() returns true if the model object is valid and can be saved:
if order.save
# all OK
else
# validation failed
end

It’s up to us to check on each call to save() to see that it did what we expected.
The reason Active Record is so lenient is that it assumes save() is called in the
context of a controller’s action method and that the view code will be presenting any errors back to the end user. And for many applications, that’s the
case.
However, if we need to save a model object in a context where we want to
make sure to handle all errors programmatically, we should use save!(). This
method raises a RecordInvalid exception if the object could not be saved:
begin
order.save!
rescue RecordInvalid => error
# validation failed
end

Deleting Rows
Active Record supports two styles of row deletion. First, it has two class-level
methods, delete() and delete_all(), that operate at the database level. The delete()
method takes a single id or an array of ids and deletes the corresponding
row(s) in the underlying table. delete_all() deletes rows matching a given condition (or all rows if no condition is specified). The return values from both calls
depend on the adapter but are typically the number of rows affected. An
exception is not thrown if the row doesn’t exist prior to the call.
Order.delete(123)
User.delete([2,3,4,5])

report erratum • discuss

294

•

Chapter 19. Active Record

Product.delete_all(["price > ?", @expensive_price])

The various destroy methods are the second form of row deletion provided by
Active Record. These methods all work via Active Record model objects.
The destroy() instance method deletes from the database the row corresponding
to a particular model object. It then freezes the contents of that object, preventing future changes to the attributes.
order = Order.find_by_name("Dave")
order.destroy
# ... order is now frozen

There are two class-level destruction methods, destroy() (which takes an id or
an array of ids) and destroy_all() (which takes a condition). Both methods read
the corresponding rows in the database table into model objects and call the
instance-level destroy() method of those objects. Neither method returns anything meaningful.
Order.destroy_all(["shipped_at < ?", 30.days.ago])

Why do we need both the delete and destroy class methods? The delete methods
bypass the various Active Record callback and validation functions, while the
destroy methods ensure that they are all invoked. In general, it is better to use
the destroy methods if you want to ensure that your database is consistent
according to the business rules defined in your model classes.
We covered validation in Chapter 7, Task B: Validation and Unit Testing, on
page 77. We cover callbacks next.

19.4 Participating in the Monitoring Process
Active Record controls the life cycle of model objects—it creates them, monitors
them as they are modified, saves and updates them, and watches sadly as
they are destroyed. Using callbacks, Active Record lets our code participate
in this monitoring process. We can write code that gets invoked at any significant event in the life of an object. With these callbacks we can perform
complex validation, map column values as they pass in and out of the
database, and even prevent certain operations from completing.
Active Record defines sixteen callbacks. Fourteen of these form before/after
pairs and bracket some operation on an Active Record object. For example,
the before_destroy callback will be invoked just before the destroy() method is
called, and after_destroy will be invoked after. The two exceptions are after_find
and after_initialize, which have no corresponding before_xxx callback. (These two
callbacks are different in other ways, too, as we’ll see later.)

report erratum • discuss

Participating in the Monitoring Process

•

295

In Figure 48, Sequence of Active Record callbacks, on page 296, we can see
how Rails wraps the sixteen paired callbacks around the basic create, update,
and destroy operations on model objects. Perhaps surprisingly, the before
and after validation calls are not strictly nested.
The before_validation and after_validation calls also accept the on: :create or on: :update
parameter, which will cause the callback to only be called on the selected
operation.
In addition to these sixteen calls, the after_find callback is invoked after any
find operation, and after_initialize is invoked after an Active Record model object
is created.
To have your code execute during a callback, you need to write a handler and
associate it with the appropriate callback.
There are two basic ways of implementing callbacks.
The preferred way to define a callback is to declare handlers. A handler can
be either a method or a block. You associate a handler with a particular event
using class methods named after the event. To associate a method, declare
it as private or protected, and specify its name as a symbol to the handler
declaration. To specify a block, simply add it after the declaration. This block
receives the model object as a parameter.
class Order < ActiveRecord::Base
before_validation :normalize_credit_card_number
after_create do |order|
logger.info "Order #{order.id} created"
end
protected
def normalize_credit_card_number
self.cc_number.gsub!(/[-\s]/, '')
end
end

You can specify multiple handlers for the same callback. They will generally
be invoked in the order they are specified unless a handler returns false (and
it must be the actual value false), in which case the callback chain is broken
early.
Alternately, you can define the callback instance method directly. If you want
to handle the before save event, for example, you could write this:
class Order < ActiveRecord::Base
# ..
def before_save
self.payment_due ||= Time.now + 30.days

report erratum • discuss

296

•

Chapter 19. Active Record

model.save()
new record

model.destroy()

existing record

before_validation

before_validation

validation operations

validation operations

after_validation

after_validation

before_save

before_save

before_create

before_update

before_destroy

insert operation

update operation

delete operation

after_create

after_update

after_destroy

after_save

after_save

Figure 48—Sequence of Active Record callbacks

end
end

Because of a performance optimization, the only way to define callbacks for
the after_find and after_initialize events is to define them as methods. If you try
declaring them as handlers using the second technique, they’ll be silently
ignored. (Sometimes folks ask why this was done. Rails has to use reflection
to determine whether there are callbacks to be invoked. When doing real
database operations, the cost of doing this is normally not significant compared
to the database overhead. However, a single database select statement could
return hundreds of rows, and both callbacks would have to be invoked for
each. This slows the query down significantly. The Rails team decided that
performance trumps consistency in this case.)

Grouping Related Callbacks Together
If you have a group of related callbacks, it may be convenient to group them
into a separate handler class. These handlers can be shared between multiple
models. A handler class is simply a class that defines callback methods
(before_save(), after_create(), and so on). Create the source files for these handler
classes in app/models.
In the model object that uses the handler, you create an instance of this
handler class and pass that instance to the various callback declarations. A
couple of examples will make this clearer.

report erratum • discuss

Participating in the Monitoring Process

•

297

If our application uses credit cards in multiple places, we might want to share
our normalize_credit_card_number() method across multiple models. To do that, we’d
extract the method into its own class and name it after the event we want it
to handle. This method will receive a single parameter, the model object that
generated the callback.
class CreditCardCallbacks
# Normalize the credit card number
def before_validation(model)
model.cc_number.gsub!(/[-\s]/, '')
end
end

Now, in our model classes, we can arrange for this shared callback to be
invoked:
class Order < ActiveRecord::Base
before_validation CreditCardCallbacks.new
# ...
end
class Subscription < ActiveRecord::Base
before_validation CreditCardCallbacks.new
# ...
end

In this example, the handler class assumes that the credit card number is
held in a model attribute named cc_number; both Order and Subscription would
have an attribute with that name. But we can generalize the idea, making
the handler class less dependent on the implementation details of the classes
that use it.
For example, we could create a generalized encryption and decryption handler.
This could be used to encrypt named fields before they are stored in the
database and to decrypt them when the row is read back. You could include
it as a callback handler in any model that needed the facility.
The handler needs to encrypt a given set of attributes in a model just before
that model’s data is written to the database. Because our application needs
to deal with the plain-text versions of these attributes, it arranges to decrypt
them again after the save is complete. It also needs to decrypt the data when
a row is read from the database into a model object. These requirements mean
we have to handle the before_save, after_save, and after_find events. Because we
need to decrypt the database row both after saving and when we find a new
row, we can save code by aliasing the after_find() method to after_save()—the same
method will have two names.

report erratum • discuss

298

•

Chapter 19. Active Record

Download rails32/e1/ar/encrypt.rb
class Encrypter
# We're passed a list of attributes that should
# be stored encrypted in the database
def initialize(attrs_to_manage)
@attrs_to_manage = attrs_to_manage
end
# Before saving or updating, encrypt the fields using the NSA and
# DHS approved Shift Cipher
def before_save(model)
@attrs_to_manage.each do |field|
model[field].tr!("a-z", "b-za")
end
end
# After saving, decrypt them back
def after_save(model)
@attrs_to_manage.each do |field|
model[field].tr!("b-za", "a-z")
end
end
# Do the same after finding an existing record
alias_method :after_find, :after_save
end

This example uses trivial encryption—you might want to beef it up before
using this class for real.
We can now arrange for the Encrypter class to be invoked from inside our orders
model:
require "encrypter"
class Order < ActiveRecord::Base
encrypter = Encrypter.new([:name, :email])
before_save encrypter
after_save encrypter
after_find encrypter
protected
def after_find
end
end

We create a new Encrypter object and hook it up to the events before_save,
after_save, and after_find. This way, just before an order is saved, the method
before_save() in the encrypter will be invoked, and so on.

report erratum • discuss

Participating in the Monitoring Process

•

299

So, why do we define an empty after_find() method? Remember that we said
that for performance reasons after_find and after_initialize are treated specially.
One of the consequences of this special treatment is that Active Record won’t
know to call an after_find handler unless it sees an actual after_find() method in
the model class. We have to define an empty placeholder to get after_find processing to take place.
This is all very well, but every model class that wants to use our encryption
handler would need to include some eight lines of code, just as we did with
our Order class. We can do better than that. We’ll define a helper method that
does all the work and make that helper available to all Active Record models.
To do that, we’ll add it to the ActiveRecord::Base class:
Download rails32/e1/ar/encrypt.rb
class ActiveRecord::Base
def self.encrypt(*attr_names)
encrypter = Encrypter.new(attr_names)
before_save encrypter
after_save encrypter
after_find encrypter
define_method(:after_find) { }
end
end

Given this, we can now add encryption to any model class’s attributes using
a single call.
Download rails32/e1/ar/encrypt.rb
class Order < ActiveRecord::Base
encrypt(:name, :email)
end

A simple driver program lets us experiment with this:
Download rails32/e1/ar/encrypt.rb
o = Order.new
o.name = "Dave Thomas"
o.address = "123 The Street"
o.email
= "dave@example.com"
o.save
puts o.name
o = Order.find(o.id)
puts o.name

On the console, we see our customer’s name (in plain text) in the model object:
ar> ruby encrypt.rb

report erratum • discuss

300

•

Chapter 19. Active Record

Dave Thomas
Dave Thomas

In the database, however, the name and email address are obscured by our
industrial-strength encryption:
depot> sqlite3 -line db/development.sqlite3 "select * from orders"
id = 1
user_id =
name = Dbwf Tipnbt
address = 123 The Street
email = ebwf@qsbhqsph.dpn

Callbacks are a fine technique, but they can sometimes result in a model
class taking on responsibilities that aren’t really related to the nature of the
model. For example, in Section 19.4, Participating in the Monitoring Process,
on page 294 we created a callback that generated a log message when an order
was created. That functionality isn’t really part of the basic Order class—we
put it there because that’s where the callback executed.
Active Record observers overcome that limitation.

Observers
An Active Record observer is an object that transparently links itself into a
model class, registering itself for callbacks as if it were part of the model but
without requiring any changes in the model itself. Here’s our previous logging
example written using an observer:
Download rails32/e1/ar/observer.rb
class OrderObserver < ActiveRecord::Observer
def after_save(an_order)
an_order.logger.info("Order #{an_order.id} created")
end
end

When ActiveRecord::Observer is subclassed, it looks at the name of the new class,
strips the word Observer from the end, and assumes that what is left is the
name of the model class to be observed. In our example, we called our observer
class OrderObserver, so it automatically hooked itself into the model Order.
Sometimes this convention breaks down. When it does, the observer class
can explicitly list the model or models it wants to observe using the observe()
method:
Download rails32/e1/ar/observer.rb
class AuditObserver < ActiveRecord::Observer
observe Order, Payment, Refund
def after_save(model)

report erratum • discuss

Transactions

•

301

model.logger.info("[Audit] #{model.class.name} #{model.id} created")
end
end

By convention, observer source files live in app/models.

Instantiating Observers
So far we’ve defined our observers. However, we also need to instantiate
them—if we don’t, they simply won’t fire. And how we instantiate observers
depends on whether we’re using them inside or outside the context of a Rails
application.
If you’re using observers within a Rails application, you need to list them in
your application’s application.rb file (in the config directory):
config.active_record.observers = :order_observer, :audit_observer

If instead you’re using your Active Record objects in a stand-alone application
(that is, you’re not running Active Record within a Rails application), you
need to create instances of the observers manually using instance():
OrderObserver.instance
AuditObserver.instance

In a way, observers bring to Rails much of the benefits of first-generation
aspect-oriented programming in languages such as Java. They allow you to
inject behavior into model classes without changing any of the code in those
classes.

19.5 Transactions
A database transaction groups a series of changes together in such a way
that either the database applies all of the changes or it applies none of the
changes. The classic example of the need for transactions (and one used in
Active Record’s own documentation) is transferring money between two bank
accounts. The basic logic is simple:
account1.deposit(100)
account2.withdraw(100)

However, we have to be careful. What happens if the deposit succeeds but
for some reason the withdrawal fails (perhaps the customer is overdrawn)?
We’ll have added $100 to the balance in account1 without a corresponding
deduction from account2. In effect, we’ll have created $100 out of thin air.
Transactions to the rescue. A transaction is something like the Three Musketeers with their motto “All for one and one for all.” Within the scope of a

report erratum • discuss

302

•

Chapter 19. Active Record

transaction, either every SQL statement succeeds or they all have no effect.
Putting that another way, if any statement fails, the entire transaction has
no effect on the database.
In Active Record we use the transaction() method to execute a block in the context
of a particular database transaction. At the end of the block, the transaction
is committed, updating the database, unless an exception is raised within
the block, in which case the database rolls back all of the changes. Because
transactions exist in the context of a database connection, we have to invoke
them with an Active Record class as a receiver.
Thus, we could write this:
Account.transaction do
account1.deposit(100)
account2.withdraw(100)
end

Let’s experiment with transactions. We’ll start by creating a new database
table. (Make sure your database supports transactions, or this code won’t
work for you.)
Download rails32/e1/ar/transactions.rb
create_table :accounts, force: true do |t|
t.string :number
t.decimal :balance, precision: 10, scale: 2, default: 0
end

Next, we’ll define a simple bank account class. This class defines instance
methods to deposit money to and withdraw money from the account. It also
provides some basic validation—for this particular type of account, the balance
can never be negative.
Download rails32/e1/ar/transactions.rb
class Account < ActiveRecord::Base
validate :price_must_be_at_least_a_cent
def withdraw(amount)
adjust_balance_and_save(-amount)
end
def deposit(amount)
adjust_balance_and_save(amount)
end
private
def adjust_balance_and_save(amount)
self.balance += amount
save!
end

report erratum • discuss

Transactions

•

303

def price_must_be_at_least_a_cent
errors.add(:balance, "is negative") if balance < 0
end
end

Let’s look at the helper method, adjust_balance_and_save(). The first line simply
updates the balance field. The method then calls save! to save the model data.
(Remember that save!() raises an exception if the object cannot be saved—we
use the exception to signal to the transaction that something has gone wrong.)
So, now let’s write the code to transfer money between two accounts. It’s
pretty straightforward:
Download rails32/e1/ar/transactions.rb
peter = Account.create(balance: 100, number: "12345")
paul = Account.create(balance: 200, number: "54321")
Account.transaction do
paul.deposit(10)
peter.withdraw(10)
end

We check the database, and, sure enough, the money got transferred:
depot> sqlite3 -line db/development.sqlite3 "select * from accounts"
id = 1
number = 12345
balance = 90
id = 2
number = 54321
balance = 210

Now let’s get radical. If we start again but this time try to transfer $350, we’ll
run Peter into the red, which isn’t allowed by the validation rule. Let’s try it:
Download rails32/e1/ar/transactions.rb
peter = Account.create(balance: 100, number: "12345")
paul = Account.create(balance: 200, number: "54321")
Download rails32/e1/ar/transactions.rb
Account.transaction do
paul.deposit(350)
peter.withdraw(350)
end

When we run this, we get an exception reported on the console:
.../validations.rb:736:in `save!': Validation failed: Balance is negative
from transactions.rb:46:in `adjust_balance_and_save'
:
:
:

report erratum • discuss

304

•

Chapter 19. Active Record

from transactions.rb:80

Looking in the database, we can see that the data remains unchanged:
depot> sqlite3 -line db/development.sqlite3 "select * from accounts"
id = 1
number = 12345
balance = 100
id = 2
number = 54321
balance = 200

However, there’s a trap waiting for you here. The transaction protected the
database from becoming inconsistent, but what about our model objects? To
see what happened to them, we have to arrange to intercept the exception to
allow the program to continue running:
Download rails32/e1/ar/transactions.rb
peter = Account.create(balance: 100, number: "12345")
paul = Account.create(balance: 200, number: "54321")
Download rails32/e1/ar/transactions.rb
begin
Account.transaction do
paul.deposit(350)
peter.withdraw(350)
end
rescue
puts "Transfer aborted"
end
puts "Paul has #{paul.balance}"
puts "Peter has #{peter.balance}"

What we see is a little surprising:
Transfer aborted
Paul has 550.0
Peter has -250.0

Although the database was left unscathed, our model objects were updated
anyway. This is because Active Record wasn’t keeping track of the before and
after states of the various objects—in fact it couldn’t, because it had no easy
way of knowing just which models were involved in the transactions.

Built-in Transactions
When we discussed parent and child tables in Specifying Relationships in
Models, on page 276, we said that Active Record takes care of saving all the
dependent child rows when you save a parent row. This takes multiple SQL

report erratum • discuss

Transactions

•

305

statement executions (one for the parent and one each for any changed or
new children). Clearly, this change should be atomic, but until now we haven’t
been using transactions when saving these interrelated objects. Have we been
negligent?
Fortunately, no. Active Record is smart enough to wrap all the updates and
inserts related to a particular save() (and also the deletes related to a destroy())
in a transaction; either they all succeed or no data is written permanently to
the database. You need explicit transactions only when you manage multiple
SQL statements yourself.
While we have covered the basics, transactions are actually very subtle. They
exhibit the so-called ACID properties: they’re Atomic, they ensure Consistency,
they work in Isolation, and their effects are Durable (they are made permanent
when the transaction is committed). It’s worth finding a good database book
and reading up on transactions if you plan to take a database application
live.

What We Just Did
We learned the relevant data structures and naming conventions for tables,
classes, columns, attributes, ids, and relationships. We saw how to create,
read, update, and delete this data. Finally, we now understand how transactions and callbacks can be used to prevent inconsistent changes.
This, coupled with validation as described in Chapter 7, Task B: Validation
and Unit Testing, on page 77, covers all the essentials of Active Record that
every Rails programmer needs to know. If you have specific needs beyond
what is covered here, look to the Rails Guides that you generated in A Place
for Documentation, on page 259 for more information.
The next major subsystem to cover is Action Pack, which covers both the view
and controller portions of Rails.

report erratum • discuss

In this chapter, we’ll see
• Representational State Transfer (REST);
• defining how requests are routed to controllers;
• selecting a data representation;
• testing routes;
• the controller environment;
• rendering and redirecting; and
• sessions, flash, and filters.

CHAPTER 20

Action Dispatch and Action Controller
Action Pack lies at the heart of Rails applications. It consists of three Ruby
modules: ActionDispatch, ActionController, and ActionView. Action Dispatch routes
requests to controllers. Action Controller converts requests into responses.
Action View is used by Action Controller to format those responses.
As a concrete example, in the Depot application, we routed the root of the
site (/) to the index() method of the StoreController. At the completion of that
method, the template in app/views/store/index.html.erb was rendered. Each of these
activities was orchestrated by modules in the Action Pack component.
Working together, these three submodules provide support for processing
incoming requests and generating outgoing responses. In this chapter, we’ll
look at both Action Dispatch and Action Controller. In the next chapter, we
will cover Action View.
When we looked at Active Record, we saw it could be used as a freestanding
library; you can use Active Record as part of a nonweb Ruby application.
Action Pack is different. Although it is possible to use it directly as a framework, you probably won’t. Instead, you’ll take advantage of the tight integration
offered by Rails. Components such as Action Controller, Action View, and
Active Record handle the processing of requests, and the Rails environment
knits them together into a coherent (and easy-to-use) whole. For that reason,
we’ll describe Action Controller in the context of Rails. Let’s start by looking
at how Rails applications handle requests. We’ll then dive down into the details
of routing and URL handling. We’ll continue by looking at how you write code
in a controller. Finally, we will cover sessions, flash, and filters.

20.1 Dispatching Requests to Controllers
At its simplest, a web application accepts an incoming request from a
browser, processes it, and sends a response.

report erratum • discuss

308

•

Chapter 20. Action Dispatch and Action Controller

The first question that springs to mind is, how does the application know
what to do with the incoming request? A shopping cart application will receive
requests to display a catalog, add items to a cart, create an order, and so on.
How does it route these requests to the appropriate code?
It turns out that Rails provides two ways to define how to route a request: a
comprehensive way that you will use when you need to and a convenient way
that you will generally use whenever you can.
The comprehensive way lets you define a direct mapping of URLs to actions
based on pattern matching, requirements, and conditions. The convenient
way lets you define routes based on resources, such as the models that you
define. And because the convenient way is built on the comprehensive way,
you can freely mix and match the two approaches.
In both cases, Rails encodes information in the request URL and uses a
subsystem called Action Dispatch to determine what should be done with that
request. The actual process is very flexible, but at the end of it Rails has
determined the name of the controller that handles this particular request,
along with a list of any other request parameters. In the process, either one
of these additional parameters or the HTTP method itself is used to identify
the action to be invoked in the target controller.
Rails routes support the mapping between URLs and actions based on the
contents of the URL and on the HTTP method used to invoke the request.
We’ve seen how to do this on a URL-by-URL basis using anonymous or named
routes. Rails also supports a higher-level way of creating groups of related
routes. To understand the motivation for this, we need to take a little diversion
into the world of Representational State Transfer.

REST: Representational State Transfer
The ideas behind REST were formalized in Chapter 5 of Roy Fielding’s 2000
PhD dissertation.1 In a REST approach, servers communicate with clients
using stateless connections. All the information about the state of the interaction between the two is encoded into the requests and responses between
them. Long-term state is kept on the server as a set of identifiable resources.
Clients access these resources using a well-defined (and severely constrained)
set of resource identifiers (URLs in our context). REST distinguishes the
content of resources from the presentation of that content. REST is designed
to support highly scalable computing while constraining application architectures to be decoupled by nature.
1.

http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm

report erratum • discuss

Dispatching Requests to Controllers

•

309

There’s a lot of abstract stuff in this description. What does REST mean in
practice?
First, the formalities of a RESTful approach mean that network designers
know when and where they can cache responses to requests. This enables
load to be pushed out through the network, increasing performance and
resilience while reducing latency.
Second, the constraints imposed by REST can lead to easier-to-write (and
maintain) applications. RESTful applications don’t worry about implementing
remotely accessible services. Instead, they provide a regular (and simple)
interface to a set of resources. Your application implements a way of listing,
creating, editing, and deleting each resource, and your clients do the rest.
Let’s make this more concrete. In REST, we use a simple set of verbs to operate
on a rich set of nouns. If we’re using HTTP, the verbs correspond to HTTP
methods (GET, PUT, POST, and DELETE, typically). The nouns are the
resources in our application. We name those resources using URLs.
The Depot application that we produced contained a set of products. There
are implicitly two resources here. First, there are the individual products.
Each constitutes a resource. There’s also a second resource: the collection of
products.
To fetch a list of all the products, we could issue an HTTP GET request against
this collection, say on the path /products. To fetch the contents of an individual
resource, we have to identify it. The Rails way would be to give its primary
key value (that is, its id). Again we’d issue a GET request, this time against
the URL /products/1.
To create a new product in our collection we use an HTTP POST request
directed at the /products path, with the post data containing the product to
add. Yes, that’s the same path we used to get a list of products. If you issue
a GET to it, it responds with a list, and if you do a POST to it, it adds a new
product to the collection.
Take this a step further. We’ve already seen you can retrieve the content of
a product—you just issue a GET request against the path /products/1. To update
that product, you’d issue an HTTP PUT request against the same URL. And,
to delete it, you could issue an HTTP DELETE request, again using the same
URL.
Take this further. Maybe our system also tracks users. Again, we have a set
of resources to deal with. REST tells us to use the same set of verbs (GET,

report erratum • discuss

310

•

Chapter 20. Action Dispatch and Action Controller

POST, PUT, and DELETE) against a similar-looking set of URLs (/users, /users/1,
and so on).
Now we see some of the power of the constraints imposed by REST. We’re
already familiar with the way Rails constrains us to structure our applications
a certain way. Now the REST philosophy tells us to structure the interface to
our applications too. Suddenly our world gets a lot simpler.
Rails has direct support for this type of interface; it adds a kind of macro
route facility, called resources. Let’s take a look at how the config/routes.rb might
have looked back in Creating a Rails Application, on page 61.
➤

Depot::Application.routes.draw do |map|
resources :products
end

The resources line caused seven new routes to be added to our application.
Along the way, it assumed that the application will have a controller named
ProductsController, containing seven actions with given names.
You can take a look at the routes that were generated for us. We do this by
making use of the handy rake routes command:
products GET

/products(.:format)
{:action=>"index", :controller=>"products"}
POST
/products(.:format)
{:action=>"create", :controller=>"products"}
new_product GET
/products/new(.:format)
{:action=>"new", :controller=>"products"}
edit_product GET
/products/:id/edit(.:format)
{:action=>"edit", :controller=>"products"}
product GET
/products/:id(.:format)
{:action=>"show", :controller=>"products"}
PUT
/products/:id(.:format)
{:action=>"update", :controller=>"products"}
DELETE /products/:id(.:format)
{:action=>"destroy", :controller=>"products"}

All the routes defined are spelled out in a columnar format. The lines will
generally wrap on your screen; in fact, they had to be broken into two lines
per route to fit on this page. The columns are (optional) route name, HTTP
method, route path, and (on a separate line on this page) route requirements.
Fields in parentheses are optional parts of the path. Field names preceded
by a colon name variables into which this part of the path is placed for later
processing by the controller.

report erratum • discuss

Dispatching Requests to Controllers

•

311

Now let’s look at the seven controller actions that these routes reference.
Although we created our routes to manage the products in our application,
let’s broaden this out in these descriptions and talk about resources—after
all, the same seven methods will be required for all resource-based routes:
index

Returns a list of the resources.
create

Creates a new resource from the data in the POST request, adding it to
the collection.
new

Constructs a new resource and passes it to the client. This resource will
not have been saved on the server. You can think of the new action as
creating an empty form for the client to fill in.
show

Returns the contents of the resource identified by params[:id].
update

Updates the contents of the resource identified by params[:id] with the data
associated with the request.
edit

Returns the contents of the resource identified by params[:id] in a form
suitable for editing.
destroy

Destroys the resource identified by params[:id].
You can see that these seven actions contain the four basic CRUD operations
(create, read, update, and delete). They also contain an action to list resources
and two auxiliary actions that return new and existing resources in a form
suitable for editing on the client.
If for some reason you don’t need or want all seven actions, you can limit the
actions produced using :only or :except options on your resources:
resources :comments, except: [:update, :destroy]

Several of the routes are named routes enabling you to use helper functions
such as products_url and edit_product_url(id:1).
Note that each route is defined with an optional format specifier. We will
cover formats in more detail in Selecting a Data Representation, on page 316.
Let’s take a look at the controller code:

report erratum • discuss

312

•

Chapter 20. Action Dispatch and Action Controller

Download rails32/depot_a/app/controllers/products_controller.rb
class ProductsController < ApplicationController
# GET /products
# GET /products.json
def index
@products = Product.all
respond_to do |format|
format.html # index.html.erb
format.json { render json: @products }
end
end
# GET /products/1
# GET /products/1.json
def show
@product = Product.find(params[:id])
respond_to do |format|
format.html # show.html.erb
format.json { render json: @product }
end
end
# GET /products/new
# GET /products/new.json
def new
@product = Product.new
respond_to do |format|
format.html # new.html.erb
format.json { render json: @product }
end
end
# GET /products/1/edit
def edit
@product = Product.find(params[:id])
end
# POST /products
# POST /products.json
def create
@product = Product.new(params[:product])
respond_to do |format|
if @product.save
format.html { redirect_to @product,
notice: 'Product was successfully created.' }
format.json { render json: @product, status: :created,

report erratum • discuss

Dispatching Requests to Controllers

•

313

location: @product }
else
format.html { render action: "new" }
format.json { render json: @product.errors,
status: :unprocessable_entity }
end
end
end
# PUT /products/1
# PUT /products/1.json
def update
@product = Product.find(params[:id])
respond_to do |format|
if @product.update_attributes(params[:product])
format.html { redirect_to @product,
notice: 'Product was successfully updated.' }
format.json { head :no_content }
else
format.html { render action: "edit" }
format.json { render json: @product.errors,
status: :unprocessable_entity }
end
end
end
# DELETE /products/1
# DELETE /products/1.json
def destroy
@product = Product.find(params[:id])
@product.destroy
respond_to do |format|
format.html { redirect_to products_url }
format.json { head :no_content }
end
end
end

Notice how we have one action for each of the RESTful actions. The comment
before each shows the format of the URL that invokes it.
Notice also that many of the actions contain a respond_to() block. As we saw
in Chapter 11, Task F: Add a Dash of Ajax, on page 129, Rails uses this to
determine the type of content to send in a response. The scaffold generator
automatically creates code that will respond appropriately to requests for
HTML or JSON content. We’ll play with that in a little while.

report erratum • discuss

314

•

Chapter 20. Action Dispatch and Action Controller

The views created by the generator are fairly straightforward. The only tricky
thing is the need to use the correct HTTP method to send requests to the
server. For example, the view for the index action looks like this:
Download rails32/depot_a/app/views/products/index.html.erb
<h1>Listing products</h1>
<table>
<% @products.each do |product| %>
<tr class="<%= cycle('list_line_odd', 'list_line_even') %>">
<td>
<%= image_tag(product.image_url, class: 'list_image') %>
</td>
<td class="list_description">
<dl>
<dt><%= product.title %></dt>
<dd><%= truncate(strip_tags(product.description),
length: 80) %></dd>
</dl>
</td>
<td class="list_actions">
<%= link_to 'Show', product %><br/>
<%= link_to 'Edit', edit_product_path(product) %><br/>
<%= link_to 'Destroy', product,
confirm: 'Are you sure?',
method: :delete %>
</td>
</tr>
<% end %>
</table>
<br />
<%= link_to 'New product', new_product_path %>

The links to the actions that edit a product and add a new product should
both use regular GET methods, so a standard link_to works fine. However, the
request to destroy a product must issue an HTTP DELETE, so the call includes
the method: :delete option to link_to.

Adding Additional Actions
Rails resources provide you with an initial set of actions, but you don’t need
to stop there. In Section 12.2, Iteration G2: Atom Feeds, on page 166, we added
an interface to allow people to fetch a list of people who bought any given
product. To do that with Rails, we use an extension to the resources call:

report erratum • discuss

Dispatching Requests to Controllers

•

315

Depot::Application.routes.draw do
resources :products do
get :who_bought, on: :member
end
end

That syntax is straightforward. It says “We want to add a new action named
who_bought, invoked via an HTTP GET. It applies to each member of the collection of products.”
Instead of specifying :member, if we instead specified :collection, then the route
would apply to the collection as a whole. This is often used for scoping; for
example, you may have collections of products on clearance or products that
have been discontinued.

Nested Resources
Often our resources themselves contain additional collections of resources.
For example, we may want to allow folks to review our products. Each review
would be a resource, and collections of review would be associated with each
product resource.
Rails provides a convenient and intuitive way of declaring the routes for this
type of situation:
resources :products do
resources :reviews
end

This defines the top-level set of products routes and additionally creates a
set of subroutes for reviews. Because the review resources appear inside the
products block, a review resource must be qualified by a product resource.
This means that the path to a review must always be prefixed by the path to
a particular product. To fetch the review with id 4 for the product with an id
of 99, you’d use a path of /products/99/reviews/4.
The named route for /products/:product_id/reviews/:id is product_review, not simply
review. This naming simply reflects the nesting of these resources.
As always, you can see the full set of routes generated by our configuration
by using the rake routes command.

Shallow Route Nesting
At times, nested resources can produce cumbersome URLs. A solution to this
is to use shallow route nesting:

report erratum • discuss

316

•

Chapter 20. Action Dispatch and Action Controller

resources :products, shallow: true do
resources :reviews
end

This will enable the recognition of the following routes:
/products/1
=> product_path(1)
/products/1/reviews => product_reviews_index_path(1)
/reviews/2
=> reviews_path(2)

Try the rake routes command to see the full mapping.

Selecting a Data Representation
One of the goals of a REST architecture is to decouple data from its representation. If a human uses the URL path /products to fetch some products, they
should see nicely formatted HTML. If an application asks for the same URL,
it could elect to receive the results in a code-friendly format (YAML, JSON,
or XML, perhaps).
We’ve already seen how Rails can use the HTTP Accept header in a respond_to
block in the controller. However, it isn’t always easy (and sometimes it’s plain
impossible) to set the Accept header. To deal with this, Rails allows you to
pass the format of response you’d like as part of the URL. As you have seen,
Rails accomplishes this by including a field called :format in your route definitions: To do this, set a :format parameter in your routes to the file extension
of the MIME type you’d like returned.
GET

/products(.:format)
{:action=>"index", :controller=>"products"}

Because a full stop (period) is a separator character in route definitions, :format
is treated as just another field. Because we give it a nil default value, it’s an
optional field.
Having done this, we can use a respond_to() block in our controllers to select
our response type depending on the requested format:
def show
respond_to do |format|
format.html
format.xml { render xml: @product.to_xml }
format.yaml { render text: @product.to_yaml }
end
end

Given this, a request to /store/show/1 or /store/show/1.html will return HTML content,
while /store/show/1.xml will return XML and /store/show/1.yaml will return YAML.
You can also pass the format in as an HTTP request parameter:

report erratum • discuss

Dispatching Requests to Controllers

•

317

GET HTTP://pragprog.com/store/show/123?format=xml

The routes defined by resources have this facility enabled by default.
Although the idea of having a single controller that responds with different
content types seems appealing, the reality is tricky. In particular, it turns out
that error handling can be tough. Although it’s acceptable on error to redirect
a user to a form, showing them a nice flash message, you have to adopt a
different strategy when you serve XML. Consider your application architecture
carefully before deciding to bundle all your processing into single controllers.
Rails makes it simple to develop an application that is based on resourcebased routing. Many claim it greatly simplifies the coding of their applications.
However, it isn’t always appropriate. Don’t feel compelled to use it if you can’t
find a way of making it work. And you can always mix and match. Some
controllers can be resource based, and others can be based on actions. Some
controllers can even be resource based with a few extra actions.

Testing Routes
So far we’ve been exploring routes by viewing them using rake routes. When it
comes time to roll out an application, though, we might want to be a little
more formal and include unit tests that verify our routes work as expected.
Rails includes a number of test helpers that make this easy:
assert_generates(path, options, defaults={}, extras={}, message=nil)

Verifies that the given set of options generates the specified path.
Download rails32/depot_t/test/unit/routing_test.rb
def test_generates
assert_generates("/", controller: "store", action: "index")
assert_generates("/products",
{ controller: "products", action: "index"})
assert_generates("/line_items",
{ controller: "line_items", action: "create",
product_id: "1"},
{method: :post}, { product_id: "1"})
end

The extras parameter is used to tell the request the names and values of
additional request parameters (in the third assertion in the previous code,
this would be product_id=1). The test framework does not add these as
strings to the generated URL; instead, it tests that the values it would
have added appear in the extras hash.
The defaults parameter can be used to specify the HTTP method.

report erratum • discuss

318

•

Chapter 20. Action Dispatch and Action Controller

assert_recognizes(options, path, extras={}, message=nil)

Verifies that routing returns a specific set of options given a path.
Download rails32/depot_t/test/unit/routing_test.rb
def test_recognizes
# Check the default index action gets generated
assert_recognizes({"controller" => "store", "action" => "index"}, "/")
# Check routing to an action
assert_recognizes({"controller" => "products", "action" => "index"},
"/products")
# And routing with a parameter
assert_recognizes({ "controller" => "line_items",
"action" => "create",
"product_id" => "1" },
{path: "/line_items", method: :post},
{"product_id" => "1"})
end

The path parameter lets you specify routes that are conditional on the
HTTP verb of the request. You can test these by passing a hash, rather
than a string, as the second parameter to assert_recognizes. The hash should
contain two elements: :path will contain the incoming request path, and
:method will contain the HTTP verb to be used.
The extras parameter again contains the additional URL parameters. In
the third assertion in the preceding code example, we use the extras parameter to verify that had the URL ended ?product_id=1, the resulting params
hash would contain the appropriate values.
assert_routing(path, options, defaults={}, extras={}, message=nil)

Combines the previous two assertions, verifying that the path generates
the options and then that the options generate the path.
Download rails32/depot_t/test/unit/routing_test.rb
def test_routing
assert_routing("/", controller: "store", action: "index")
assert_routing("/products", controller: "products", action: "index")
assert_routing({path: "/line_items", method: :post},
{ controller: "line_items", action: "create",
product_id: "1"},
{}, { product_id: "1"})
end

It’s important to use symbols as the keys and use strings as the values in the
options hash. If you don’t, asserts that compare your options with those
returned by routing will fail.

report erratum • discuss

Processing of Requests

•

319

20.2 Processing of Requests
In the previous section, we worked out how Action Dispatch routes an incoming request to the appropriate code in your application. Now let’s see what
happens inside that code.

Action Methods
When a controller object processes a request, it looks for a public instance
method with the same name as the incoming action. If it finds one, that
method is invoked. If it doesn’t find one and the controller implements
method_missing(), that method is called, passing in the action name as the first
parameter and an empty argument list as the second. If no method can be
called, the controller looks for a template named after the current controller
and action. If found, this template is rendered directly. If none of these things
happens, an AbstractController::ActionNotFound error is generated.

Controller Environment
The controller sets up the environment for actions (and, by extension, for the
views that they invoke). Many of these methods provide direct access to information contained in the URL or request.
action_name

The name of the action currently being processed.
cookies

The cookies associated with the request. Setting values into this object
stores cookies on the browser when the response is sent. Rails support
for sessions is based on cookies. We discuss sessions in Rails Sessions,
on page 330.
headers

A hash of HTTP headers that will be used in the response. By default,
Cache-Control is set to no-cache. You might want to set Content-Type headers for
special-purpose applications. Note that you shouldn’t set cookie values
in the header directly—use the cookie API to do this.
params

A hash-like object containing request parameters (along with pseudoparameters generated during routing). It’s hash-like because you can index
entries using either a symbol or a string—params[:id] and params['id'] return
the same value. Idiomatic Rails applications use the symbol form.

report erratum • discuss

320

•

Chapter 20. Action Dispatch and Action Controller

request

The incoming request object. It includes these attributes:
• request_method returns the request method, one of :delete, :get, :head, :post,
or :put.
• method returns the same value as request_method except for :head, which
it returns as :get because these two are functionally equivalent from
an application point of view.
• delete?, get?, head?, post?, and put? return true or false based on the request
method.
• xml_http_request? and xhr? return true if this request was issued by one
of the Ajax helpers. Note that this parameter is independent of the
method parameter.
• url(), which returns the full URL used for the request.
• protocol(), host(), port(), path(), and query_string(), which returns components
of the URL used for the request, based on the following pattern: protocol://host:port/path?query_string.
• domain(), which returns the last two components of the domain name
of the request.
• host_with_port(), which is a host:port string for the request.
• port_string(), which is a :port string for the request if the port is not the
default port (80 for HTTP, 443 for HTTPS).
• ssl?(), which is true if this is an SSL request; in other words, the request
was made with the HTTPS protocol.
• remote_ip(), which returns the remote IP address as a string. The string
may have more than one address in it if the client is behind a proxy.
• env(), the environment of the request. You can use this to access values
set by the browser, such as this:
request.env['HTTP_ACCEPT_LANGUAGE']

• accepts(), which is an array with Mime::Type objects that represent the
MIME types in the Accept header.
• format(), which is computed based on the value of the Accept header,
with Mime::HTML as a fallback.

report erratum • discuss

Processing of Requests

•

321

• content_type(), which is the MIME type for the request. This is useful for
put and post requests.
• headers(), which is the complete set of HTTP headers.
• body(), which is the request body as an I/O stream.
• content_length(), which is the number of bytes purported to be in the
body.
Rails leverages a gem named Rack to provide much of this functionality.
See the documentation of Rack::Request for full details.
response

The response object, filled in during the handling of the request. Normally,
this object is managed for you by Rails. As we’ll see when we look at filters
in Filters, on page 337, we sometimes access the internals for specialized
processing.
session

A hash-like object representing the current session data. We describe this
in Rails Sessions, on page 330.
In addition, a logger is available throughout Action Pack.

Responding to the User
Part of the controller’s job is to respond to the user. There are basically four
ways of doing this:
• The most common way is to render a template. In terms of the MVC
paradigm, the template is the view, taking information provided by the
controller and using it to generate a response to the browser.
• The controller can return a string directly to the browser without invoking
a view. This is fairly rare but can be used to send error notifications.
• The controller can return nothing to the browser. This is sometimes used
when responding to an Ajax request. In all cases, however, the controller
returns a set of HTTP headers, because some kind of response is expected.
• The controller can send other data to the client (something other than
HTML). This is typically a download of some kind (perhaps a PDF document or a file’s contents).
A controller always responds to the user exactly one time per request. This
means that you should have just one call to a render(), redirect_to(), or send_xxx ()

report erratum • discuss

322

•

Chapter 20. Action Dispatch and Action Controller

method in the processing of any request. (A DoubleRenderError exception is thrown
on the second render.)
Because the controller must respond exactly once, it checks to see whether
a response has been generated just before it finishes handling a request. If
not, the controller looks for a template named after the controller and action
and automatically renders it. This is the most common way that rendering
takes place. You may have noticed that in most of the actions in our shopping
cart tutorial we never explicitly rendered anything. Instead, our action
methods set up the context for the view and return. The controller notices
that no rendering has taken place and automatically invokes the appropriate
template.
You can have multiple templates with the same name but with different
extensions (for example, .html.erb, .xml.builder, and .js.coffee). If you don’t specify
an extension in a render request, Rails assumes html.erb.

Rendering Templates
A template is a file that defines the content of a response for our application.
Rails supports three template formats out of the box: erb, which is embedded
Ruby code (typically with HTML); builder, a more programmatic way of constructing XML content; and RJS, which generates JavaScript. We’ll talk about
the contents of these files starting in Section 21.1, Using Templates, on page
341.
By convention, the template for action action of controller controller will be in
the file app/views/controller/action.type.xxx (where type is the file type, such as html,
atom, or js; and xxx is one of erb, builder, coffee or scss). The app/views part of the
name is the default. You can override this for an entire application by setting
this:
ActionController.prepend_view_path dir_path

The render() method is the heart of all rendering in Rails. It takes a hash of
options that tell it what to render and how to render it.
It is tempting to write code in our controllers that looks like this:
# DO NOT DO THIS
def update
@user = User.find(params[:id])
if @user.update_attributes(params[:user])
render action: show
end
render template: "fix_user_errors"
end

report erratum • discuss

Processing of Requests

•

323

It seems somehow natural that the act of calling render (and redirect_to) should
somehow terminate the processing of an action. This is not the case. The
previous code will generate an error (because render is called twice) in the case
where update_attributes succeeds.
Let’s look at the render options used in the controller here (we’ll look separately
at rendering in the view starting in Partial-Page Templates, on page 363):
render()

With no overriding parameter, the render() method renders the default
template for the current controller and action. The following code will
render the template app/views/blog/index.html.erb:
class BlogController < ApplicationController
def index
render
end
end

So will the following (as the default behavior of a controller is to call render()
if the action doesn’t):
class BlogController < ApplicationController
def index
end
end

And so will this (because the controller will call a template directly if no
action method is defined):
class BlogController < ApplicationController
end

render(text: string)

Sends the given string to the client. No template interpretation or HTML
escaping is performed.
class HappyController < ApplicationController
def index
render(text: "Hello there!")
end
end

render(inline: string, [ type: "erb"|"builder"|"coffee"|"scss" ], [ locals: hash] )

Interprets string as the source to a template of the given type, rendering
the results back to the client. You can use the :locals hash to set the values
of local variables in the template.

report erratum • discuss

324

•

Chapter 20. Action Dispatch and Action Controller

The following code adds method_missing() to a controller if the application
is running in development mode. If the controller is called with an invalid
action, this renders an inline template to display the action’s name and
a formatted version of the request parameters.
class SomeController < ApplicationController
if RAILS_ENV == "development"
def method_missing(name, *args)
render(inline: %{
<h2>Unknown action: #{name}</h2>
Here are the request parameters:<br/>
<%= debug(params) %> })
end
end
end

render(action: action_name)

Renders the template for a given action in this controller. Sometimes folks
use the :action form of render() when they should use redirects. See the
discussion starting in Redirects, on page 327 for why this is a bad idea.
def display_cart
if @cart.empty?
render(action: :index)
else
# ...
end
end

Note that calling render(:action...) does not call the action method; it simply
displays the template. If the template needs instance variables, these
must be set up by the method that calls the render() method.
Let’s repeat this, because this is a mistake that beginners often make:
calling render(:action...) does not invoke the action method. It simply renders
that action’s default template.
render(template: name, [locals: hash] )

Renders a template and arranges for the resulting text to be sent back to
the client. The :template value must contain both the controller and action
parts of the new name, separated by a forward slash. The following code
will render the template app/views/blog/short_list:
class BlogController < ApplicationController
def index
render(template: "blog/short_list")
end
end

report erratum • discuss

Processing of Requests

•

325

render(partial: name, …)

Renders a partial template. We talk about partial templates in depth in
Partial-Page Templates, on page 363.
render(nothing: true)

Returns nothing—sends an empty body to the browser.
render(xml: stuff)

Renders stuff as text, forcing the content type to be application/xml.
render(json: stuff, [callback: hash] )

Renders stuff as JSON, forcing the content type to be application/json.
Specifying :callback will cause the result to be wrapped in a call to the
named callback function.
render(:update) do |page| ... end

Renders the block as an RJS template, passing in the page object.
render(:update) do |page|
page[:cart].replace_html partial: 'cart', object: @cart
page[:cart].visual_effect :blind_down if @cart.total_items == 1
end

All forms of render() take optional :status, :layout, and :content_type parameters.
The :status parameter provides the value used in the status header in the HTTP
response. It defaults to "200 OK". Do not use render() with a 3xx status to do
redirects; Rails has a redirect() method for this purpose.
The :layout parameter determines whether the result of the rendering will be
wrapped by a layout. (We first came across layouts in Section 8.2, Iteration
C2: Adding a Page Layout, on page 96. We’ll look at them in depth starting
in Section 21.6, Reducing Maintenance with Layouts and Partials, on page 358.)
If the parameter is false, no layout will be applied. If set to nil or true, a layout
will be applied only if there is one associated with the current action. If the
:layout parameter has a string as a value, it will be taken as the name of the
layout to use when rendering. A layout is never applied when the :nothing option
is in effect.
The :content_type parameter lets you specify a value that will be passed to the
browser in the Content-Type HTTP header.
Sometimes it is useful to be able to capture what would otherwise be sent to
the browser in a string. The render_to_string() method takes the same parameters
as render() but returns the result of rendering as a string—the rendering is not
stored in the response object and so will not be sent to the user unless you
take some additional steps. Calling render_to_string does not count as a real

report erratum • discuss

326

•

Chapter 20. Action Dispatch and Action Controller

render. You can invoke the real render method later without getting a DoubleRender
error.

Sending Files and Other Data
We’ve looked at rendering templates and sending strings in the controller.
The third type of response is to send data (typically, but not necessarily, file
contents) to the client.

send_data
Sends a string containing binary data to the client.
send_data(data, options…)
Sends a data stream to the client. Typically the browser will use a combination
of the content type and the disposition, both set in the options, to determine
what to do with this data.
def sales_graph
png_data = Sales.plot_for(Date.today.month)
send_data(png_data, type: "image/png", disposition: "inline")
end

Options:
:disposition

string

Suggests to the browser that the file should be displayed inline (option
inline) or downloaded and saved (option attachment, the default).

:filename

string

A suggestion to the browser of the default filename to use when saving
this data.

:status

string

The status code (defaults to "200 OK").

:type

string

The content type, defaulting to application/octet-stream.

:url_based_filename boolean If true and :filename is not set, this option prevents Rails from providing
the basename of the file in the Content-Disposition header. Specifying
this is necessary in order to make some browsers handle i18n filenames
correctly.

send_file
Sends the contents of a file to the client.
send_file(path, options…)
Sends the given file to the client. The method sets the Content-Length, Content-Type, Content-Disposition, and Content-Transfer-Encoding headers.
Options:
:buffer_size number

The amount sent to the browser in each write if streaming is enabled (:stream
is true).

report erratum • discuss

Processing of Requests

•

327

:disposition string

Suggests to the browser that the file should be displayed inline (option inline)
or downloaded and saved (option attachment, the default).

:filename

string

A suggestion to the browser of the default filename to use when saving the
file. If not set, defaults to the filename part of path.

:status

string

The status code (defaults to "200 OK").

:stream

true or false If false, the entire file is read into server memory and sent to the client.
Otherwise, the file is read and written to the client in :buffer_size chunks.

:type

string

The content type, defaulting to application/octet-stream.

You can set additional headers for either send_ method by using the headers
attribute in the controller.
def send_secret_file
send_file("/files/secret_list")
headers["Content-Description"] = "Top secret"
end

We show how to upload files starting in Section 21.4, Uploading Files to Rails
Applications, on page 348.

Redirects
An HTTP redirect is sent from a server to a client in response to a request. In
effect, it says, “I can’t handle this request, but here’s some URL that can.”
The redirect response includes a URL that the client should try next along
with some status information saying whether this redirection is permanent
(status code 301) or temporary (307). Redirects are sometimes used when
web pages are reorganized; clients accessing pages in the old locations will
get referred to the page’s new home. More commonly, Rails applications use
redirects to pass the processing of a request off to some other action.
Redirects are handled behind the scenes by web browsers. Normally, the only
way you’ll know that you’ve been redirected is a slight delay and the fact that
the URL of the page you’re viewing will have changed from the one you
requested. This last point is important—as far as the browser is concerned,
a redirect from a server acts pretty much the same as having an end user
enter the new destination URL manually.
Redirects turn out to be important when writing well-behaved web applications. Let’s look at a simple blogging application that supports comment
posting. After a user has posted a comment, our application should redisplay
the article, presumably with the new comment at the end.
It’s tempting to code this using logic such as the following:

report erratum • discuss

328

•

Chapter 20. Action Dispatch and Action Controller

class BlogController
def display
@article = Article.find(params[:id])
end
def add_comment
@article = Article.find(params[:id])
comment = Comment.new(params[:comment])
@article.comments << comment
if @article.save
flash[:note] = "Thank you for your valuable comment"
else
flash[:note] = "We threw your worthless comment away"
end
# DON'T DO THIS
render(action: 'display')
end
end

The intent here was clearly to display the article after a comment has been
posted. To do this, the developer ended the add_comment() method with a call
to render(action:'display'). This renders the display view, showing the updated article
to the end user. But think of this from the browser’s point of view. It sends
a URL ending in blog/add_comment and gets back an index listing. As far as the
browser is concerned, the current URL is still the one that ends in
blog/add_comment. This means that if the user hits Refresh or Reload (perhaps
to see whether anyone else has posted a comment), the add_comment URL will
be sent again to the application. The user intended to refresh the display, but
the application sees a request to add another comment. In a blog application,
this kind of unintentional double entry is inconvenient. In an online store, it
can get expensive.
In these circumstances, the correct way to show the added comment in the
index listing is to redirect the browser to the display action. We do this using
the Rails redirect_to() method. If the user subsequently hits Refresh, it will
simply reinvoke the display action and not add another comment:
def add_comment
@article = Article.find(params[:id])
comment = Comment.new(params[:comment])
@article.comments << comment
if @article.save
flash[:note] = "Thank you for your valuable comment"
else
flash[:note] = "We threw your worthless comment away"
end
➤
redirect_to(action: 'display')
end

report erratum • discuss

Processing of Requests

•

329

Rails has a simple yet powerful redirection mechanism. It can redirect to an
action in a given controller (passing parameters), to a URL (on or off the current server), or to the previous page. Let’s look at these three forms in turn.

redirect_to
Redirects to an action.
redirect_to(action: ..., options…)
Sends a temporary redirection to the browser based on the values in the options
hash. The target URL is generated using url_for(), so this form of redirect_to() has
all the smarts of Rails routing code behind it.

redirect_to
Redirects to a URL.
redirect_to(path)
Redirects to the given path. If the path does not start with a protocol (such
as http://), the protocol and port of the current request will be prepended. This
method does not perform any rewriting on the URL, so it should not be used
to create paths that are intended to link to actions in the application (unless
you generate the path using url_for or a named route URL generator).
def save
order = Order.new(params[:order])
if order.save
redirect_to action: "display"
else
session[:error_count] ||= 0
session[:error_count] += 1
if session[:error_count] < 4
self.notice = "Please try again"
else
# Give up -- user is clearly struggling
redirect_to("/help/order_entry.html")
end
end
end

redirect_to
Redirects to the referrer.
redirect_to(:back)
Redirects to the URL given by the HTTP_REFERER header in the current request.

report erratum • discuss

330

•

Chapter 20. Action Dispatch and Action Controller

def save_details
unless params[:are_you_sure] == 'Y'
redirect_to(:back)
else
...
end
end

By default all redirections are flagged as temporary (they will affect only the
current request). When redirecting to a URL, it’s possible you might want to
make the redirection permanent. In that case, set the status in the response
header accordingly:
headers["Status"] = "301 Moved Permanently"
redirect_to("http://my.new.home")

Because redirect methods send responses to the browser, the same rules
apply as for the rendering methods—you can issue only one per request.
So far, we have been looking at requests and responses in isolation. Rails also
provides a number of mechanisms that span requests.

20.3 Objects and Operations That Span Requests
While the bulk of the state that persists across requests belongs in the
database and is accessed via Active Record, some other bits of state have
different life spans and need to be managed differently. In the Depot application, while the Cart itself was stored in the database, knowledge of which cart
is the current cart was managed by sessions. Flash notices were used to
communicate simple messages such as “Can’t delete the last user” to the next
request after a redirect. And filters were used to extract locale data from the
URLs themselves.
In this section, we will explore each of these mechanisms in turn.

Rails Sessions

marshal
↪ on page 49

A Rails session is a hash-like structure that persists across requests. Unlike
raw cookies, sessions can hold any objects (as long as those objects can be
marshaled), which makes them ideal for holding state information in web
applications. For example, in our store application, we used a session to hold
the shopping cart object between requests. The Cart object could be used in
our application just like any other object. But Rails arranged things such
that the cart was saved at the end of handling each request and, more important, that the correct cart for an incoming request was restored when Rails

report erratum • discuss

Objects and Operations That Span Requests

•

331

started to handle that request. Using sessions, we can pretend that our application stays around between requests.
And that leads to an interesting question: exactly where does this data stay
around between requests? One choice is for the server to send it down to the
client as a cookie. This is the default for Rails 3.1. It places limitations on the
size and increases the bandwidth but means that there is less for the server
to manage and clean up. Note that the contents are cryptographically signed
but (by default) unencrypted, which means that users can see but not tamper
with the contents.
The other option is to store the data on the server. There are two parts to this.
First, Rails has to keep track of sessions. It does this by creating (by default)
a 32-hex character key (which means there are 1632 possible combinations).
This key is called the session id, and it’s effectively random. Rails arranges
to store this session id as a cookie (with the key _session_id) on the user’s
browser. Because subsequent requests come into the application from this
browser, Rails can recover the session id.
Second, Rails keeps a persistent store of session data on the server, indexed
by the session id. When a request comes in, Rails looks up the data store
using the session id. The data that it finds there is a serialized Ruby object.
It deserializes this and stores the result in the controller’s session attribute,
where the data is available to our application code. The application can add
to and modify this data to its heart’s content. When it finishes processing
each request, Rails writes the session data back into the data store. There it
sits until the next request from this browser comes along.
What should you store in a session? You can store anything you want, subject
to a few restrictions and caveats:
• There are some restrictions on what kinds of object you can store in a
session. The details depend on the storage mechanism you choose (which
we’ll look at shortly). In the general case, objects in a session must be
serializable (using Ruby’s Marshal functions). This means, for example, that
you cannot store an I/O object in a session.

serialize
↪ on page 49

• If you store any Rails model objects in a session, you’ll have to add model
declarations for them. This causes Rails to preload the model class so
that its definition is available when Ruby comes to deserialize it from the
session store. If the use of the session is restricted to just one controller,
this declaration can go at the top of that controller.

report erratum • discuss

332

•

Chapter 20. Action Dispatch and Action Controller

David says:

The Wonders of a Cookie-Based Session
The default Rails session store sounds like a crazy idea when you hear it at first.
You’re going to actually store the values on the client?! But what if I want to store
the nuclear launch codes in the session and I can’t have the client actually knowing
those?
Yes, the default store is not suitable for storing secrets you need to keep from the
client. But that’s actually a valuable constraint that’ll lead you to avoid the perils of
keeping complex objects that can go out of date in the session. And the paper dragon
of the nuclear launch codes is just about never a real, relevant concern.
Neither is the size constraint. Cookies can be only about 4KB big, so you can’t stuff
them with all sorts of malarkey. That again fits the best practices of storing only references, like a cart_id, not the actual cart itself.
The key security concern you should be worried about is whether the client is actually able to change the session. You want to ensure the integrity of the values that
you put. It’d be no good if the client could change his cart_id from a 5 to 8 and get
someone else’s cart. Thankfully, Rails protects you against exactly this case by signing
the session and raising an exception that warns of the tampering if it doesn’t match.
The benefits you get back is that there is no load on the database from fetching and
saving the session on every request, and there are no cleanup duties either. If you
keep your session on the filesystem or in the database, you’ll have to deal with how
to clean up stale sessions, which is a real hassle. No one likes to be on cleanup duty.
The cookie-based sessions know how to clean up after themselves. What’s not to love
about that?

class BlogController < ApplicationController
model :user_preferences
# . . .

However, if the session might get read by another controller (which is
likely in any application with multiple controllers), you’ll probably want
to add the declaration to application_controller.rb in app/controllers.
• You probably don’t want to store massive objects in session data—put
them in the database, and reference them from the session. This is particularly true for cookie-based sessions, where the overall limit is 4KB.
• You probably don’t want to store volatile objects in session data. For
example, you might want to keep a tally of the number of articles in a
blog and store that in the session for performance reasons. But, if you do
that, the count won’t get updated if some other user adds an article.

report erratum • discuss

Objects and Operations That Span Requests

•

333

It is tempting to store objects representing the currently logged-in user
in session data. This might not be wise if your application needs to be
able to invalidate users. Even if a user is disabled in the database, their
session data will still reflect a valid status.
Store volatile data in the database, and reference it from the session
instead.
• You probably don’t want to store critical information solely in session
data. For example, if your application generates an order confirmation
number in one request and stores it in session data so that it can be saved
to the database when the next request is handled, you risk losing that
number if the user deletes the cookie from their browser. Critical information needs to be in the database.
There’s one more caveat, and it’s a big one. If you store an object in session
data, then the next time you come back to that browser, your application will
end up retrieving that object. However, if in the meantime you’ve updated
your application, the object in session data may not agree with the definition
of that object’s class in your application, and the application will fail while
processing the request. There are three options here. One is to store the object
in the database using conventional models and keep just the id of the row in
the session. Model objects are far more forgiving of schema changes than the
Ruby marshaling library. The second option is to manually delete all the
session data stored on your server whenever you change the definition of a
class stored in that data.
The third option is slightly more complex. If you add a version number to
your session keys and change that number whenever you update the stored
data, you’ll only ever load data that corresponds with the current version of
the application. You can potentially version the classes whose objects are
stored in the session and use the appropriate classes depending on the session
keys associated with each request. This last idea can be a lot of work, so you’ll
need to decide whether it’s worth the effort.
Because the session store is hash-like, you can save multiple objects in it,
each with its own key.
There is no need to also disable sessions for particular actions. Because sessions are lazily loaded, simply don’t reference a session in any action in which
you don’t need a session.

report erratum • discuss

334

•

Chapter 20. Action Dispatch and Action Controller

Session Storage
Rails has a number of options when it comes to storing your session data.
Each has good and bad points. We’ll start by listing the options and then
compare them at the end.
The session_store attribute of ActionController::Base determines the session storage
mechanism—set this attribute to a class that implements the storage strategy.
This class must be defined in the ActiveSupport::Cache::Store module. You use
symbols to name the session storage strategy; the symbol is converted into
a CamelCase class name.
session_store = :cookie_store

This is the default session storage mechanism used by Rails, starting
with version 2.0. This format represents objects in their marshaled form,
which allows any serializable data to be stored in sessions but is limited
to 4KB total. This is the option we used in the Depot application.
session_store = :active_record_store

You can store your session data in your application’s database using
ActiveRecordStore. You can generate a migration that creates the sessions table
using Rake:
depot> rake db:sessions:create

Run rake db:migrate to create the actual table.
If you look at the migration file, you’ll see that Rails creates an index on
the session_id column, because it is used to look up session data. Rails also
defines a column called updated_at, so Active Record will automatically
timestamp the rows in the session table—we’ll see later why this is a good
idea.
session_store = :drb_store

DRb is a protocol that allows Ruby processes to share objects over a network connection. Using the DRbStore database manager, Rails stores
session data on a DRb server (which you manage outside the web application). Multiple instances of your application, potentially running on
distributed servers, can access the same DRb store. DRb uses Marshal to
serialize objects.
session_store = :mem_cache_store
memcached is a freely available, distributed object caching system main-

tained by Dormando.2 The Rails MemCacheStore uses Michael Granger’s
2.

http://memcached.org/

report erratum • discuss

Objects and Operations That Span Requests

•

335

Ruby interface3 to memcached to store sessions. memcached is more complex
to use than the other alternatives and is probably interesting only if you
are already using it for other reasons at your site.
session_store = :memory_store

This option stores the session data locally in the application’s memory.
Because no serialization is involved, any object can be stored in an
in-memory session. As we’ll see in a minute, this generally is not a good
idea for Rails applications.
session_store = :file_store

Session data is stored in flat files. It’s pretty much useless for Rails applications, because the contents must be strings. This mechanism supports
the additional configuration options :prefix, :suffix, and :tmpdir.

Comparing Session Storage Options
With all these session options to choose from, which should you use in your
application? As always, the answer is “It depends.”
There are few absolutes when it comes to performance, and everyone’s context
is different. Your hardware, network latencies, database choices, and possibly
even the weather will impact how all the components of session storage interact. Our best advice is to start with the simplest workable solution and then
monitor it. If it starts to slow you down, find out why before jumping out of
the frying pan.
If you’re a high-volume site, keeping the size of the session data small and
going with cookie_store is the way to go.
If we rule out memory store as being too simplistic, file store as too restrictive,
and memcached as overkill, the server-side choices boil down to CookieStore,
Active Record store, and DRb-based storage. Should you need to store more
in a session than you can with cookies, we recommend you start with an
Active Record solution. If, as your application grows, you find this becoming
a bottleneck, you can migrate to a DRb-based solution.

Session Expiry and Cleanup
One problem with all the server-side session storage solutions is that each
new session adds something to the session store. This means you’ll eventually
need to do some housekeeping or you’ll run out of server resources.

3.

Available from http://deveiate.org/projects/RMemCache

report erratum • discuss

336

•

Chapter 20. Action Dispatch and Action Controller

There’s another reason to tidy up sessions. Many applications don’t want a
session to last forever. Once a user has logged in from a particular browser,
the application might want to enforce a rule that the user stays logged in
only as long as they are active; when they log out or some fixed time after
they last use the application, their session should be terminated.
You can sometimes achieve this effect by expiring the cookie holding the
session id. However, this is open to end-user abuse. Worse, it is hard to
synchronize the expiry of a cookie on the browser with the tidying up of the
session data on the server.
We therefore suggest that you expire sessions by simply removing their serverside session data. Should a browser request subsequently arrive containing
a session id for data that has been deleted, the application will receive no
session data; the session will effectively not be there.
Implementing this expiration depends on the storage mechanism being used.
For Active Record–based session storage, use the updated_at columns in the
sessions table. You can delete all sessions that have not been modified in the
last hour (ignoring daylight saving time changes) by having your sweeper task
issue SQL such as this:
delete from sessions
where now() - updated_at > 3600;

For DRb-based solutions, expiry takes place within the DRb server process.
You’ll probably want to record timestamps alongside the entries in the session
data hash. You can run a separate thread (or even a separate process) that
periodically deletes the entries in this hash.
In all cases, your application can help this process by calling reset_session() to
delete sessions when they are no longer needed (for example, when a user
logs out).

Flash: Communicating Between Actions
When we use redirect_to() to transfer control to another action, the browser
generates a separate request to invoke that action. That request will be handled by our application in a fresh instance of a controller object—instance
variables that were set in the original action are not available to the code
handling the redirected action. But sometimes we need to communicate
between these two instances. We can do this using a facility called the flash.
The flash is a temporary scratchpad for values. It is organized like a hash
and stored in the session data, so you can store values associated with keys

report erratum • discuss

Objects and Operations That Span Requests

•

337

and later retrieve them. It has one special property. By default, values stored
into the flash during the processing of a request will be available during the
processing of the immediately following request. Once that second request
has been processed, those values are removed from the flash.
Probably the most common use of the flash is to pass error and informational
strings from one action to the next. The intent here is that the first action
notices some condition, creates a message describing that condition, and
redirects to a separate action. By storing the message in the flash, the second
action is able to access the message text and use it in a view. An example of
such usage can be found in Iteration E1 on page 120.
It is sometimes convenient to use the flash as a way of passing messages into
a template in the current action. For example, our display() method might want
to output a cheery banner if there isn’t another, more pressing note. It doesn’t
need that message to be passed to the next action—it’s for use in the current
request only. To do this, it could use flash.now, which updates the flash but
does not add to the session data.
While flash.now creates a transient flash entry, flash.keep does the opposite,
making entries that are currently in the flash stick around for another request
cycle. If you pass no parameters to flash.keep, then all the flash contents are
preserved.
Flashes can store more than just text messages—you can use them to pass
all kinds of information between actions. Obviously, for longer-term information you’d want to use the session (probably in conjunction with your database)
to store the data, but the flash is great if you want to pass parameters from
one request to the next.
Because the flash data is stored in the session, all the usual rules apply. In
particular, every object must be serializable. We strongly recommend passing
only simple objects in the flash.

Filters
Filters enable you to write code in your controllers that wrap the processing
performed by actions—you can write a chunk of code once and have it be
called before or after any number of actions in your controller (or your controller’s subclasses). This turns out to be a powerful facility. Using filters, we
can implement authentication schemes, logging, response compression, and
even response customization.
Rails supports three types of filter: before, after, and around. Filters are called
just prior to and/or just after the execution of actions. Depending on how

report erratum • discuss

338

•

Chapter 20. Action Dispatch and Action Controller

you define them, they either run as methods inside the controller or are passed
the controller object when they are run. Either way, they get access to details
of the request and response objects, along with the other controller attributes.

Before and After Filters
As their names suggest, before and after filters are invoked before or after an
action. Rails maintains two chains of filters for each controller. When a controller is about to run an action, it executes all the filters on the before chain.
It executes the action before running the filters on the after chain.
Filters can be passive, monitoring activity performed by a controller. They
can also take a more active part in request handling. If a before filter returns
false, processing of the filter chain terminates, and the action is not run. A
filter may also render output or redirect requests, in which case the original
action never gets invoked.
We saw an example of using filters for authorization in the administration
part of our store example in Section 14.3, Iteration I3: Limiting Access, on
page 200. We defined an authorization method that redirected to a login screen
if the current session didn’t have a logged-in user. We then made this method
a before filter for all the actions in the administration controller.
Filter declarations also accept blocks and the names of classes. If a block is
specified, it will be called with the current controller as a parameter. If a class
is given, its filter() class method will be called with the controller as a parameter.
By default, filters apply to all actions in a controller (and any subclasses of
that controller). You can modify this with the :only option, which takes one or
more actions to be filtered, and the :except option, which lists actions to be
excluded from filtering.
The before_filter and after_filter declarations append to the controller’s chain of
filters. Use the variants prepend_before_filter() and prepend_after_filter() to put filters
at the front of the chain.
After filters can be used to modify the outbound response, changing the
headers and content if required. Some applications use this technique to
perform global replacements in the content generated by the controller’s
templates (for example, by substituting a customer’s name for the string
<customer/> in the response body). Another use might be compressing the
response if the user’s browser supports it.
Around filters wrap the execution of actions. You can write an around filter
in two different styles. In the first, the filter is a single chunk of code. That

report erratum • discuss

Objects and Operations That Span Requests

•

339

code is called before the action is executed. If the filter code invokes yield, the
action is executed. When the action completes, the filter code continues
executing.
Thus, the code before the yield is like a before filter, and the code after the yield
is the after filter. If the filter code never invokes yield, the action is not run—this
is the same as having a before filter return false.
The benefit of around filters is that they can retain context across the invocation of the action.
As well as passing around_filter the name of a method, you can pass it a block
or a filter class.
If you use a block as a filter, it will be passed two parameters: the controller
object and a proxy for the action. Use call() on this second parameter to invoke
the original action.
A second form allows you to pass an object as a filter. This object should
implement a method called filter(). This method will be passed the controller
object. It yields to invoke the action.
Like before and after filters, around filters take :only and :except parameters.
Around filters are (by default) added to the filter chain differently: the first
around filter added executes first. Subsequently added around filters will be
nested within existing around filters.

Filter Inheritance
If you subclass a controller containing filters, the filters will be run on the
child objects as well as in the parent. However, filters defined in the children
will not run in the parent.
If you don’t want a particular filter to run in a child controller, you can override
the default processing with the skip_before_filter and skip_after_filter declarations.
These accept the :only and :except parameters.
You can use skip_filter to skip any filter (before, after, and around). However,
it works only for filters that were specified as the (symbol) name of a method.
We made use of skip_before_filter in Section 14.3, Iteration I3: Limiting Access,
on page 200.

What We Just Did
We learned how Action Dispatch and Action Controller cooperate to enable
our server to respond to requests. The importance of this can’t be emphasized

report erratum • discuss

340

•

Chapter 20. Action Dispatch and Action Controller

enough. In nearly every application, this is the primary place where the creativity of your application is expressed. While Active Record and Action View
are hardly passive, our routes and our controllers are the place where the
action is.
We started this chapter by covering the concept of REST, which was the inspiration for the way in which Rails approaches routing of requests. We saw
how this provided seven basic actions as a starting point and how to add
more actions. We also saw how to select a data representation (for example,
JSON or XML). And we covered how to test routes.
We then covered the environment that Action Controller provides for your
actions, as well as the methods it provides for rendering and redirecting.
Finally, we covered sessions, flash, and filters, each of which is available for
use in your application’s controllers.
Along the way, we showed how each of these concepts were used in the Depot
application. Now that you have seen each in use and have been exposed to
the theory behind each, how you combine and use these concepts is limited
only by your own creativity.
In the next chapter, we will cover the remaining component of Action Pack,
namely, Action View, which handles the rendering of results.

report erratum • discuss

In this chapter, we’ll see
• templates,
• forms: fields and uploading files,
• helpers, and
• layouts and partials.

CHAPTER 21

Action View
We’ve seen how the routing component determines which controller to use
and how the controller chooses an action. We’ve also seen how the controller
and action between them decide what to render to the user. Normally that
rendering takes place at the end of the action, and typically it involves a
template. That’s what this chapter is all about. The ActionView module encapsulates all the functionality needed to render templates, most commonly
generating HTML, XML, or JavaScript back to the user. As its name suggests,
ActionView is the view part of our MVC trilogy.
In this chapter, we will start with templates, for which Rails provides a range
of options. We will then cover a number of different ways in which users
provide input: forms, file uploads, and links. We will complete this chapter
by looking at a number of ways to reduce maintenance using helpers, layouts,
and partials.

21.1 Using Templates
When you write a view, you’re writing a template: something that will get
expanded to generate the final result. To understand how these templates
work, we need to look at three areas:
• Where the templates go
• The environment they run in
• What goes inside them

Where Templates Go
The render() method expects to find templates in the app/views directory of the
current application. Within this directory, the convention is to have a separate
subdirectory for the views of each controller. Our Depot application, for
instance, includes products and store controllers. As a result, our application

report erratum • discuss

342

•

Chapter 21. Action View

has templates in app/views/products and app/views/store. Each directory typically
contains templates named after the actions in the corresponding controller.
You can also have templates that aren’t named after actions. You render such
templates from the controller using calls such as these:
render(action:
'fake_action_name')
render(template: 'controller/name')
render(file:
'dir/template')

The last of these allows you to store templates anywhere on your filesystem.
This is useful if you want to share templates across applications.

The Template Environment
Templates contain a mixture of fixed text and code. The code in the template
adds dynamic content to the response. That code runs in an environment
that gives it access to the information set up by the controller.
• All instance variables of the controller are also available in the template.
This is how actions communicate data to the templates.
• The controller object’s flash, headers, logger, params, request, response, and session
are available as accessor methods in the view. Apart from the flash, view
code probably should not use these directly, because the responsibility
for handling them should rest with the controller. However, we do find
this useful when debugging. For example, the following html.erb template
uses the debug() method to display the contents of the session, the details
of the parameters, and the current response:
<h4>Session</h4> <%= debug(session) %>
<h4>Params</h4>
<%= debug(params) %>
<h4>Response</h4> <%= debug(response) %>

• The current controller object is accessible using the attribute named controller. This allows the template to call any public method in the controller
(including the methods in ActionController::Base).
• The path to the base directory of the templates is stored in the attribute
base_path.

What Goes in a Template
Out of the box, Rails supports four types of templates:
• Builder templates use the Builder library to construct XML responses.
We talk more about Builder in Section 25.1, Generating XML with Builder,
on page 419.

report erratum • discuss

Generating Forms

•

343

Figure 49—Some of the common ways to enter data into forms

• CoffeeScript templates create JavaScript, which can change both the
presentation and the behavior of your content in the browser.
• ERb templates are a mixture of content and embedded Ruby. They are
typically used to generate HTML pages. We talk more about ERB in Section
25.2, Generating HTML with ERb, on page 421.
• SCSS templates create CSS stylesheets to control the presentation of your
content in the browser.
By far, the one that you will be using the most will be ERB. In fact, you made
extensive use of ERB templates in developing the Depot application.
So far in this chapter, we have focused on producing output. In Chapter 20,
Action Dispatch and Action Controller, on page 307, we focused on processing
input. In a well-designed application, these two are not unrelated: the output
we produce contains forms, links, and buttons that guide the end user to
producing the next set of inputs. As you might expect by now, Rails provides
considerable amount of help in this area too.

21.2 Generating Forms
HTML provides a number of elements, attributes, and attribute values that
control how input is gathered. You certainly could hand-code your form
directly into the template, but there really is no need to do that.

report erratum • discuss

344

•

Chapter 21. Action View

In this section, we will cover a number of helpers that Rails provides that
assist with this process. In Section 21.5, Using Helpers, on page 351, we will
show you how you can create your own helpers.
HTML provides a number of ways to collect data in forms. A few of the more
common means are shown in Figure 49, Some of the common ways to enter
data into forms, on page 343. Note that the form itself is not representative of
any sort of typical use; in general, you will use only a subset of these methods
to collect data.
Let’s look at the template that was used to produce that form:
Line 1
5

Download rails32/views/app/views/form/input.html.erb
<%= form_for(:model) do |form| %>
<p>
<%= form.label :input %>
<%= form.text_field :input, :placeholder => 'Enter text here...' %>
</p>

10

<p>
<%= form.label :address, :style => 'float: left' %>
<%= form.text_area :address, :rows => 3, :cols => 40 %>
</p>

15
20

<p>
<%=
<%=
<%=
<%=
<%=
<%=
<%=
</p>

form.label :color %>:
form.radio_button :color, 'red' %>
form.label :red %>
form.radio_button :color, 'yellow' %>
form.label :yellow %>
form.radio_button :color, 'green' %>
form.label :green %>

<p>
<%=
<%=
<%=
<%=
<%=
<%=
<%=
</p>

form.label 'condiment' %>:
form.check_box :ketchup %>
form.label :ketchup %>
form.check_box :mustard %>
form.label :mustard %>
form.check_box :mayonnaise %>
form.label :mayonnaise %>

25
30
35

<p>
<%= form.label :priority %>:
<%= form.select :priority, (1..10) %>
</p>

-

<p>

report erratum • discuss

Generating Forms

40

•

345

<%= form.label :start %>:
<%= form.date_select :start %>
</p>

45
-

<p>
<%= form.label :alarm %>:
<%= form.time_select :alarm %>
</p>
<% end %>

In that template, you will see a number of labels, such as the one on line 3.
You use labels to associate text with an input field for a specified attribute.
The text of the label will default to the attribute name unless you specify it
explicitly.
You use the text_field() and text_area() helpers (on lines 4 and 9, respectively) to
gather single-line and multiline input fields. You may specify a placeholder,
which will be displayed inside the field until the user provides a value. Not
every browser supports this function, but those that don’t simply will display
an empty box. Since this will degrade gracefully, there is no need for you to
design to the least common denominator—make use of this feature, because
those who can see it will benefit from it immediately.
Placeholders are one of the many small “fit and finish” features provided with
HTML5, and once again, Rails is ready even if the browser your users have
installed is not. You can use the search_field(), telephone_field(), url_field(), email_field(),
number_field(), and range_field() helpers to prompt for a specific type of input. How
the browser will make use of this information varies. Some may display the
field slightly differently in order to more clearly identify its function. Safari
on Mac, for example, will display search fields with rounded corners and will
insert a little x for clearing the field once data entry begins. Some may provide
added validation. For example, Opera will validate URL fields prior to submission. The iPad will even adjust the virtual on-screen keyboard to provide ready
access to characters such as the @ sign when entering an email address.
Although the support for these functions varies by browser, those that don’t
provide extra support for these functions simply display a plain, unadorned
input box. Once again, nothing is gained by waiting. If you have an input field
that’s expected to contain an email address, don’t simply use text_field()—go
ahead and start using email_field() now.
Lines 14, 24, and 34 demonstrate three different ways to provide a constrained
set of options. Although the display may vary a bit from browser to browser,
these approaches are all well supported across all browsers. The select() method
is particularly flexible—it can be passed a simple Enumeration as shown here,

report erratum • discuss

346

•

Chapter 21. Action View

an array of pairs of name/value pairs, or a Hash. A number of form options
helpers1 are available to produce such lists from various sources, including
the database.
Finally, lines 39 and 44 show prompts for a date and time, respectively. As
you might expect by now, Rails provides plenty of options here too.2
Not shown in this example are hidden_field() and password_field(). A hidden field is
not displayed at all, but the value is passed back to the server. This may be
useful as an alternative to storing transient data in sessions, enabling data
from one request to be passed onto the next. Password fields are displayed,
but the text entered in them is obscured.
This is more than an adequate starter set for most needs. Should you find
that you have additional needs, you are quite likely to find a helper or plugin
is already available for you. A good place to start is with the Rails Guides.3
Meanwhile, let’s explore how the data forms submit is processed.

21.3 Processing Forms
In Figure 50, Models, controllers, and views work together., on page 347, we
can see how the various attributes in the model pass through the controller
to the view, on to the HTML page, and back again into the model. The model
object has attributes such as name, country, and password. The template uses
helper methods to construct an HTML form to let the user edit the data in
the model. Note how the form fields are named. The country attribute, for
example, maps to an HTML input field with the name user[country].
When the user submits the form, the raw POST data is sent back to our
application. Rails extracts the fields from the form and constructs the params
hash. Simple values (such as the id field, extracted by routing from the form
action) are stored directly in the hash. But, if a parameter name has brackets
in it, Rails assumes that it is part of more structured data and constructs a
hash to hold the values. Inside this hash, the string inside the brackets acts
as the key. This process can repeat if a parameter name has multiple sets of
brackets in it.
Form parameters
id=123

1.
2.
3.

params

{ id: "123" }

http://api.rubyonrails.org/classes/ActionView/Helpers/FormOptionsHelper.html
http://api.rubyonrails.org/classes/ActionView/Helpers/DateHelper.html
http://guides.rubyonrails.org/form_helpers.html

report erratum • discuss

Processing Forms

•

347

➊ myapp_controller.rb

def edit
@user = User.ﬁnd(params[:id])
end

➋ edit.html.erb
<% form_for :user,
:url => { :action => 'save', :id => @user } do |f| %>
<%= f.text_ﬁeld
'name' %></p>
<%= f.text_ﬁeld
'country' %></p>
<%= f.password_ﬁeld 'password' %></p>
...
<% end %>

➊ The application receives a request

to edit a user. It reads the data into
a new User model object.

➋ The edit.html.erb template is

called. It uses the information in
the user object to generate...

➌ <form action="/myapp/save/1234">
<input name="user[name]" ... >
<input name="user[country]" ... >
<input name="user[password]" ... >
...
</form>

➌ the HTML is sent to the browser.

When the response is received...

➍ the parameters are extracted into a
nested hash.

➎ The save action uses the

parameters to ﬁnd the user record
and update it.

➎ def save
user = User.ﬁnd(params[:id])
if user.update_attributes(params[:user])
...
end
end

➍

@params = {
:id => 1234,
:user => {
:name => " ... ",
:country => " ... ",
:password => " ... " }
}

Figure 50—Models, controllers, and views work together.

Form parameters

params

user[name]=Dave

{ user: { name: "Dave" }}

user[address][city]=Wien

{ user: { address: { city: "Wien" }}}

In the final part of the integrated whole, model objects can accept new attribute
values from hashes, which allows us to say this:
user.update_attributes(params[:user])

Rails integration goes deeper than this. Looking at the .html.erb file in Figure
50, Models, controllers, and views work together., on page 347, we can see that
the template uses a set of helper methods to create the form’s HTML; these
are methods such as form_for() and text_field().

report erratum • discuss

348

•

Chapter 21. Action View

Before moving on, it is worth noting that params may be used for more than
simple text. Entire files can be uploaded. We’ll cover that next.

21.4 Uploading Files to Rails Applications
Your application may allow users to upload files. For example, a bug-reporting
system might let users attach log files and code samples to a problem ticket,
or a blogging application could let its users upload a small image to appear
next to their articles.
In HTTP, files are uploaded as a multipart/form-data POST message. As the
name suggests, forms are used to generate this type of message. Within that
form, you’ll use one or more <input> tags with type="file". When rendered by a
browser, this tag allows the user to select a file by name. When the form is
subsequently submitted, the file or files will be sent back along with the rest
of the form data.
To illustrate the file upload process, we’ll show some code that allows a user
to upload an image and display that image alongside a comment. To do this,
we first need a pictures table to store the data:
Download rails32/e1/views/db/migrate/20110711000004_create_pictures.rb
class CreatePictures < ActiveRecord::Migration
def change
create_table :pictures do |t|
t.string :comment
t.string :name
t.string :content_type
# If using MySQL, blobs default to 64k, so we have to give
# an explicit size to extend them
t.binary :data, :limit => 1.megabyte
end
end
end

We’ll create a somewhat artificial upload controller just to demonstrate the
process. The get action is pretty conventional; it simply creates a new picture
object and renders a form:
Download rails32/e1/views/app/controllers/upload_controller.rb
class UploadController < ApplicationController
def get
@picture = Picture.new
end
# . . .
end

report erratum • discuss

Uploading Files to Rails Applications

•

349

The get template contains the form that uploads the picture (along with a
comment). Note how we override the encoding type to allow data to be sent
back with the response:
Download rails32/e1/views/app/views/upload/get.html.erb
<% form_for(:picture,
url: {action: 'save'},
html: {multipart: true}) do |form| %>
Comment:
<%= form.text_field("comment") %><br/>
Upload your picture: <%= form.file_field("uploaded_picture") %><br/>
<%= submit_tag("Upload file") %>
<% end %>

The form has one other subtlety. The picture uploads into an attribute called
uploaded_picture. However, the database table doesn’t contain a column of that
name. That means that there must be some magic happening in the model.
Download rails32/e1/views/app/models/picture.rb
class Picture < ActiveRecord::Base
validates_format_of :content_type,
with: /^image/,
message: "--- you can only upload pictures"
def uploaded_picture=(picture_field)
self.name
= base_part_of(picture_field.original_filename)
self.content_type = picture_field.content_type.chomp
self.data
= picture_field.read
end
def base_part_of(file_name)
File.basename(file_name).gsub(/[^\w._-]/, '')
end
end

We define an accessor called uploaded_picture=() to receive the file uploaded by
the form. The object returned by the form is an interesting hybrid. It is filelike, so we can read its contents with the read() method; that’s how we get the
image data into the data column. It also has the attributes content_type and
original_filename, which let us get at the uploaded file’s metadata. Accessor
methods pick all this apart, resulting in a single object stored as separate
attributes in the database.
Note that we also add a simple validation to check that the content type is of
the form image/xxx. We don’t want someone uploading JavaScript.
The save action in the controller is totally conventional:

report erratum • discuss

350

•

Chapter 21. Action View

Download rails32/e1/views/app/controllers/upload_controller.rb
def save
@picture = Picture.new(params[:picture])
if @picture.save
redirect_to(action: 'show', id: @picture.id)
else
render(action: :get)
end
end

So, now that we have an image in the database, how do we display it? One
way is to give it its own URL and simply link to that URL from an image tag.
For example, we could use a URL such as upload/picture/123 to return the image
for picture 123. This would use send_data() to return the image to the browser.
Note how we set the content type and filename—this lets browsers interpret
the data and supplies a default name should the user choose to save the
image:
Download rails32/e1/views/app/controllers/upload_controller.rb
def picture
@picture = Picture.find(params[:id])
send_data(@picture.data,
filename: @picture.name,
type: @picture.content_type,
disposition: "inline")
end

Finally, we can implement the show action, which displays the comment and
the image. The action simply loads the picture model object:
Download rails32/e1/views/app/controllers/upload_controller.rb
def show
@picture = Picture.find(params[:id])
end

In the template, the image tag links back to the action that returns the picture
content. In Figure 51, Uploading a file, on page 351, we can see the get and
show actions in all their glory:
Download rails32/e1/views/app/views/upload/show.html.erb
<h3><%= @picture.comment %></h3>
<img src="<%= url_for(:action => 'picture', :id => @picture.id) %>"/>

You can optimize the performance of this technique by caching the picture
action. (We discuss caching starting in Section 22.2, Page Caching, on page
374.)

report erratum • discuss

Using Helpers

•

351

Figure 51—Uploading a file

If you’d like an easier way of dealing with uploading and storing images, take
a look at thoughtbot’s Paperclip4 or Rick Olson’s attachment_fu5 plugins.
Create a database table that includes a given set of columns (documented on
Rick’s site), and the plugin will automatically manage storing both the uploaded data and the upload’s metadata. Unlike our previous approach, it handles
storing the uploads in either your filesystem or a database table.
Forms and uploads are just two examples of helpers that Rails provides. Next
we will show you how you can provide your own helpers and introduce you
to a number of other helpers that come with Rails.

21.5 Using Helpers
Earlier we said that it’s OK to put code in templates. Now we’re going to
modify that statement. It’s perfectly acceptable to put some code in templates—that’s what makes them dynamic. However, it’s poor style to put too
much code in templates.
There are three main reasons for this. First, the more code you put in the
view side of your application, the easier it is to let discipline slip and start
adding application-level functionality to the template code. This is definitely
poor form; you want to put application stuff in the controller and model layers
so that it is available everywhere. This will pay off when you add new ways
of viewing the application.
The second reason is that html.erb is basically HTML. When you edit it, you’re
editing an HTML file. If you have the luxury of having professional designers

4.
5.

https://github.com/thoughtbot/paperclip#readme
https://github.com/technoweenie/attachment_fu

report erratum • discuss

352

•

Chapter 21. Action View

create your layouts, they’ll want to work with HTML. Putting a bunch of Ruby
code in there just makes it hard to work with.
The final reason is that code embedded in views is hard to test, whereas code
split out into helper modules can be isolated and tested as individual units.
Rails provides a nice compromise in the form of helpers. A helper is simply a
module containing methods that assist a view. Helper methods are outputcentric. They exist to generate HTML (or XML, or JavaScript)—a helper extends
the behavior of a template.

Your Own Helpers
By default, each controller gets its own helper module. Additionally, there is
an application-wide helper named application_helper.rb. It won’t be surprising to
learn that Rails makes certain assumptions to help link the helpers into the
controller and its views. While all view helpers are available to all controllers,
it often is good practice to organize helpers. Helpers that are unique to the
views associated with the ProductController tend to be placed in a helper module
called ProductHelper in the file product_helper.rb in the app/helpers directory. You don’t
have to remember all these details—the rails generate controller script creates a
stub helper module automatically.
In Section 11.4, Iteration F4: Hiding an Empty Cart, on page 143, we created
such a helper method named hidden_div_if(), which enabled us to hide the cart
under specified conditions. We can use the same technique to clean up the
application layout a bit. At the present time we have the following:
<h3><%= @page_title || "Pragmatic Store" %></h3>

Let’s move the code that works out the page title into a helper method. Because
we’re in the store controller, we edit the file store_helper.rb in app/helpers.
module StoreHelper
def page_title
@page_title || "Pragmatic Store"
end
end

Now the view code simply calls the helper method:
<h3><%= page_title %></h3>

(We might want to eliminate even more duplication by moving the rendering
of the entire title into a separate partial template, shared by all the controller’s
views, but we don’t talk about partial templates until Partial-Page Templates,
on page 363.)

report erratum • discuss

Using Helpers

•

353

Helpers for Formatting and Linking
Rails comes with a bunch of built-in helper methods, available to all views.
In this section, we’ll touch on the highlights, but you’ll probably want to look
at the Action View RDoc for the specifics—there’s a lot of functionality in
there.

Formatting Helpers
One set of helper methods deals with dates, numbers, and text.
<%= distance_of_time_in_words(Time.now, Time.local(2010, 12, 25)) %>

9 months
<%= distance_of_time_in_words(Time.now, Time.now + 33, false) %>

1 minute
<%= distance_of_time_in_words(Time.now, Time.now + 33, true) %>

Half a minute
<%= time_ago_in_words(Time.local(2010, 12, 25)) %>

9 months
<%= number_to_currency(123.45) %>

$123.45
<%= number_to_currency(234.56, unit: "CAN$", precision: 0) %>

CAN$235
<%= number_to_human_size(123_456) %>

120.6 KB
<%= number_to_percentage(66.66666) %>

66.667%
<%= number_to_percentage(66.66666, precision: 1) %>

66.7%
<%= number_to_phone(2125551212) %>

212-555-1212
<%= number_to_phone(2125551212, area_code: true, delimiter: " ") %>

(212) 555 1212
<%= number_with_delimiter(12345678) %>

12,345,678
<%= number_with_delimiter(12345678, delimiter: "_") %>

12_345_678

report erratum • discuss

354

•

Chapter 21. Action View

<%= number_with_precision(50.0/3, precision: 2) %>

16.67
The debug() method dumps out its parameter using YAML and escapes the
result so it can be displayed in an HTML page. This can help when trying to
look at the values in model objects or request parameters.
<%= debug(params) %>
--- !ruby/hash:HashWithIndifferentAccess
name: Dave
language: Ruby
action: objects
controller: test

Yet another set of helpers deals with text. There are methods to truncate
strings and highlight words in a string.
<%= simple_format(@trees) %>

Formats a string, honoring line and paragraph breaks. You could give it
the plain text of the Joyce Kilmer poem Trees, and it would add the HTML
to format it as follows.
<p> I think that I shall never see <br />A poem lovely as a tree.</p> <p>A
tree whose hungry mouth is prest <br />Against the sweet earth’s flowing
breast; </p>
<%= excerpt(@trees, "lovely", 8) %>

...A poem lovely as a tre...
<%= highlight(@trees, "tree") %>

I think that I shall never see A poem lovely as a <strong class="highlight">tree</strong>. A <strong class="highlight">tree</strong> whose
hungry mouth is prest Against the sweet earth’s flowing breast;
<%= truncate(@trees, length: 20) %>

I think that I sh...
There’s a method to pluralize nouns.
<%= pluralize(1, "person") %> but <%= pluralize(2, "person") %>

1 person but 2 people
If you’d like to do what the fancy websites do and automatically hyperlink
URLs and email addresses, there are helpers to do that. There’s another that
strips hyperlinks from text.

report erratum • discuss

Using Helpers

•

355

Back in Iteration A2 on page 72, we saw how the cycle() helper can be used to
return the successive values from a sequence each time it’s called, repeating
the sequence as necessary. This is often used to create alternating styles for
the rows in a table or list. The current_cycle() and reset_cycle() methods are also
available.
Finally, if you’re writing something like a blog site or you’re allowing users to
add comments to your store, you could offer them the ability to create their
text in Markdown (BlueCloth)6 or Textile (RedCloth)7 format. These are simple
formatters that take text with very simple, human-friendly markup and convert
it into HTML.

Linking to Other Pages and Resources
TheActionView::Helpers::AssetTagHelper and ActionView::Helpers::UrlHelper modules contain
a number of methods that let you reference resources external to the current
template. Of these, the most commonly used is link_to(), which creates a hyperlink to another action in your application:
<%= link_to "Add Comment", new_comments_path %>

The first parameter to link_to() is the text displayed for the link. The next is a
string or hash specifying the link’s target.
An optional third parameter provides HTML attributes for the generated link:
<%= link_to "Delete", product_path(@product),
{ class: "dangerous", method: 'delete' }
%>

This third parameter also supports two additional options that modify the
behavior of the link. Each requires JavaScript to be enabled in the browser.
The :method option is a hack—it allows you to make the link look to the application as if the request were created by a POST, PUT, or DELETE, rather than
the normal GET method. This is done by creating a chunk of JavaScript that
submits the request when the link is clicked—if JavaScript is disabled in the
browser, a GET will be generated.
The :confirm option takes a short message. If present, JavaScript will be generated to display the message and get the user’s confirmation before the link
is followed:

6.
7.

https://github.com/rtomayko/rdiscount
http://redcloth.org/

report erratum • discuss

356

•

Chapter 21. Action View

<%= link_to "Delete", product_path(@product),
{ class: "dangerous",
confirm: "Are you sure?",
method: :delete}
%>

The button_to() method works the same as link_to() but generates a button in a
self-contained form, rather than a straight hyperlink. This is the preferred
method of linking to actions that have side effects. However, these buttons
live in their own forms, which imposes a couple of restrictions: they cannot
appear inline, and they cannot appear inside other forms.
Rails has conditional linking methods that generate hyperlinks if some condition is met and just return the link text otherwise. link_to_if() and link_to_unless()
take a condition parameter, followed by the regular parameters to link_to. If
the condition is true (for link_to_if) or false (for link_to_unless), a regular link will be
created using the remaining parameters. If not, the name will be added as
plain text (with no hyperlink).
The link_to_unless_current() helper creates menus in sidebars where the current
page name is shown as plain text and the other entries are hyperlinks:
<ul>
<% %w{ create list edit save logout }.each do |action| %>
<li>
<%= link_to_unless_current(action.capitalize, action: action) %>
</li>
<% end %>
</ul>

The link_to_unless_current() helper may also be passed a block that is evaluated
only if the current action is the action given, effectively providing an alternative
to the link. There also is a current_page() helper method that simply tests
whether the current request URI was generated by the given options.
As with url_for(), link_to() and friends also support absolute URLs:
<%= link_to("Help", "http://my.site/help/index.html") %>

The image_tag() helper creates <img> tags. Optional :size parameters (of the form
widthxheight), or separate width and height parameters, define the size of the
image:
<%= image_tag("/images/dave.png", class: "bevel", size: "80x120") %>
<%= image_tag("/images/andy.png", class: "bevel",
width: "80", height: "120") %>

report erratum • discuss

Using Helpers

•

357

If you don’t give an :alt option, Rails synthesizes one for you using the image’s
filename. If the image path doesn’t start with a / character, Rails assumes
that it lives under the /images directory.
You can make images into links by combining link_to() and image_tag():
<%= link_to(image_tag("delete.png", size: "50x22"),
product_path(@product),
{ confirm: "Are you sure?",
method: :delete})
%>

The mail_to() helper creates a mailto: hyperlink that, when clicked, normally
loads the client’s email application. It takes an email address, the name of
the link, and a set of HTML options. Within these options, you can also use
:bcc, :cc, :body, and :subject to initialize the corresponding email fields. Finally,
the magic option encode: "javascript" uses client-side JavaScript to obscure the
generated link, making it harder for spiders to harvest email addresses from
your site. Unfortunately, it also means your users won’t see the email link if
they have JavaScript disabled in their browsers.
<%= mail_to("support@pragprog.com", "Contact Support",
subject: "Support question from #{@user.name}",
encode: "javascript") %>

As a weaker form of obfuscation, you can use the :replace_at and :replace_dot
options to replace the at sign and dots in the displayed name with other
strings. This is unlikely to fool harvesters.
The AssetTagHelper module also includes helpers that make it easy to link to
stylesheets and JavaScript code from your pages and to create autodiscovery
Atom feed links. We created links in the layouts for the Depot application
using the stylesheet_link_tag() and javascript_link_tag() methods in the head:
Download rails32/depot_r/app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
<title>Pragprog Books Online Store</title>
<%= stylesheet_link_tag "application" %>
<%= javascript_include_tag "application" %>
<%= csrf_meta_tag %>
</head>

The stylesheet_link_tag() method can also take a parameter named :all, indicating
that all styles in the stylesheet directory will be included. Adding recursive: true
will cause Rails to include all styles in all subdirectories too.

report erratum • discuss

358

•

Chapter 21. Action View

The javascript_include_tag() method takes a list of JavaScript filenames (assumed
to live in public/javascripts) and creates the HTML to load these into a page. In
addition to :all, javascript_include_tag accepts as a parameter the value :defaults,
which acts as a shortcut and causes Rails to load jQuery.js.
An RSS or Atom link is a header field that points to a URL in our application.
When that URL is accessed, the application should return the appropriate
RSS or Atom XML:
<html>
<head>
<%= auto_discovery_link_tag(:atom, products_url(format: 'atom')) %>
</head>
. . .

Finally, the JavaScriptHelper module defines a number of helpers for working
with JavaScript. These create JavaScript snippets that run in the browser to
generate special effects and to have the page dynamically interact with our
application.
By default, image and stylesheet assets are assumed to live in the images and
stylesheets directories relative to the application’s public directory. If the path
given to an asset tag method starts with a forward slash, then the path is
assumed to be absolute, and no prefix is applied. Sometimes it makes sense
to move this static content onto a separate box or to different locations on
the current box. Do this by setting the configuration variable asset_host:
config.action_controller.asset_host = "http://media.my.url/assets"

Although this list of helpers may seem to be comprehensive, Rails provides
many more, new helpers are introduced with each release, and a select few
are retired or moved off into a plugin where they can be evolved at a different
pace than Rails itself. Now would be a good time to review the online documentation that you produced in A Place for Documentation, on page 259 to see
what other goodies Rails provides for you.

21.6 Reducing Maintenance with Layouts and Partials
So far in this chapter we’ve looked at templates as isolated chunks of code
and HTML. But one of the driving ideas behind Rails is honoring the DRY
principle and eliminating the need for duplication. The average website,
though, has lots of duplication.
• Many pages share the same tops, tails, and sidebars.
• Multiple pages may contain the same snippets of rendered HTML (a blog
site, for example, may display an article in multiple places).

report erratum • discuss

Reducing Maintenance with Layouts and Partials

•

359

• The same functionality may appear in multiple places. Many sites have
a standard search component, or a polling component, that appears in
most of the sites’ sidebars.
Rails provides both layouts and partials that reduce the need for duplication
in these three situations.

Layouts
Rails allows you to render pages that are nested inside other rendered pages.
Typically this feature is used to put the content from an action within a
standard site-wide page frame (title, footer, and sidebar). In fact, if you’ve
been using the generate script to create scaffold-based applications, then you’ve
been using these layouts all along.
When Rails honors a request to render a template from within a controller,
it actually renders two templates. Obviously, it renders the one you ask for
(or the default template named after the action if you don’t explicitly render
anything). But Rails also tries to find and render a layout template (we’ll talk
about how it finds the layout in a second). If it finds the layout, it inserts the
action-specific output into the HTML produced by the layout.
Let’s look at a layout template:
<html>
<head>
<title>Form: <%= controller.action_name %></title>
<%= stylesheet_link_tag 'scaffold' %>
</head>
<body>
<%= yield :layout %>
</body>
</html>

The layout sets out a standard HTML page, with the head and body sections.
It uses the current action name as the page title and includes a CSS file. In
the body, there’s a call to yield. This is where the magic takes place. When the
template for the action was rendered, Rails stored its content, labeling it :layout.
Inside the layout template, calling yield retrieves this text. In fact, :layout is the
default content returned when rendering, so you can write yield instead of yield
:layout. We personally prefer the slightly more explicit version.
If the my_action.html.erb template contained this:
<h1><%= @msg %></h1>

the browser would see the following HTML:

report erratum • discuss

360

•

Chapter 21. Action View

<html>
<head>
<title>Form: my_action</title>
<link href="/stylesheets/scaffold.css" media="screen"
rel="Stylesheet" type="text/css" />
</head>
<body>
<h1>Hello, World!</h1>
</body>
</html>

Locating Layout Files
As you’ve probably come to expect, Rails does a good job of providing defaults
for layout file locations, but you can override the defaults if you need something different.
Layouts are controller-specific. If the current request is being handled by a
controller called store, Rails will by default look for a layout called store (with
the usual .html.erb or .xml.builder extension) in the app/views/layouts directory. If
you create a layout called application in the layouts directory, it will be applied
to all controllers that don’t otherwise have a layout defined for them.
You can override this using the layout declaration inside a controller. At its
simplest, the declaration takes the name of a layout as a string. The following
declaration will make the template in the file standard.html.erb or standard.xml.builder
the layout for all actions in the store controller. The layout file will be looked
for in the app/views/layouts directory.
class StoreController < ApplicationController
layout "standard"
# ...
end

You can qualify which actions will have the layout applied to them using the
:only and :except qualifiers:
class StoreController < ApplicationController
layout "standard", except: [ :rss, :atom ]
# ...
end

Specifying a layout of nil turns off layouts for a controller.
Sometimes you need to change the appearance of a set of pages at runtime.
For example, a blogging site might offer a different-looking side menu if the

report erratum • discuss

Reducing Maintenance with Layouts and Partials

•

361

user is logged in, or a store site might have different-looking pages if the site
is down for maintenance. Rails supports this need with dynamic layouts. If
the parameter to the layout declaration is a symbol, it’s taken to be the name
of a controller instance method that returns the name of the layout to be
used:
class StoreController < ApplicationController
layout :determine_layout
# ...
private
def determine_layout
if Store.is_closed?
"store_down"
else
"standard"
end
end
end

Subclasses of a controller use the parent’s layout unless they override it using
the layout directive. Finally, individual actions can choose to render using a
specific layout (or with no layout at all) by passing render() the :layout option:
def rss
render(layout: false)
# never use a layout
end
def checkout
render(layout: "layouts/simple")
end

Passing Data to Layouts
Layouts have access to all the same data that’s available to conventional
templates. In addition, any instance variables set in the normal template will
be available in the layout (because the regular template is rendered before
the layout is invoked). This might be used to parameterize headings or menus
in the layout. For example, the layout might contain this:
<html>
<head>
<title><%= @title %></title>
<%= stylesheet_link_tag 'scaffold' %>
</head>
<body>
<h1><%= @title %></h1>
<%= yield :layout %>
</body>
</html>

report erratum • discuss

362

•

Chapter 21. Action View

An individual template could set the title by assigning to the @title variable:
<% @title = "My Wonderful Life" %>
<p>
Dear Diary:
</p>
<p>
Yesterday I had pizza for dinner. It was nice.
</p>

In fact, we can take this further. The same mechanism that lets us use yield
:layout to embed the rendering of a template into the layout also lets you generate arbitrary content in a template, which can then be embedded into any
other template.
For example, different templates may need to add their own template-specific
items to the standard page sidebar. We’ll use the content_for mechanism in
those templates to define content and then use yield in the layout to embed
this content into the sidebar.
In each regular template, use a content_for to give a name to the content rendered inside a block. This content will be stored inside Rails and will not
contribute to the output generated by the template.
<h1>Regular Template</h1>
<% content_for(:sidebar) do %>
<ul>
<li>this text will be rendered</li>
<li>and saved for later</li>
<li>it may contain <%= "dynamic" %> stuff</li>
</ul>
<% end %>
<p>
Here's the regular stuff that will appear on
the page rendered by this template.
</p>

Then, in the layout, you use yield :sidebar to include this block into the page’s
sidebar:
<!DOCTYPE .... >
<html>
<body>
<div class="sidebar">
<p>
Regular sidebar stuff
</p>

report erratum • discuss

Reducing Maintenance with Layouts and Partials

➤

•

363

<div class="page-specific-sidebar">
<%= yield :sidebar %>
</div>
</div>
</body>
</html>

This same technique can be used to add page-specific JavaScript functions
into the <head> section of a layout, create specialized menu bars, and so on.

Partial-Page Templates
Web applications commonly display information about the same application
object or objects on multiple pages. A shopping cart might display an order
line item on the shopping cart page and again on the order summary page.
A blog application might display the contents of an article on the main index
page and again at the top of a page soliciting comments. Typically this would
involve copying snippets of code between the different template pages.
Rails, however, eliminates this duplication with the partial-page templates
(more frequently called partials). You can think of a partial as a kind of
subroutine. You invoke it one or more times from within another template,
potentially passing it objects to render as parameters. When the partial template finishes rendering, it returns control to the calling template.
Internally, a partial template looks like any other template. Externally, there’s
a slight difference. The name of the file containing the template code must
start with an underscore character, differentiating the source of partial templates from their more complete brothers and sisters.
For example, the partial to render a blog entry might be stored in the file
_article.html.erb in the normal views directory, app/views/blog:
<div class="article">
<div class="articleheader">
<h3><%= article.title %></h3>
</div>
<div class="articlebody">
<%= article.body %>
</div>
</div>

Other templates use the render(partial:) method to invoke this:
<%= render(partial: "article", object: @an_article) %>
<h3>Add Comment</h3>
. . .

report erratum • discuss

364

•

Chapter 21. Action View

The :partial parameter to render() is the name of the template to render (but
without the leading underscore). This name must be both a valid filename
and a valid Ruby identifier (so a-b and 20042501 are not valid names for partials).
The :object parameter identifies an object to be passed into the partial. This
object will be available within the template via a local variable with the same
name as the template. In this example, the @an_article object will be passed to
the template, and the template can access it using the local variable article.
That’s why we could write things such as article.title in the partial.
Idiomatic Rails developers use a variable named after the template (article in
this instance). In fact, it’s normal to take this a step further. If the object to
be passed to the partial is in a controller instance variable with the same
name as the partial, you can omit the :object parameter. If, in the previous
example, our controller had set up the article in the instance variable @article,
the view could have rendered the partial using just this:
<%= render(partial: "article") %>
<h3>Add Comment</h3>
. . .

You can set additional local variables in the template by passing render() a :locals
parameter. This takes a hash where the entries represent the names and
values of the local variables to set.
render(partial: 'article',
object: @an_article,
locals: { authorized_by: session[:user_name],
from_ip:
request.remote_ip })

Partials and Collections
Applications commonly need to display collections of formatted entries. A blog
might show a series of articles, each with text, author, date, and so on. A
store might display entries in a catalog, where each has an image, a description, and a price.
The :collection parameter to render() works in conjunction with the :partial parameter. The :partial parameter lets us use a partial to define the format of an
individual entry, and the :collection parameter applies this template to each
member of the collection. To display a list of article model objects using our
previously defined _article.html.erb partial, we could write this:
<%= render(partial: "article", collection: @article_list) %>

Inside the partial, the local variable article will be set to the current article from
the collection—the variable is named after the template. In addition, the

report erratum • discuss

Reducing Maintenance with Layouts and Partials

•

365

variable article_counter will have its value set to the index of the current article
in the collection.
The optional :spacer_template parameter lets you specify a template that will be
rendered between each of the elements in the collection. For example, a view
might contain the following:
Download rails32/e1/views/app/views/partial/list.html.erb
<%= render(partial:
"animal",
collection:
%w{ ant bee cat dog elk },
spacer_template: "spacer")
%>

This uses _animal.html.erb to render each animal in the given list, rendering the
partial _spacer.html.erb between each. If _animal.html.erb contains this:
Download rails32/e1/views/app/views/partial/_animal.html.erb
<p>The animal is <%= animal %></p>

and _spacer.html.erb contains this:
Download rails32/e1/views/app/views/partial/_spacer.html.erb
<hr />

your users would see a list of animal names with a line between each.

Shared Templates
If the first option or :partial parameter to a render call is a simple name, Rails
assumes that the target template is in the current controller’s view directory.
However, if the name contains one or more / characters, Rails assumes that
the part up to the last slash is a directory name and the rest is the template
name. The directory is assumed to be under app/views. This makes it easy to
share partials and subtemplates across controllers.
The convention among Rails applications is to store these shared partials in
a subdirectory of app/views called shared. Render shared partials using statements
such as these:
<%= render("shared/header", title: @article.title) %>
<%= render(partial: "shared/post", object: @article) %>
. . .

In this previous example, the @article object will be assigned to the local variable
post within the template.

Partials with Layouts
Partials can be rendered with a layout, and you can apply a layout to a block
within any template:

report erratum • discuss

366

•

Chapter 21. Action View

<%= render partial: "user", layout: "administrator" %>
<%= render layout: "administrator" do %>
# ...
<% end %>

Partial layouts are to be found directly in the app/views directory associated
with the controller, along with the customary underbar prefix, for example,
app/views/users/_administrator.html.erb.

Partials and Controllers
It isn’t just view templates that use partials. Controllers also get in on the
act. Partials give controllers the ability to generate fragments from a page
using the same partial template as the view itself. This is particularly important when you are using Ajax support to update just part of a page from the
controller—use partials, and you know your formatting for the table row or
line item that you’re updating will be compatible with that used to generate
its brethren initially.
Taken together, partials and layouts provide an effective way to make sure
that the user interface portion of your application is maintainable. But being
maintainable is only part of the story; doing so in a way that also performs
well is also crucial.

What We Just Did
Views are the public face of Rails applications, and we have seen that Rails
delivers extensive support for what you need to build robust and maintainable
user and application programming interfaces.
We started with templates, of which Rails provides built-in support for four
types: ERb, builder, CoffeeScript, and SCSS. Templates make it easy for us
to provide HTML, XML, CSS, and JavaScript responses to any request. We
will discuss adding another option in Section 26.2, Beautifying Our Markup
with Haml, on page 439.
We dove into forms, which are the primary means by which users will interact
with your application. Along the way, we covered uploading files.
We continued with helpers, which enable us to factor out complex application
logic to allow our views to focus on presentation aspects. We explored a
number of helpers that Rails provides, ranging from simple formatting to
hypertext links, which are the final way in which users interact with HTML
pages.

report erratum • discuss

Reducing Maintenance with Layouts and Partials

•

367

We completed our tour of Action View by covering two related ways of factoring
out large chunks of content for reuse. We use layouts to factor out the outermost layers of a view and provide a common look and feel. We use partials
to factor out common inner components, such as a single form or table.
That covers how a user with a browser will access our Rails application. Next
up: covering how we can use caching techniques to reduce or even eliminate
the computational overhead of rendering a view when the underlying data in
the database has not changed between requests.

report erratum • discuss

In this chapter, we’ll see
• caching full pages statically,
• caching the results of an action,
• expiring pages from the cache, and
• caching a part of a page.

CHAPTER 22

Caching
Many applications seem to spend a lot of their time doing the same task over
and over. A blog application renders the list of current articles for every visitor.
A store application will display the same page of product information for
everyone who requests it.
All this repetition costs us resources and time on the server. Rendering the
front page of your site may require half a dozen database queries, and it may
end up running through a number of Ruby methods and Rails templates. It
isn’t a big deal for an individual request, but multiply that by several thousand
hits an hour, and suddenly your server is starting to glow a dull red. Your
users will see this as slower response times.
In situations such as these, we can use caching to greatly reduce the load on
our servers and increase the responsiveness of our applications. Rather than
generate the same old content from scratch, time after time, we create it once
and remember the result. The next time a request arrives for that same page,
we deliver it from the cache rather than create it. Or better yet, somebody
else delivers it from their cache, and the request never gets to us at all.
Because when it comes down to it, the request that is the most efficient to
process is the one that you never see.
The first thing to realize is that the Internet has a rich set of features available
to prevent duplicate and redundant requests from getting to your application.
Rails is designed to work with the Internet. But if you find that there are
cases where Internet caching is not appropriate, or despite your best efforts
duplicate requests are still coming in, Rails offers three additional approaches
to caching: page caching, action caching, and fragment caching.

report erratum • discuss

370

•

Chapter 22. Caching

22.1 Playing Nice with Client Caches
Clients (generally, but not always, browsers) often have caches too. Intermediaries between your server and the client may also provide caching services.
Your web server has a cache. You can help optimize these caches (and
therefore reduce load on your server) by providing HTTP headers. Doing so
is entirely optional and won’t always result in a bandwidth reduction, but on
the other hand, sometimes the savings can be quite significant.

Expiration Headers
The most efficient request is the request that is never made. Many pages
(particularly images, scripts, and stylesheets) change very rarely yet may be
referenced fairly frequently. One way to ensure that re-retrievals are optimized
out before they get to your server is to provide an Expires header.
Although an Expires header may provide a number of different options, the
most common usage is to indicate how long the given response is to be considered “good for,” suggesting that the client need not re-request this data in
the interim. Calling the expires_in() method in your controller achieves this
result:
expires_in 10.minutes, public: true

A server should not provide a date more than one year in the future on Expires
headers.
An alternate use for the Expires header is to indicate that the response is not
to be cached at all. This can be accomplished with the expires_now() method,
which understandably takes no parameters.
Let’s take a look at that header in the context of the Depot application. Your
storefront is going to be visited by bazillions of visitors. You want that to
happen. And you want their experience to be a good one.
In order to produce that page, the controller needs to communicate to the
models, which need to communicate to the database. Then the results need
to be processed by the view, and this will result in a response going across
the wire and back across the Internet. And that’s just the start of the fun, as
the browser will immediately come back and ask for more. Stylesheet. JavaScript. Images.
And frankly, none of that is likely to change that frequently in production.
Add to that that there typically are a lot more users browsing than buying.
If a browser gets a catalog listing that is seven minutes old, it is just fine.

report erratum • discuss

Playing Nice with Client Caches

•

371

Caching the store front but not the checkout will reduce your server load
significantly.
And there really is no reason to get greedy. Setting the expiration to be ten
minutes may be plenty. Sure, it is likely to change a lot less frequently than
that, but if your server can’t process one request every ten minutes, either
you have a poorly designed application or a rather slow server.
Best of all, when run in production mode, Rails handles this automatically
for all the assets in your application. That includes stylesheets, JavaScripts,
and images. The way it does this is clever and worth understanding. To see
it in action, restart your server in production mode:
rails server -e production

Now bring up the Depot storefront. It doesn’t look any different, does it? Now
view source. Look for the references to the assets: the link tag, the script tag,
and the img tags. Each starts with /assets/ and ends with the extension you
would expect, but in between is a long string of hexadecimal characters.
Rails has computed a hash of the response and included that hash in the
name. At the same time, it has provided an expires header that says that this
resource will not change for a full year. And the reason why Rails can guarantee that is that if you so much as change a single bit in that object, that
will change the hash, and as far as the client is concerned that will be an
entirely different resource.
What does this mean to the end user? Well, a first-time user who comes to
the storefront will end up downloading all of the scripts and stylesheets that
they will need, as Rails will bundle each of these up into a single file. A few
minutes later when this user proceeds to the checkout page, if the file hasn’t
changed, then the hash won’t have either. The browser will match up the
names, obtain the resource from its own local cache, and not request it again
from the server.
Clever, eh?
You can find additional information on more expiration options in the HTTP
specification.1
Be aware that if you are using page-level caching, requests that are cached
at the server won’t get to your application, so this mechanism needs to also
be implemented at the server level to be effective. Here’s an example for the
Apache web server:
1.

http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.3

report erratum • discuss

372

•

Chapter 22. Caching

<LocationMatch "^/assets/.*$">
Header unset Last-Modified
Header unset ETag
FileETag None
ExpiresActive On
ExpiresDefault "access plus 1 year"
</LocationMatch>

LastModified and ETag Support
The next best thing to eliminating requests entirely is to respond immediately
with an HTTP 304 Not Modified response. This will instruct user agents and
intermediaries to use the version of this page that they already have in their
cache. At a minimum, such responses will save on bandwidth. Often this will
enable you to eliminate the server load associated with producing a more
complete response.
If you are already doing page-level caching with Apache, the web server will
generally take care of this for you, based on the timestamp associated with
the on-disk cache.
For all other requests, Rails will produce the necessary HTTP headers for you,
if you call one of the stale?() or fresh_when() methods.
Both methods accept both a :last_modified timestamp (in UTC) and an :etag. The
latter is either an object on which the response depends or an array of such
objects. Such objects need to respond to either cache_key() or to_param(). Active
Record takes care of this for you.
To demonstrate how this can be used in the context of Depot, let’s introduce
a single method to the Product model, which finds the product that was most
recently updated:
Download rails32/depot_u/app/models/product.rb
def self.latest
Product.order('updated_at desc').limit(1).first
end

First we’ll show the stale?() method, which is typically used in if statements
when custom rendering is involved:
def index
latest = Product.latest
if stale?(etag: latest, last_modified: latest.updated_at.utc)
# ...
end
end

report erratum • discuss

Playing Nice with Client Caches

•

373

The fresh_when() method is often more convenient when you are making use of
default rendering because it will produce a 304 Not Modified response for you:
Download rails32/depot_u/app/controllers/store_controller.rb
class StoreController < ApplicationController
skip_before_filter :authorize
def index
if params[:set_locale]
redirect_to store_path(locale: params[:set_locale])
else
@products = Product.order(:title)
@cart = current_cart
end
➤
➤
➤

latest = Product.latest
fresh_when etag: latest, last_modified: latest.created_at.utc
expires_in 10.minutes, public: true
end
end

We’ve talked about how easy this is to implement. Now let’s talk about
downsides that you need to be aware of.
In the case of your Depot store front, ETags aren’t going to help much. You
likely won’t face the problem of the same person getting the same page over
and over again. That’s easy, and a response of 304 Not Modified solves it handily.
No, what you are likely to see is lots of different people visiting the site, each
of whom hasn’t seen it recently and wants to get the latest.
Expiring without specifying the public attribute isn’t any better at solving this
problem. This is still a private negotiation between your server and each and
every client. Setting the public attribute to true changes everything. It makes
the page eligible for caching by your web server and even potentially by other
intermediaries on the web.
But for this to work properly, the content must truly be public. It can’t be
different for different users. In order to use this with the current storefront,
you’ll need to make a few changes. You can’t have administrative links that
only are added if the user is logged on. Nor can you make use of a hidden_div_if()
helper. You’ll need to have a separate page for administrators, and a separate
page for a visible cart. You still can use Ajax techniques to update the page;
you only need to avoid server-side if statements in your views.
There is one other matter to be aware of; in this case it’s both a plus and a
minus. If your HTML is cached so that new requests for this page from the
client never make it to the Rails application, then the client won’t be aware

report erratum • discuss

374

•

Chapter 22. Caching

of changes in the hash part of the assets’ name, so they won’t fetch updates
to images, JavaScripts, and stylesheets until the HTML page expires.
All in all, HTML caching is well worth the effort. In a situation where this is
not for you, Rails does have more to offer. However, it is generally worthwhile
to try to make HTTP caching work for you before you explore Rails’ caching
options.

22.2 Page Caching
Page caching is the simplest and most efficient form of Rails caching. The
first time a user requests a particular URL, our application gets invoked and
generates a page of HTML. The contents of this page are stored in the cache.
The next time a request containing that URL is received, the HTML of the
page will be delivered straight from the cache. Your application never sees
the request. In fact, Rails is not involved at all. The web server itself handles
the entire request, which makes page caching very, very efficient. Your application delivers these pages at the same speed that the server can deliver any
other static content.
Sometimes, though, our application needs to be at least partially involved in
handling these requests. For example, your store might display details of
certain products only to a subset of users (perhaps premium customers get
earlier access to new products). In this case, the page you display will have
the same content, but you don’t want to display it to just anyone—you need
to filter access to the cached content. Rails provides action caching for this
purpose. With action caching, your application controller is still invoked, and
it’s invoked before filters are run. However, the action itself is not called if
there’s an existing cached page.
Let’s look at this in the context of a site that has public content and premium,
members-only content. We have two controllers: an admin controller that
verifies that someone is a member and a content controller with actions to
show both public and premium content. The public content consists of a
single page with links to premium articles. If someone requests premium
content and they’re not a member, we redirect them to an action in the admin
controller that signs them up.
Ignoring caching for a minute, we can implement the content side of this
application using a before filter to verify the user’s status and a couple of
action methods for the two kinds of content:
Download rails32/e1/cookies/app/controllers/content_controller.rb
class ContentController < ApplicationController
before_filter :verify_premium_user, :except => :public_content

report erratum • discuss

Page Caching

•

375

def public_content
@articles = Article.list_public
end
def premium_content
@articles = Article.list_premium
end
private
def verify_premium_user
user = session[:user_id]
user = User.find(user) if user
unless user && user.active?
redirect_to :controller => "login", :action => "signup_new"
end
end
end

Because the content pages are fixed, they can be cached. We can cache the
public content at the page level, but we have to restrict access to the cached
premium content to members, so we need to use action-level caching for it.
To enable caching, we simply add two declarations to our class:
Download rails32/e1/cookies/app/controllers/content_controller.rb
class ContentController < ApplicationController
before_filter :verify_premium_user, :except => :public_content
caches_page
:public_content
caches_action :premium_content

The caches_page directive tells Rails to cache the output of public_content() the
first time it is produced. Thereafter, this page will be delivered directly from
the web server.
The second directive, caches_action, tells Rails to cache the results of executing
premium_content() but still to execute the filters. This means that we’ll still validate
that the person requesting the page is allowed to do so, but we won’t actually
execute the action more than once.
Action caching is a good example of an around filter, described in Filters, on
page 337. The before part of the filter checks to see whether the cached item
exists. If it does, it renders it directly to the user, preventing the real action
from running. The after part of the filter saves the results of running the action
in the cache.

report erratum • discuss

376

•

Chapter 22. Caching

The caches_action() method can accept a number of options. A :cache_path option
allows you to modify the action cache path. This can be useful for actions
that handle a number of different conditions with different cache needs. :if
and :unless allow you to pass a Proc that will control when an action should
be passed. Finally, a :layout option, if false, will cause Rails to cache only your
action content. This is useful when your layout has dynamic information.
Caching is, by default, enabled only in production environments. You can
turn it on or off manually by setting this:
ActionController::Base.perform_caching = true | false

You can make this change in your application’s environment files (in config/environments), although the preferred syntax is slightly different there:
config.action_controller.perform_caching = true

Note that both Rails action and page caching are strictly URL based. A page
is cached according to the content of the URL that first generated it, and
subsequent requests to that same URL will return the saved content.
This means that dynamic pages that depend on information not in the URL
are poor candidates for caching. These include the following:
• Pages where the content is time based (although see Time-Based Expiry
of Cached Pages, on page 380).
• Pages whose content depends on session information. For example, if you
customize pages for each of your users, you’re unlikely to be able to cache
them (although you might be able to take advantage of fragment caching,
described starting in Section 22.4, Fragment Caching, on page 381).
• Pages generated from data that you don’t control. For example, a page
displaying information from our database might not be cachable if nonRails applications can update that database too. Our cached page would
become out-of-date without our application knowing.
However, caching can cope with pages generated from volatile content that’s
under your control. As we’ll see in the next section, it’s simply a question of
removing the cached pages when they become outdated.

22.3 Expiring Pages
Creating cached pages is only one half of the equation. If the content initially
used to create these pages changes, the cached versions will become out-ofdate, and we’ll need a way of expiring them.

report erratum • discuss

Expiring Pages

•

377

The trick is to code the application to notice when the data used to create a
dynamic page has changed and then to remove the cached version. The next
time a request comes through for that URL, the cached page will be regenerated based on the new content.

Expiring Pages Explicitly
The low-level way to remove cached pages is with the methods expire_page()
and expire_action(). These take the same parameters as url_for() and expire the
cached page that matches the generated URL.
For example, our content controller might have an action that allows us to
create an article and another action that updates an existing article. When
we create an article, the list of articles on the public page will become obsolete,
so we call expire_page(), passing in the action name that displays the public
page. When we update an existing article, the public index page remains
unchanged (at least, it does in our application), but any cached version of
this particular article should be deleted. Because this cache was created using
caches_action, we need to expire the page using expire_action(), passing in the action
name and the article id.
Download rails32/e1/cookies/app/controllers/content_controller.rb
def create_article
article = Article.new(params[:article])
if article.save
expire_page :action => "public_content"
else
# ...
end
end
def update_article
article = Article.find(params[:id])
if article.update_attributes(params[:article])
expire_action :action => "premium_content", :id => article
else
# ...
end
end

The method that deletes an article does a bit more work—it has to both invalidate the public index page and remove the specific article page:
Download rails32/e1/cookies/app/controllers/content_controller.rb
def delete_article
Article.destroy(params[:id])
expire_page
:action => "public_content"
expire_action :action => "premium_content", :id => params[:id]
end

report erratum • discuss

378

•

Chapter 22. Caching

Picking a Caching Store Strategy
Caching, like sessions, features a number of storage options. You can keep
the fragments in files, in a database, in a DRb server, or in memcached servers.
But whereas sessions usually contain small amounts of data and require
only one row per user, fragment caching can easily create sizeable amounts
of data, and you can have many per user. This makes database storage a
poor fit.
For many setups, it’s easiest to keep cache files on the filesystem. But you
can’t keep these cached files locally on each server, because expiring a cache
on one server would not expire it on the rest. You therefore need to set up a
network drive that all the servers can share for their caching.
As with session configuration, you can configure a file-based caching store
globally in environment.rb or in a specific environment’s file:
ActionController::Base.cache_store = :file_store, "#{RAILS_ROOT}/cache"

This configuration assumes that a directory named cache is available in the
root of the application and that the web server has full read and write access
to it. This directory can easily be symlinked to the path on the server that
represents the network drive.
Regardless of which store you pick for caching fragments, you should be
aware that network bottlenecks can quickly become a problem. If your site
depends heavily on fragment caching, every request will need a lot of data
transferring from the network drive to the specific server before it’s again sent
on to the user. To use this on a high-profile site, you need to have a highbandwidth internal network between your servers, or you will see slowdown.
The caching store system is available only for caching actions and fragments.
Full-page caches need to be kept on the filesystem in the public directory. In
this case, you will have to go the network drive route if you want to use page
caching across multiple web servers. You can then symlink either the entire
public directory (but that will also cause your images, stylesheets, and JavaScript to be passed over the network, which may be a problem) or just the
individual directories that are needed for your page caches. In the latter case,
you would, for example, symlink public/products to your network drive to keep
page caches for your products controller.

Expiring Pages Implicitly
The expire_xxx methods work well, but they also couple the caching function
to the code in your controllers. Every time you change something in the

report erratum • discuss

Expiring Pages

•

379

database, you also have to work out which cached pages this might affect.
Although this is easy for smaller applications, this gets more difficult as the
application grows. A change made in one controller might affect pages cached
in another. Business logic in helper methods, which really shouldn’t have to
know about HTML pages, now needs to worry about expiring cached pages.
Fortunately, Rails sweepers can simplify some of this coupling. A sweeper is
a special kind of observer on your model objects. When something significant
happens in the model, the sweeper expires the cached pages that depend on
that model’s data.
Your application can have as many sweepers as it needs. You’ll typically create
a separate sweeper to manage the caching for each controller. Put your
sweeper code in app/sweepers:
Download rails32/e1/cookies/app/sweepers/article_sweeper.rb
class ArticleSweeper < ActionController::Caching::Sweeper
observe Article
# If we create a new article, the public list of articles must be regenerated
def after_create(article)
expire_public_page
end
# If we update an existing article, the cached version of that article is stale
def after_update(article)
expire_article_page(article.id)
end
# Deleting a page means we update the public list and blow away the cached article
def after_destroy(article)
expire_public_page
expire_article_page(article.id)
end
private
def expire_public_page
expire_page(:controller => "content", :action => 'public_content')
end
def expire_article_page(article_id)
expire_action(:controller => "content",
:action
=> "premium_content",
:id
=> article_id)
end
end

report erratum • discuss

380

•

Chapter 22. Caching

The flow through the sweeper is somewhat convoluted:
• You first declare the sweeper as an observer on one or more Active Record
classes. In our example case, it observes the Article model. (We first talked
about observers back in Observers, on page 300.) The sweeper uses hook
methods (such as after_update()) to expire cached pages if appropriate.
• The sweeper is also declared to be active in a controller using the directive
cache_sweeper:
class ContentController < ApplicationController
before_filter :verify_premium_user, :except => :public_content
caches_page
:public_content
caches_action :premium_content
cache_sweeper :article_sweeper,
:only => [ :create_article,
:update_article,
:delete_article ]
# ...

• If a request comes in that invokes one of the actions that the sweeper is
filtering, the sweeper is activated. If any of the Active Record observer
methods fires, the page and action expiry methods will be called. If the
Active Record observer gets invoked but the current action is not selected
as a cache sweeper, the expire calls in the sweeper are ignored. Otherwise,
the expiry takes place.

Time-Based Expiry of Cached Pages
Consider a site that shows fairly volatile information such as stock quotes or
news headlines. If we did the style of caching where we expired a page
whenever the underlying information changed, we’d be expiring pages constantly. The cache would rarely get used, and we would lose the benefit of
having it.
In these circumstances, you might want to consider switching to time-based
caching, where you build the cached pages exactly as we did previously but
don’t expire them when their content becomes obsolete.
You run a separate background process that periodically goes into the cache
directory and deletes the cache files. You choose how this deletion occurs—you
could simply remove all files, the files created more than so many minutes
ago, or the files whose names match some pattern. That part is applicationspecific.

report erratum • discuss

Fragment Caching

•

381

The next time a request comes in for one of these pages, it won’t be satisfied
from the cache, and the application will handle it. In the process, it’ll automatically repopulate that particular page in the cache, lightening the load for
subsequent fetches of this page.
Where do you find the cache files to delete? Not surprisingly, this is configurable. Page cache files are by default stored in the public directory of your
application. They’ll be named after the URL they are caching, with an .html
extension. For example, the page cache file for content/show/1 will be here:
app/public/content/show/1.html

This naming scheme is no coincidence; it allows the web server to find the
cache files automatically. You can, however, override the defaults using this:
config.action_controller.page_cache_directory = "dir/name"
config.action_controller.page_cache_extension = ".html"

Action cache files are not by default stored in the regular filesystem directory
structure and cannot be expired using this technique.
In addition to the ability to cache a full page, Rails also provides support for
caching parts of a page. We cover why that is useful and how to integrate it
into your application next.

22.4 Fragment Caching
Caching parts of a page turns out to be remarkably useful in dynamic sites.
Perhaps you customize the greeting and the sidebar on your blog application
for each individual user. In this case, you can’t use page caching, because
the overall page is different for each user. But because the list of articles
doesn’t change between users, you can use fragment caching—you construct
the HTML that displays the articles just once and include it in customized
pages delivered to individual users.
Just to illustrate fragment caching, let’s set up a pretend blog application.
Here’s the controller. It sets up @dynamic_content, representing content that
should change each time the page is viewed. For our fake blog, we use the
current time as this content.
Download rails32/e1/views/app/controllers/blog_controller.rb
class BlogController < ApplicationController
def list
@dynamic_content = Time.now.to_s
end
end

report erratum • discuss

382

•

Chapter 22. Caching

Here’s our mock Article class. It simulates a model class that in normal circumstances would fetch articles from the database. We’ve arranged for the first
article in our list to display the time at which it was created.
Download rails32/e1/views/app/models/article.rb
class Article
attr_reader :body
def initialize(body)
@body = body
end
def self.find_recent
[ new("It is now #{Time.now.to_s}"),
new("Today I had pizza"),
new("Yesterday I watched Spongebob"),
new("Did nothing on Saturday") ]
end
end

Now we’d like to set up a template that uses a cached version of the rendered
articles but still updates the dynamic data. It turns out to be trivial.
Download rails32/e1/views/app/views/blog/list.html.erb
<%= @dynamic_content %>
<!-- Here's dynamic content. -->
<% cache do %>
<!-- Here's the content we cache -->
<ul>
<% for article in Article.find_recent %>
<li><p><%= h(article.body) %></p></li>
<% end %>
</ul>
<% end %>
<!-- End of cached content -->
<%= @dynamic_content %>

<!-- More dynamic content. -->

The magic is the cache() method. All output generated in the block associated
with this method will be cached. The next time this page is accessed, the
dynamic content will still be rendered, but the stuff inside the block will come
straight from the cache—it won’t be regenerated. We can see this if we bring
up our skeletal application and hit Refresh after a few seconds, as shown in
Figure 52, Refreshing a page with cached and noncached data, on page 384.
The times at the top and bottom of the page—the dynamic portion of our data
—change on the refresh. However, the time in the center section remains the
same, because it is being served from the cache. (If you’re trying this at home
and you see all three time strings change, chances are you’re running your
application in development mode. Caching is enabled by default only in

report erratum • discuss

Fragment Caching

•

383

production mode. If you’re testing using WEBrick, the -e production option will
do the trick.)
The key concept here is that the stuff that’s cached is the fragment generated
in the view. If we’d constructed the article list in the controller and then passed
that list to the view, the future access to the page would not have to rerender
the list, but the database would still be accessed on every request. Moving
the database request into the view means it won’t be called once the output
is cached.
OK, you say, but that just broke the rule about putting application-level code
into view templates. Can’t we avoid that somehow? We can, but it means
making caching just a little less transparent than it would otherwise be. The
trick is to have the action test for the presence of a cached fragment. If one
exists, the action bypasses the expensive database operation, knowing that
the fragment will be used.
Download rails32/e1/views/app/controllers/blog1_controller.rb
class Blog1Controller < ApplicationController
def list
@dynamic_content = Time.now.to_s
unless fragment_exist?(action: 'list')
logger.info("Creating fragment")
@articles = Article.find_recent
end
end
end

The action uses the fragment_exist?() method to see whether a fragment exists
for this action. If not, it loads the list of articles from the (fake) database. The
view then uses this list to create the fragment.
Download rails32/e1/views/app/views/blog1/list.html.erb
<%= @dynamic_content %> <!-- Here's dynamic content. -->
<% cache do %>
<!-- Here's the content we cache -->
<ul>
<% for article in @articles %>
<li><p><%= h(article.body) %></p></li>
<% end %>
</ul>
<% end %>
<!-- End of the cached content -->
<%= @dynamic_content %> <!-- More dynamic content. -->

report erratum • discuss

384

•

Chapter 22. Caching

Refresh page

Figure 52—Refreshing a page with cached and noncached data

Expiring Cached Fragments
Now that we have a cached version of the article list, our Rails application
will be able to serve it whenever this page is referenced. If the articles are
updated, however, the cached version will be out-of-date and should be
expired. We do this with the expire_fragment() method. By default, fragments
are cached using the name of the controller and action that rendered the page
(blog and list in our first case). To expire the fragment (for example, when the
article list changes), the controller could call this:
Download rails32/e1/views/app/controllers/blog_controller.rb
expire_fragment(:controller => 'blog', :action => 'list')

Clearly, this naming scheme works only if there’s just one fragment on the
page. Fortunately, if you need more, you can override the names associated
with fragments by adding parameters (using url_for() conventions) to the cache()
method:
Download rails32/e1/views/app/views/blog2/list.html.erb
<% cache(:action => 'list', :part => 'articles') do %>
<ul>
<% for article in @articles %>
<li><p><%= h(article.body) %></p></li>
<% end %>
</ul>
<% end %>
<% cache(:action => 'list', :part => 'counts') do %>
<p>
There are a total of <%= @article_count %> articles.
</p>
<% end %>

report erratum • discuss

Fragment Caching

•

385

In this example, two fragments are cached. The first has the additional :part
parameter set to articles, and the second has it set to counts.
Within the controller, we can pass the same parameters to expire_fragment() to
delete particular fragments. For example, when we edit an article, we have
to expire the article list, but the count is still valid. If instead we delete an
article, we need to expire both fragments. The controller looks like this (we
don’t have any code that actually does anything to the articles in it—just look
at the caching):
Download rails32/e1/views/app/controllers/blog2_controller.rb
class Blog2Controller < ApplicationController
def list
@dynamic_content = Time.now.to_s
@articles = Article.find_recent
@article_count
= @articles.size
end
def edit
# do the article editing
expire_fragment(:action => 'list', :part => 'articles')
redirect_to(:action => 'list')
end
def delete
# do the deleting
expire_fragment(:action => 'list', :part => 'articles')
expire_fragment(:action => 'list', :part => 'counts')
redirect_to(:action => 'list')
end
end

The expire_fragment() method can also take a single regular expression as a
parameter, allowing us to expire all fragments whose names match:
expire_fragment(%r{/blog2/list.*})

What We Just Did
We explored three techniques that can be used to make your site respond
faster.
We learned how to cache entire pages and thereby avoid all Ruby, Rails, and
database overhead when processing requests that can be served by the cache.
This is useful for high-traffic pages that require database access to produce
and yet rarely change. The product catalog listings from the Depot application
is a prime example of such a page.

report erratum • discuss

386

•

Chapter 22. Caching

We learned how to cache the results of controller actions, avoiding rendering
and database overhead. This is useful in cases where we want to continue to
have filters run, generally for authentication purposes. Along the way we
covered both explicit and implicit mechanisms to force expiration of pages in
the cache.
Finally, we learned how to cache fragments of pages, which allows us full
control over balancing optimization and the production of dynamic content.
This covers maintaining the cache in support of views. Next up: maintaining
database schemas in support of models.

report erratum • discuss

In this chapter, we’ll see
• naming migration files,
• renaming and columns,
• creating and renaming tables,
• defining indices and keys,
• using native SQL.

CHAPTER 23

Migrations
Rails encourages an agile, iterative style of development. We don’t expect to
get everything right the first time. Instead, we write tests and interact with
our customers to refine our understanding as we go.
For that to work, we need a supporting set of practices. We write tests to help
us design our interfaces and to act as a safety net when we change things,
and we use version control to store our application’s source files, allowing us
to undo mistakes and to monitor what changes day to day.
But there’s another area of the application that changes, an area that we
can’t directly manage using version control. The database schema in a Rails
application constantly evolves as we progress through the development: we
add a table here, rename a column there, and so on. The database changes
in step with the application’s code.
With Rails, each of those steps is made possible through the use of a migration.
You saw this in use throughout the development of the Depot application,
starting when we created the first products table in Generating the Scaffold, on
page 62 and when we performed such tasks as adding a quantity to the
line_items table in Section 10.1, Iteration E1: Creating a Smarter Cart, on page
115. Now it is time to dig deeper into how migrations work and what else you
can do with them.

23.1 Creating and Running Migrations
A migration is simply a Ruby source file in your application’s db/migrate directory. Each migration file’s name starts with a number of digits (typically
fourteen) and an underscore. Those digits are the key to migrations, because
they define the sequence in which the migrations are applied—they are the
individual migration’s version number.

report erratum • discuss

388

•

Chapter 23. Migrations

The version number itself is the Coordinated Universal Time (UTC) timestamp
at the time the migration was created. These numbers contain the four-digit
year, followed by two digits each for the month, day, hour, minute, and second,
all based on the mean solar time at the Royal Observatory in Greenwich,
London. Because migrations tend to be created relatively infrequently and
the accuracy is recorded down to the second, the chances of any two people
getting the same timestamp is vanishingly small. And the benefit of having
timestamps that can be deterministically ordered far outweighs the miniscule
risk of this occurring.
Here’s what the db/migrate directory of our Depot application looks like:
depot> ls db/migrate
20110711000001_create_products.rb
20110711000002_create_carts.rb
20110711000003_create_line_items.rb
20110711000004_add_quantity_to_line_items.rb
20110711000005_combine_items_in_cart.rb
20110711000006_create_orders.rb
20110711000007_add_order_id_to_line_item.rb
20110711000008_create_users.rb

Although you could create these migration files by hand, it’s easier (and less
error prone) to use a generator. As we saw when we created the Depot application, there are actually two generators that create migration files:
• The model generator creates a migration to in turn create the table associated with the model (unless you specify the --skip-migration option). As the
example that follows shows, creating a model called discount also creates
a migration called yyyyMMddhhmmss_create_discounts.rb:
depot> rails generate model discount
invoke active_record
➤
create
db/migrate/20110608133549_create_discounts.rb
create
app/models/discount.rb
invoke
test_unit
create
test/unit/discount_test.rb
create
test/fixtures/discounts.yml

• You can also generate a migration on its own:
depot> rails generate migration add_price_column
invoke active_record
➤
create
db/migrate/20110608133814_add_price_column.rb

Later, starting in Anatomy of a Migration, we’ll see what goes in the migration
files. But for now, let’s jump ahead a little in the workflow and see how to
run migrations.

report erratum • discuss

Creating and Running Migrations

•

389

Running Migrations
Migrations are run using the db:migrate Rake task:
depot> rake db:migrate

To see what happens next, let’s dive down into the internals of Rails.
The migration code maintains a table called schema_migrations inside every Rails
database. This table has just one column, called version, and it will have one
row per successfully applied migration.
When you run rake db:migrate, the task first looks for the schema_migrations table.
If it doesn’t yet exist, it will be created.
The migration code then looks at all the migration files in db/migrate and skips
from consideration any that have a version number (the leading digits in the
filename) that is already in the database. It then proceeds to apply the remainder of the migrations, creating a row in the schema_migrations table for each.
If we were to run migrations again at this point, nothing much would happen.
Each of the version numbers of the migration files would match with a row
in the database, so there’d be no migrations to apply.
However, if we subsequently create a new migration file, it will have a version
number not in the database. This is true even if the version number was before
one or more of the already applied migrations. This can happen when multiple
users are using a version control system to store the migration files. If we
then run migrations, this new migration file—and only this migration file—will
be executed. This may mean that migrations are run out of order, so you
might want to take care and ensure that these migrations are independent.
Or you might want to revert your database to a previous state and then apply
the migrations in order.
You can force the database to a specific version by supplying the VERSION=
parameter to the rake db:migrate command:
depot> rake db:migrate VERSION=20110711000009

If the version you give is greater than any of the migrations that have yet to
be applied, these migrations will be applied.
If, however, the version number on the command line is less than one or more
versions listed in the schema_migrations table, something different happens. In
these circumstances, Rails looks for the migration file whose number
matches the database version and undoes it. It repeats this process until
there are no more versions listed in the schema_migrations table that exceed the

report erratum • discuss

390

•

Chapter 23. Migrations

number you specified on the command line. That is, the migrations are unapplied in reverse order to take the schema back to the version that you specify.
You can also redo one or more migrations:
depot> rake db:migrate:redo STEP=3

By default, redo will roll back one migration and rerun it. To roll back multiple
migrations, pass the STEP= parameter.

23.2 Anatomy of a Migration
Migrations are subclasses of the Rails class ActiveRecord::Migration. Migrations
generally contain the two methods up() and down():
class SomeMeaningfulName < ActiveRecord::Migration
def up
# ...
end
def down
# ...
end
end

The name of the class, after all uppercase letters are downcased and preceded
by an underscore, must match the portion of the filename after the version
number. For example, the previous class could be found in a file named
20110711000017_some_meaningful_name.rb. No two migrations can contain classes
with the same name.
The up() method is responsible for applying the schema changes for this
migration, while the down() method undoes those changes. Let’s make this
more concrete. Here’s a migration that adds an e_mail column to the orders table:
class AddEmailToOrders < ActiveRecord::Migration
def up
add_column :orders, :e_mail, :string
end
def down
remove_column :orders, :e_mail
end
end

See how the down() method undoes the effect of the up() method?
You can also see that there is a bit of duplication here. In many cases, Rails
can detect how to automatically undo a given operation. For example, the

report erratum • discuss

Anatomy of a Migration

•

391

opposite of add_column() is clearly remove_column(). In such cases, by simply
renaming up() to change(), you can eliminate the need for a down():
class AddEmailToOrders < ActiveRecord::Migration
def change
add_column :orders, :e_mail, :string
end
end

Now isn’t that much cleaner?

Column Types
The third parameter to add_column specifies the type of the database column.
In the previous example, we specified that the e_mail column has a type of
:string. But just what does this mean? Databases typically don’t have column
types of :string.
Remember that Rails tries to make your application independent of the
underlying database; you could develop using SQLite 3 and deploy to Postgres
if you wanted, for example. But different databases use different names for
the types of columns. If you used a SQLite 3 column type in a migration, that
migration might not work if applied to a Postgres database. So, Rails migrations insulate you from the underlying database type systems by using logical
types. If we’re migrating a SQLite 3 database, the :string type will create a column of type varchar(255). On Postgres, the same migration adds a column with
the type char varying(255).
The types supported by migrations are :binary, :boolean, :date, :datetime, :decimal,
:float, :integer, :string, :text, :time, and :timestamp. The default mappings of these
types for the database adapters in Rails are shown in Figure 53, Migration
and database column types, on page 392. Using this figure, you could work
out that a column declared to be :integer in a migration would have the underlying type integer in SQLite 3 and number(38) in Oracle.
You can specify up to three options when defining most columns in a migration; decimal columns take an additional two options. Each of these options
is given as a key: value pair. The common options are as follows:
null: true or false

If false, the underlying column has a not null constraint added (if the
database supports it).
limit: size

This sets a limit on the size of the field. This basically appends the string
(size) to the database column type definition.

report erratum • discuss

392

•

Chapter 23. Migrations

Figure 53—Migration and database column types

report erratum • discuss

Anatomy of a Migration

•

393

default: value

This sets the default value for the column. Note that the default is calculated once, at the point the migration is run, so the following code will set
the default column value to the date and time when the migration was
run:
add_column :orders, :placed_at, :datetime, default: Time.now

In addition, decimal columns take the options :precision and :scale. The :precision
option specifies the number of significant digits that will be stored, and the
:scale option determines where the decimal point will be located in these digits
(think of the scale as the number of digits after the decimal point). A decimal
number with a precision of 5 and a scale of 0 can store numbers from -99,999
to +99,999. A decimal number with a precision of 5 and a scale of 2 can store
the range -999.99 to +999.99.
The :precision and :scale parameters are optional for decimal columns. However,
incompatibilities between different databases lead us to strongly recommend
that you include the options for each decimal column.
Here are some column definitions using the migration types and options:
add_column
add_column
add_column
add_column

:orders,
:orders,
:orders,
:orders,

:attn, :string, limit: 100
:order_type, :integer
:ship_class, :string, null: false, default: 'priority'
:amount, :decimal, precision: 8, scale: 2

Renaming Columns
When we refactor our code, we often change our variable names to make them
more meaningful. Rails migrations allow us to do this to database column
names, too. For example, a week after we first added it, we might decide that
e_mail isn’t the best name for the new column. We can create a migration to
rename it using the rename_column() method:
class RenameEmailColumn < ActiveRecord::Migration
def change
rename_column :orders, :e_mail, :customer_email
end
end

As rename_column() is reversible, separate up() and down() methods are not required
in order to use it.
Note that the rename doesn’t destroy any existing data associated with the
column. Also be aware that renaming is not supported by all the adapters.

report erratum • discuss

394

•

Chapter 23. Migrations

Changing Columns
Use the change_column() method to change the type of a column or to alter the
options associated with a column. Use it the same way you’d use add_column,
but specify the name of an existing column. Let’s say that the order type column is currently an integer, but we need to change it to be a string. We want
to keep the existing data, so an order type of 123 will become the string "123".
Later, we’ll use noninteger values such as "new" and "existing".
Changing from an integer column to a string is easy:
def up
change_column :orders, :order_type, :string
end

However, the opposite transformation is problematic. We might be tempted
to write the obvious down() migration:
def down
change_column :orders, :order_type, :integer
end

But if our application has taken to storing data like "new" in this column, the
down() method will lose it—"new" can’t be converted to an integer. If that’s
acceptable, then the migration is acceptable as it stands. If, however, we want
to create a one-way migration—one that cannot be reversed—we’ll want to
stop the down migration from being applied. In this case, Rails provides a
special exception that we can throw:
class ChangeOrderTypeToString < ActiveRecord::Migration
def up
change_column :orders, :order_type, :string, null: false
end
def down
raise ActiveRecord::IrreversibleMigration
end
end

ActiveRecord::IrreversibleMigration is also the name of the exception that Rails will

raise if you attempt to call a method that can’t be automatically reversed from
within a change() method.

23.3 Managing Tables
So far we’ve been using migrations to manipulate the columns in existing
tables. Now let’s look at creating and dropping tables:

report erratum • discuss

Managing Tables

•

395

class CreateOrderHistories < ActiveRecord::Migration
def change
create_table :order_histories do |t|
t.integer :order_id, null: false
t.text :notes
t.timestamps
end
end
end

create_table() takes the name of a table (remember, table names are plural) and

a block. (It also takes some optional parameters that we’ll look at in a minute.)
The block is passed a table definition object, which we use to define the
columns in the table.
Generally the call to drop_table() is not needed, as add_table() is reversible.
drop_table() accepts a single parameter, which is the name of the table to drop.
The calls to the various table definition methods should look familiar—they’re
similar to the add_column method we used previously except these methods
don’t take the name of the table as the first parameter, and the name of the
method itself is the data type desired. This reduces repetition.
Note that we don’t define the id column for our new table. Unless we say otherwise, Rails migrations automatically add a primary key called id to all tables
they create. For a deeper discussion of this, see Primary Keys, on page 398.
The timestamps method creates both the created_at and updated_at columns, with
the correct timestamp data type. Although there is no requirement to add these
columns to any particular table, this is yet another example of Rails making
it easy for a common convention to be implemented easily and consistently.

Options for Creating Tables
You can pass a hash of options as a second parameter to create_table.
If you specify force: true, the migration will drop an existing table of the same
name before creating the new one. This is a useful option if you want to create
a migration that forces a database into a known state, but there’s clearly a
potential for data loss.
The temporary: true option creates a temporary table—one that goes away when
the application disconnects from the database. This is clearly pointless in the
context of a migration, but as we will see later, it does have its uses elsewhere.
The options: "xxxx" parameter lets you specify options to your underlying
database. These are added to the end of the CREATE TABLE statement, right after

report erratum • discuss

396

•

Chapter 23. Migrations

the closing parenthesis. Although this is rarely necessary with SQLite 3, it
may at times be useful with other database servers. For example, some versions of MySQL allow you to specify the initial value of the autoincrementing
id column. We can pass this in through a migration as follows:
create_table :tickets, options: "auto_increment = 10000" do |t|
t.text :description
t.timestamps
end

Behind the scenes, migrations will generate the following DDL from this table
description when configured for MySQL:
CREATE TABLE "tickets" (
"id" int(11) default null auto_increment primary key,
"description" text,
"created_at" datetime,
"updated_at" datetime
) auto_increment = 10000;

Be careful when using the :options parameter with MySQL. The Rails MySQL
database adapter sets a default option of ENGINE=InnoDB. This overrides any
local defaults you may have and forces migrations to use the InnoDB storage
engine for new tables. However, if you override :options, you’ll lose this setting;
new tables will be created using whatever database engine is configured as
the default for your site. You may want to add an explicit ENGINE=InnoDB to the
options string to force the standard behavior in this case. You probably want
to keep using InnoDB if you’re using MySQL, because this engine gives you
transaction support. You might need transaction support in your application,
and you’ll definitely need it in your tests if you’re using the default of transactional test fixtures.

Renaming Tables
If refactoring leads us to rename variables and columns, then it’s probably
not a surprise that we sometimes find ourselves renaming tables, too. Migrations support the rename_table() method:
class RenameOrderHistories < ActiveRecord::Migration
def change
rename_table :order_histories, :order_notes
end
end

Rolling back this migration undoes the change by renaming the table back.

report erratum • discuss

Managing Tables

•

397

Problems with rename_table
There’s a subtle problem when we rename tables in migrations.
For example, let’s assume that in migration 4 we create the order_histories table
and populate it with some data:
def up
create_table :order_histories do |t|
t.integer :order_id, null: false
t.text :notes
t.timestamps
end
order = Order.find :first
OrderHistory.create(order_id: order, notes: "test")
end

Later, in migration 7, we rename the table order_histories to order_notes. At this
point we’ll also have renamed the model OrderHistory to OrderNote.
Now we decide to drop our development database and reapply all migrations.
When we do so, the migrations throw an exception in migration 4: our application no longer contains a class called OrderHistory, so the migration fails.
One solution, proposed by Tim Lucas, is to create local, dummy versions of
the model classes needed by a migration within the migration itself. For
example, the following version of the fourth migration will work even if the
application no longer has an OrderHistory class:
class CreateOrderHistories < ActiveRecord::Migration
➤
➤

class Order < ActiveRecord::Base; end
class OrderHistory < ActiveRecord::Base; end
def change
create_table :order_histories do |t|
t.integer :order_id, null: false
t.text :notes
t.timestamps
end
order = Order.find :first
OrderHistory.create(order: order_id, notes: "test")
end
end

This works as long as our model classes do not contain any additional functionality that would have been used in the migration—all we’re creating here
is a bare-bones version.

report erratum • discuss

398

•

Chapter 23. Migrations

Defining Indices
Migrations can (and probably should) define indices for tables. For example,
we might notice that once your application has a large number of orders in
the database, searching based on the customer’s name takes longer than
we’d like. It’s time to add an index using the appropriately named add_index()
method:
class AddCustomerNameIndexToOrders < ActiveRecord::Migration
def change
add_index :orders, :name
end
end

If we give add_index the optional parameter unique: true, a unique index will be
created, forcing values in the indexed column to be unique.
By default the index will be given the name index_table_on_column. We can
override this using the name: "somename" option. If we use the :name option when
adding an index, we’ll also need to specify it when removing the index.
We can create a composite index—an index on multiple columns—by passing
an array of column names to add_index. In this case, only the first column name
will be used when naming the index.
Indices are removed using the remove_index() method.

Primary Keys
Rails assumes every table has a numeric primary key (normally called id) and
ensures the value of this column is unique for each new row added to a table.
We’ll rephrase that.
Rails really doesn’t work too well unless each table has a numeric primary
key. It is less fussy about the name of the column. So, for your average Rails
application, our strong advice is to go with the flow and let Rails have its id
column.
If you decide to be adventurous, you can start by using a different name for
the primary key column (but keeping it as an incrementing integer). Do this
by specifying a :primary_key option on the create_table call:
create_table :tickets, primary_key: :number do |t|
t.text :description
t.timestamps
end

report erratum • discuss

Advanced Migrations

•

399

This adds the number column to the table and sets it up as the primary key:
$ sqlite3 db/development.sqlite3 ".schema tickets"
CREATE TABLE tickets ("number" INTEGER PRIMARY KEY AUTOINCREMENT
NOT NULL, "description" text DEFAULT NULL, "created_at" datetime
DEFAULT NULL, "updated_at" datetime DEFAULT NULL);

The next step in the adventure might be to create a primary key that isn’t an
integer. Here’s a clue that the Rails developers don’t think this is a good idea:
migrations don’t let you do this (at least not directly).

Tables with No Primary Key
Sometimes we may need to define a table that has no primary key. The most
common case in Rails is for join tables—tables with just two columns where
each column is a foreign key to another table. To create a join table using
migrations, we have to tell Rails not to automatically add an id column:
create_table :authors_books, id: false do |t|
t.integer :author_id, null: false
t.integer :book_id,
null: false
end

In this case, you might want to investigate creating one or more indices on
this table to speed navigation between books and authors.

23.4 Advanced Migrations
Most Rails developers use the basic facilities of migrations to create and
maintain their database schemas. However, every now and then it’s useful
to push migrations just a bit further. This section covers some more advanced
migration usage.

Using Native SQL
Migrations give you a database-independent way of maintaining your application’s schema. However, if migrations don’t contain the methods you need to
be able to do what you need to do, you’ll need to drop down to databasespecific code. Rails provides two ways to do this. One is with options arguments
to methods like add_column(). The second is the execute() method.
When you use options or execute(), you might well be tying your migration to a
specific database engine, because any SQL you provide in these two locations
uses your database’s native syntax.
A common example in our migrations is the addition of foreign key constraints
to a child table.

report erratum • discuss

400

•

Chapter 23. Migrations

We could do this by adding a method such as the following to our migration
source file:
def foreign_key(from_table, from_column, to_table)
constraint_name = "fk_#{from_table}_#{to_table}"
execute %{
CREATE TRIGGER #{constraint_name}_insert
BEFORE INSERT ON #{from_table}
FOR EACH ROW BEGIN
SELECT
RAISE(ABORT, "constraint violation: #{constraint_name}")
WHERE
(SELECT id FROM #{to_table} WHERE
id = NEW.#{from_column}) IS NULL;
END;
}
execute %{
CREATE TRIGGER #{constraint_name}_update
BEFORE UPDATE ON #{from_table}
FOR EACH ROW BEGIN
SELECT
RAISE(ABORT, "constraint violation: #{constraint_name}")
WHERE
(SELECT id FROM #{to_table} WHERE
id = NEW.#{from_column}) IS NULL;
END;
}
execute %{
CREATE TRIGGER #{constraint_name}_delete
BEFORE DELETE ON #{to_table}
FOR EACH ROW BEGIN
SELECT
RAISE(ABORT, "constraint violation: #{constraint_name}")
WHERE
(SELECT id FROM #{from_table} WHERE
#{from_column} = OLD.id) IS NOT NULL;
END;
}
end

Within the up() migration, we can call this new method using this:
def up
create_table ... do
end
foreign_key(:line_items, :product_id, :products)
foreign_key(:line_items, :order_id, :orders)
end

report erratum • discuss

Advanced Migrations

•

401

However, we may want to go a step further and make our foreign_key() method
available to all our migrations. To do this, create a module in the application’s
lib directory, and add the foreign_key() method.
This time, however, make it a regular instance method, not a class method:
module MigrationHelpers
def foreign_key(from_table, from_column, to_table)
constraint_name = "fk_#{from_table}_#{to_table}"
execute %{
CREATE TRIGGER #{constraint_name}_insert
BEFORE INSERT ON #{from_table}
FOR EACH ROW BEGIN
SELECT
RAISE(ABORT, "constraint violation: #{constraint_name}")
WHERE
(SELECT id FROM #{to_table} WHERE id = NEW.#{from_column}) IS NULL;
END;
}
execute %{
CREATE TRIGGER #{constraint_name}_update
BEFORE UPDATE ON #{from_table}
FOR EACH ROW BEGIN
SELECT
RAISE(ABORT, "constraint violation: #{constraint_name}")
WHERE
(SELECT id FROM #{to_table} WHERE id = NEW.#{from_column}) IS NULL;
END;
}
execute %{
CREATE TRIGGER #{constraint_name}_delete
BEFORE DELETE ON #{to_table}
FOR EACH ROW BEGIN
SELECT
RAISE(ABORT, "constraint violation: #{constraint_name}")
WHERE
(SELECT id FROM #{from_table} WHERE #{from_column} = OLD.id) IS NOT NULL;
END;
}
end
end

We can now add this to any migration by adding the following lines to the top
of our migration file:
➤ require "migration_helpers"

class CreateLineItems < ActiveRecord::Migration
➤

extend MigrationHelpers

report erratum • discuss

402

•

Chapter 23. Migrations

The require line brings the module definition into the migration’s code, and the
extend line adds the methods in the MigrationHelpers module into the migration
as class methods. We can use this technique to develop and share any number
of migration helpers.
(And, if you’d like to make your life even easier, someone has written a plugin1
that automatically handles adding foreign key constraints.)

Custom Messages and Benchmarks
Although not exactly an advanced migration, something that is useful to do
within advanced migrations is to output our own messages and benchmarks.
We can do this with the say_with_time() method:
def up
say_with_time "Updating prices..." do
Person.all.each do |p|
p.update_attribute :price, p.lookup_master_price
end
end
end

say_with_time() prints the string passed before the block is executed and prints

the benchmark after the block completes.

23.5 When Migrations Go Bad
Migrations suffer from one serious problem. The underlying DDL statements
that update the database schema are not transactional. This isn’t a failing in
Rails—most databases just don’t support the rolling back of create table, alter
table, and other DDL statements.
Let’s look at a migration that tries to add two tables to a database:
class ExampleMigration < ActiveRecord::Migration
def change
create_table :one do ...
end
create_table :two do ...
end
end
end

In the normal course of events, the up() method adds tables, one and two, and
the down() method removes them.

1.

http://wiki.rubyonrails.org/rails/pages/AvailableGenerators

report erratum • discuss

Schema Manipulation Outside Migrations

•

403

But what happens if there’s a problem creating the second table? We’ll end
up with a database containing table one but not table two. We can fix whatever
the problem is in the migration, but now we can’t apply it—if we try, it will
fail because table one already exists.
We could try to roll the migration back, but that won’t work. Because the
original migration failed, the schema version in the database wasn’t updated,
so Rails won’t try to roll it back.
At this point, you could mess around and manually change the schema information and drop table one. But it probably isn’t worth it. Our recommendation
in these circumstances is simply to drop the entire database, re-create it, and
apply migrations to bring it back up-to-date. You’ll have lost nothing, and
you’ll know you have a consistent schema.
All this discussion suggests that migrations are dangerous to use on production databases. Should you run them? We really can’t say. If you have
database administrators in your organization, it’ll be their call. If it’s up to
you, you’ll have to weigh the risks. But, if you decide to go for it, you really
must back up your database first. Then, you can apply the migrations by
going to your application’s directory on the machine with the database role
on your production servers and executing this command:
depot> RAILS_ENV=production rake db:migrate

This is one of those times where the legal notice at the start of this book kicks
in. We’re not liable if this deletes your data.

23.6 Schema Manipulation Outside Migrations
All the migration methods described so far in this chapter are also available
as methods on Active Record connection objects and so are accessible within
the models, views, and controllers of a Rails application.
For example, you might have discovered that a particular long-running report
runs a lot faster if the orders table has an index on the city column. However,
that index isn’t needed during the day-to-day running of the application, and
tests have shown that maintaining it slows the application appreciably.
Let’s write a method that creates the index, runs a block of code, and then
drops the index. This could be a private method in the model or could be
implemented in a library.

report erratum • discuss

404

•

Chapter 23. Migrations

def run_with_index(column)
connection.add_index(:orders, column)
begin
yield
ensure
connection.remove_index(:orders, column)
end
end

The statistics-gathering method in the model can use this as follows:
def get_city_statistics
run_with_index(:city) do
# .. calculate stats
end
end

What We Just Did
While we had been informally using migrations throughout the development
of the Depot application and even into deployment, in this chapter we saw
how migrations are the basis for a principled and disciplined approach to
configuration management of the schema for your database.
You learned how to create, rename, and delete columns and tables; to manage
indices and keys; to apply and back out entire sets of changes; and even to
mix in your own custom SQL into the mix, all in a completely reproducible
manner.
At this point we’ve covered the externals of Rails. The next few chapters are
going to delve deeper. We are going to show you how to take Rails apart and
put it back together. The first stop along the way is to show you how to use
select Rails classes and methods outside the context of a web server.

report erratum • discuss

In this chapter, we’ll see
• invoking Rails methods,
• accessing Rails application data, and
• remote manipulation of databases.

CHAPTER 24

Nonbrowser Applications
Previous chapters focused primarily on server-to-human communications,
mostly via HTML. But not all web interactions need to directly involve a person.
This chapter focuses accessing your Rails application and data from within
a stand-alone script.
There are a variety of reasons why you might want to access portions of your
Rails application from outside a browser. For example, you may desire to
have your database loaded or synchronized periodically using a background
job kicked off by a utility like cron. You may have existing applications, perhaps
even Rails applications, that want to directly access the data in (another)
Rails application, possibly even on a different machine. You might just want
a command-line interface, not because it is required but just because.
Whatever your reasons, Rails is there for you. As you will see, you will be able
to pull in as little or as much of Rails as you need to get your job done.
We will start with the assumption that your application is on the same
machine as your installation of Rails and your data, and then we will proceed
to describing how you can do the same things on a remote machine.

24.1 A Stand-Alone Application Using Active Record
One of the first things you will want unfettered access to is your data. You
will be pleased to know that you can make full use of Active Record from
within a stand-alone application. First, we will show you the “hard” way to
do so (the “scare quotes” is because it isn’t all that hard—remember it is Rails
we are talking about here, after all). Then we will show you the easy way.
We will start with a stand-alone program that uses Active Record to wrap a
table of orders in a SQLite 3 database. After finding the order with a particular

report erratum • discuss

406

•

Chapter 24. Nonbrowser Applications

id, it modifies the purchaser’s name and saves the result in the database,
updating the original row.
require "rubygems"
require "active_record"
ActiveRecord::Base.establish_connection(:adapter => "sqlite3",
:database => "db/development.sqlite3")
class Order < ActiveRecord::Base
end
order = Order.find(1)
order.name = "Dave Thomas"
order.save

That’s all there is to it—in this case no configuration information (apart from
the database connection stuff) is required. Active Record figured out what we
needed based on the database schema itself and took care of all of the necessary details.
Now that you have seen the “hard” way, let’s see the easy way—the one where
Rails will handle the connection for you and load all of your models.
require "config/environment.rb"
order = Order.find(1)
order.name = "Dave Thomas"
order.save

For this to work, Ruby will need to find the config/environment.rb for the application
that you want to load. You can do this by specifying the full path to this file
on the require statement or by including path in the RUBYLIB environment
variable. Another environment variable to watch out for is RAILS_ENV, which is
used to select from the development, test, and production environments.
Once we have required this one file, we have access to roughly the same parts
of our applications as we did when we used rails console in Would the Last Admin
to Leave…, on page 204.
That was done all with a single require. It couldn’t be easier. But believe it or
not, at times you will want to access only a portion of the features that Rails
provides, outside the context of a Rails application. We cover that next.

24.2 A Library Function Using Active Support
Active Support is a set of libraries shared by all Rails components. Some of
what’s in there is intended for Rails’ internal use; however, all of it is available
for use by non-Rails applications.

report erratum • discuss

A Library Function Using Active Support

•

407

This could be important if you develop a Rails application and in the course
of that development you produce a set of classes or even just a set of methods
that you would like to make use of in a non-Rails application. You start by
copying and pasting this code into a separate file and then find out that it
doesn’t run—not because this logic is dependent on your application in any
way but because it uses other methods and classes that Rails provides.
We will start with a brief survey of some of the most important of these and
along the way show how they can be made available to your application.

Core Extensions (core-ext)
Active Support extends some of Ruby’s built-in classes in interesting, useful,
and sometimes whimsical ways. In this section, we’ll quickly list the most
popular of these core extensions.
• Array: second(), third(), fourth(), fifth() and forty_two(). These complement the
first() and last() methods provided by Ruby itself.
• CGI: escape_skipping_slashes(). As the name implies, it differs from escape() in
that it doesn’t escape slashes.
• Class: Accessors for class attributes, delegating accessors, inheritable
readers and writers, and descendants (aka subclasses). These methods
are too numerous to enumerate; see the documentation for details.
• Date: yesterday(), future?(), next_month(), and many, many more.
• Enumerable: group_by(), sum(), each_with_object(), index_by(), many?(), and exclude?().
• File: atomic_write(), and path().
• Float: Adds an optional precision argument to round().
• Hash: diff(), deep_merge(), except(), stringify_keys(), symbolize_keys(), reverse_merge(),
and slice(). Many of these methods also have variants ending in a exclamation point.
• Integer: ordinalize(), multiple_of?(). months(), years(). See also Numeric.
• Kernel: debugger(), breakpoint(). silence_warnings(), enable_warnings().
• Module: Accessors for module attributes, aliasing support, delegation,
deprecation, internal readers and writers, synchronization, and parentage.
• Numeric: bytes(), kilobytes(), megabytes(), and so on; seconds(), minutes(), hours(),
and so on.

report erratum • discuss

408

•

Chapter 24. Nonbrowser Applications

• Object: blank?(), present?(), duplicable?(), instance_values(), instance_variable_() names(),
returning(), and try().
• String: exclude?(), pluralize(), singularize(), camelize(), titleize(), underscore(), dasherize(),
demodulize(), parameterize(), tableize(), classify(), humanize(), foreign_key(), constantize(),
squish(), mb_chars(), at?(), from(), to(), first(), last(), to_time(), to_date(), and try().
• Time: yesterday(), future?(), advance(), and many, many more.
As you can see, this is a fairly long list. These methods tend to be fairly small;
many are only a single line of code. Although you will probably only ever use
a small percentage of these, all of them are available for use in your Rails
application.
As you can also see, there is a lot there. Most of it you won’t ever directly use.
However, you’ll quickly find yourself adopting a small portion of these additional methods as if they were part of the Ruby language itself. Although all
of these methods are documented online,1 the best way to learn is often to
experiment directly by using rails console. Here are a few things to try:
•
•
•
•
•

2.years.ago
[1,2,3,4].sum
5.gigabytes
"man".pluralize
String.methods.sort

Because there is no one best way to identify what subset works for you,
simply be aware that these methods exist and check the documentation when
you find yourself with what seems to be a common need because the Rails
developers may have already added the method that you find missing.

Additional Active Support Classes
In addition to extending the base objects provided by Ruby, Active Support
provides plenty of additional functionality. More so than with the core extensions, these classes tend to support specific needs of other Rails components,
but you are welcome to make use of these functions directly.
• BasicObject: A backport of Ruby 1.9’s class of the same name to Ruby
1.8.
• Benchmarkable: Measures the execution time of a block in a template and
records the results to the log.

1.

http://as.rubyonrails.org/

report erratum • discuss

A Library Function Using Active Support

•

409

David says:

Why Extending Base Classes Doesn’t Lead to the
Apocalypse
The awe that seeing 5.months + 30.minutes for the first time is usually replaced by a state
of panic shortly thereafter. If everyone can just change how integers work, won’t that
lead to an utterly unmaintainable spaghetti land of hell? Yes, if everyone did that all
the time, it would. But they don’t, so it doesn’t.
Don’t think of Active Support as a collection of random extensions to the Ruby language that invites everyone and their brother to add their own pet feature to the string
class. Think of it as a dialect of Ruby spoken universally by all Rails programmers.
Because Active Support is a required part of Rails, you can always rely on that 5.months
will work in any Rails application. That negates the problem of having a thousand
personal dialects of Ruby.
Active Support gives us the best of both worlds when it comes to language extensions.
It’s contextual standardization.

• Cache::Store: Various implementations of caches, based on files or memory; with synchronized or compressed as options.
• Callbacks: Provide hooks into the life cycle of an object.
• Concern and Dependencies: Helps manage dependencies in a modular
way.
• Configurable: Provides a config Hash class variable.
• Deprecation: Provides behavior, reporting, and wrapping to support deprecation of methods.
• Duration: Additional methods such as ago() and since().
• Gzip: Convenience methods to compress() and decompress() a String.
• HashWithIndifferentAccess: Allows both params[:key] and params['key'].
• I18n: Internationalization support.
• Inflections: Handles English’s inconsistent rules for pluralization.
• JSON: JavaScript Object Notation encoding and decoding methods.
• LazyLoadHooks: Support for deferred initialization of modules.
• Memoizable: Caches the result of a method call.

report erratum • discuss

410

•

Chapter 24. Nonbrowser Applications

• MessageEncryptor: Encrypts values that are to be stored someplace
untrustworthy.
• MessageVerifier: Generates and verifies signed messages (to prevent
tampering).
• MultiByte: Encoding support (primarily for Ruby 1.8.7).
• Notifications: Instrumentation API.
• OptionMerger: Deep merge lambda expressions.
• OrderedHash and OrderedOptions: Provides ordered hash support (primarily for Ruby 1.8.7).
• Railtie: Defines core objects that the rest of the framework can depend
on.
• Rescueable: Eases exception handling.
• SecureRandom: Generates random numbers suitable for generating session
keys in HTTP cookies.
• StringInquirer: Provides a prettier way to test for equality.
• TestCase: Testing framework independent interface to test cases.
• Time and TimeWithZone: Even more support for time calculations and
conversions.
So although this book will not go into the (currently) forty-nine methods and
counting that, for example, TimeWithZone alone provides, the previous list will
enable you to find the functions you need in the guides and API documentation. But what this book will do is show you how you can use these methods
in your stand-alone application:
require "rubygems"
require "active_support/time"
Time.zone = 'Eastern Time (US & Canada)'
puts Time.zone.now

So if, like most people, you find yourself addicted to one or more of these
extensions, you can simply require what you need (for example, require "active_
support/basic_object" or require "active_support/core_ext") or pull in everything with require
"active_support/all".

Using Action View Helpers
OK, so although this doesn’t exactly fall under the category of Active Support,
it is close enough. What applies to Active Support also applies to other parts

report erratum • discuss

A Remote Application Using Active Resource

•

411

of Rails, though most routing, controllers, and Action View methods tend to
be relevant only to the processing of an active web request.
One notable exception is some of the Action View helpers. Here’s an example
of how you can access an Action View helper from a stand-alone application:
require "rubygems"
require "action_view"
require "action_view/helpers"
include ActionView::Helpers::DateHelper
puts distance_of_time_in_words_to_now(Time.parse("December 25"))

All in all, this is only slightly more work than getting access to the much more
commonly needed Active Support methods, but it’s still quite doable.
At this point, we’ve covered accessing some or all of Rails functionality from
scripts running on the same machine as the server; now let’s move on to
accessing your Rails application remotely.

24.3 A Remote Application Using Active Resource
When writing an application, you may very well find yourself in a situation
where not all of the data resides neatly tucked away and categorized in your
database. It may not be in a database. It might not even be on your machine
at all. That’s what web services are about. And Active Resource is Rails’ take
on web services. Note that these are web services with a lowercase w and a
lowercase s, not Web Services as in SOAP and WSDL and UDDI.

Accessing and Updating Simple Attributes
We will demonstrate Active Resource with live examples, picking up where
we left off with the Depot application. The key difference is that this time we
will be remotely accessing the Depot application via a client application. And
for a client, we will use rails console. First, check to make sure the Depot server
is running. Then let’s create the client:
work> rails new depot_client
work> cd depot_client

Now, let’s write a stub for the Product model:
Download rails32/depot_client/app/models/product.rb
class Product < ActiveResource::Base
self.site = 'http://dave:secret@localhost:3000/'
end

There really isn’t much to it. The Product class inherits from the ActiveResource::Base
class. Inside, there is a single statement that identifies username, password,

report erratum • discuss

412

•

Chapter 24. Nonbrowser Applications

host name, and port number. In a real-life application, the user and password
would be obtained separately and not hard-coded into the model, but at this
point, we are just exploring the concepts. If you completed the HTTP basic
exercise on page 207, you can put that stub to use:
depot_client> rails console
Loading development environment (Rails 3.2.0)
>> Product.find(3).title
=> "Programming Ruby 1.9"

Success! Let’s be a little bolder. How about we have a $5 off sale on this book?
depot_client> rails console
Loading development environment (Rails 3.2.0)
>> p = Product.find(3)
=> #<Product:0x282e7ac @prefix_options={}, ... >
>> puts p.price
49.5
=> nil
>> p.price = BigDecimal.new(p.price)-5
=> #<BigDecimal:7f88f8ebfef0,'0.3795E2',18(36)>
>> p.save
=> true

While this is clearly a lower-level interface in that you have to convert the
string representation of the price to a format that can be manipulated, you
can see that it is functional. We’ll see shortly how to make the data types
pass on through. Meanwhile, we can easily verify whether this worked by
simply visiting the store in our browser:

We don’t know about you, but to us Active Resource seems to be so sufficiently
advanced technology as to be indistinguishable from magic.

report erratum • discuss

A Remote Application Using Active Resource

•

413

Relationships and Collections
Flush with success with Products, let’s move on to Orders. We start by writing a
stub:
Download rails32/depot_client/app/models/order.rb
class Order < ActiveResource::Base
self.site = 'http://dave:secret@localhost:3000/'
end

Looks good. Let’s try it:
depot_client> rails console
>> Order.find(1).name
=> "Dave Thomas"
>> Order.find(1).line_items
NoMethodError: undefined method `line_items' for #<Order:0x2818970>

OK, at this point, we need to understand how things work under the covers.
Back to theory, but not to worry, it’s not much.
The way the magic works is that it exploits all the REST and JSON interfaces
that the scaffolding provides. To get a list of products, it goes to http://localhost:3000/products.json. To fetch product #2, it will GET http://localhost:3000/products/2.json. To save changes to product #2, it will PUT the
updated product to http://localhost:3000/products/2.json.
So, that’s what the magic is—producing URLs, much like what was discussed
in Chapter 20, Action Dispatch and Action Controller, on page 307. And producing (and consuming) JSON, as we discussed in Selecting a Data Representation,
on page 316. Let’s see that in action. First we make line_items a nested resource
under orders. We do that by editing the config.routes file in the server application:
resources :orders do
resources :line_items
end

Now change the line items controller to look for the :order_id in the params and
treat it as part of the line item. The problem is that we changed what this
method was expecting in Iteration D3 on page 110. So, we simply modify the
code to handle both types of input:

➤
➤
➤
➤

Download rails32/depot_u/app/controllers/line_items_controller.rb
def create
@cart = current_cart
if params[:line_item]
# ActiveResource
params[:line_item][:order_id] = params[:order_id]
@line_item = LineItem.new(params[:line_item])

report erratum • discuss

414
➤
➤

➤

•

Chapter 24. Nonbrowser Applications

else
# HTML forms
product = Product.find(params[:product_id])
@line_item = @cart.add_product(product.id)
end
respond_to do |format|
if @line_item.save
format.html { redirect_to store_url }
format.js
{ @current_item = @line_item }
format.json { render json: @line_item,
status: :created, location: @line_item }
else
format.html { render action: "new" }
format.json { render json: @line_item.errors,
status: :unprocessable_entity }
end
end
end

Let’s fetch the data, just to see what it looks like:
[{"cart_id":null,"created_at":"2011-06-08T12:55:47Z","id":10,
"order_id":1,"price":"49.5","product_id":3,"quantity":1,
"updated_at":"2011-06-08T12:56:41Z"},
{"cart_id":null,"created_at":"2011-06-08T13:00:34Z","id":11,
"order_id":2,"price":"42.95","product_id":2,"quantity":2,
"updated_at":"2011-06-08T13:00:38Z"}]

Although the default format is JSON, you can also use XML as an alternative.
First we’ll need to enable XML as a format for the actions we wish to use.
Download rails32/depot_u/app/controllers/line_items_controller.rb
def index
@line_items = LineItem.all
respond_to do |format|
format.html # index.html.erb
format.json { render json: @line_items }
format.xml { render xml: @line_items }
end
end
<?xml version="1.0" encoding="UTF-8"?>
<line-items type="array">
<line-item>
<price type="decimal">49.5</price>
<created-at type="datetime">2010-02-11T03:11:44Z</created-at>
<product-id type="integer">3</product-id>
<quantity type="integer">1</quantity>
<order-id type="integer">1</order-id>
<updated-at type="datetime">2010-02-11T03:12:11Z</updated-at>

report erratum • discuss

A Remote Application Using Active Resource

•

415

<id type="integer">10</id>
<cart-id type="integer" nil="true"></cart-id>
</line-item>
<line-item>
<price type="decimal">42.95</price>
<created-at type="datetime">2010-02-11T03:14:18Z</created-at>
<product-id type="integer">2</product-id>
<quantity type="integer">2</quantity>
<order-id type="integer">102</order-id>
<updated-at type="datetime">2010-02-11T03:14:25Z</updated-at>
<id type="integer">11</id>
<cart-id type="integer" nil="true"></cart-id>
</line-item>
</line-items>

Note that data types are included in this output. This means that instead of
seeing dates as ISO 8601/RFC 3339–formatted strings and decimals as simple
strings, you will see these attributes as dates and decimals. To take advantage
of this, simply set format to :xml in your client classes.
Now let’s give Dave 20 percent off on his first purchase:
>> LineItem.format = :xml
=> :xml
>> li = LineItem.find(:all, :params => {:order_id=>1}).first
=> #<LineItem:0x2823334 @prefix_options={:order_id=>1}, ... >
>> puts li.price
36.0
=> nil
>> li.price*=0.8
=> 28.8

So, everything here is working as it should. One thing to note is the use of
:params. This is processed exactly as you would expect for URL generations.
Parameters that match the site template provided for the ActiveResource class
will be replaced. And parameters that remain will be tacked on as query
parameters. The server uses the URL for routing and makes the parameters
available as params array.
If you now try to save this object, you’ll get a 406 response code indicating
that XML is not acceptable for this action. To enable this, you either have to
set LineItem.format to :json or update the update() in the LineItemsController to support
XML as a response format.
Finally, let’s add a line item to an order:

report erratum • discuss

416

•

Chapter 24. Nonbrowser Applications

>> li2 = LineItem.new(:order_id=>1, :product_id=>2, :quantity=>1,
>> :price=>0.0)
=> #<LineItem:0x7fd986812b00 @prefix_options={},
@attributes={"price"=>0, "product_id"=>2, "quantity"=>1, "order_id"=>1}>
>> li2.save
=> true

Pulling It All Together
Although ActiveResource at first seems like a bit of magic, it simply relies heavily
on the concepts described earlier in this book. Here are a few pointers:
• Authentication uses the underlying authentication mechanism that your
website already supports and doesn’t go against the grain of the Web, like
some other protocols tend to do. In any case, nobody can do anything
with Active Resource that they couldn’t already do.
Be aware that if you are using basic authentication, you want to use
Transport Layer Security (TLS), also known as Secure Sockets Layer (SSL)
or HTTPS, to ensure that passwords can’t be sniffed.
• Although Active Resource doesn’t make effective use of sessions or cookies,
this doesn’t mean your server isn’t continuing to produce them. Either
you want to turn off sessions for the interfaces used by Active Resource
or you want to make sure you use cookie-based sessions. Otherwise, the
server will end up managing a lot of sessions that are never needed. See
Rails Sessions, on page 330 for more details.
• In Adding Additional Actions, on page 314, we described collections and
members. ActiveResource defines four class methods for dealing with collections and four instance methods for dealing with members. The names
of these methods are get(), post(), put(), and delete(). The method names determine the underlying HTTP method used.
The first parameter in each of these methods is the name of the collection
or member. This information is simply used to construct the URL. You
may specify additional :params, which either will match values in the self.site
or will be added as query parameters.
You will likely end up using this a lot more than you would expect. Instead
of fetching all orders, you might want to provide an interface that fetches
only the orders that are recent or are overdue. What you can do in any
of these methods is limited only by your imagination.
• Active Resource maps HTTP status codes into exceptions:

report erratum • discuss

A Remote Application Using Active Resource

•

417

301, 302
ActiveResource::Redirection

400
ActiveResource::BadRequest

401
ActiveResource::UnauthorizedAccess

403
ActiveResource::ForbiddenAccess

404
ActiveResource::ResourceNotFound

405
ActiveResource::MethodNotAllowed

409
ActiveResource::ResourceConflict

422
ActiveResource::ResourceInvalid

401..499
ActiveResource::ClientError

• You can provide client-side validations by overriding validation methods
in the ActiveResource base class. This behaves the same as validation does
in ActiveRecord. Server-side validation failures result in a response code of
422, and you can access such failures in the same manner. We covered
validation in Section 7.1, Iteration B1: Validating!, on page 77.
• In addition to self.site, you can separately set self.user and self.password.
• self.timeout enables you to specify how long a web service request should
wait, in seconds, before giving up and raising a Timeout::Error.

What We Just Did
We broke free from the constraints of the browser and accessed Active Support,
Action View, and Active Record methods directly from stand-alone script. This
enables us to produce scripts that can be run from the command line, integrated into existing applications, or run periodically and automatically using
facilities such as cron.

report erratum • discuss

418

•

Chapter 24. Nonbrowser Applications

Finally, we used Active Resource to break free of the constraints of needing
to run your script on the same machine as the application. Although this
requires slightly more setup, it provides a workable, and secure, means to
access the data you have inside a Rails application.
Next up: we will explore other separately installable components that are
included in the bundle when you install Rails.

report erratum • discuss

In this chapter, we’ll see
• XML and HTML templates,
• managing application dependencies,
• scripting tasks, and
• interfacing with a web server.

CHAPTER 25

Rails’ Dependencies
At this point, we have covered base Rails itself. But there is much more to
the story. Much of what makes Rails great is functionality provided by components that Rails builds upon.
These components should be familiar, because you have used each one. Atom
templates, HTML templates, rake db:migrate, bundle install, and rails server should
all be familiar by now.
Although this chapter goes beyond your normal day-to-day activities and
shows how each component can be used in isolation, it is not meant to be an
exhaustive description of any of these components. Each component requires
a small book in itself to do it justice. Instead, the intent of this chapter is to
introduce you to a number of key components in order to provide the background necessary for you to begin self-directed explorations.
We start by introducing you to a number of such dependencies, beginning
with the underlying templating engines that power views. Then we will explore
Bundler, which is the component that is used to manage dependencies. Finally,
we will show how these pieces are put together using Rack and Rake.

25.1 Generating XML with Builder
Builder is a freestanding library that lets you express structured text (such
as XML) in code. A builder template (in a file with an .xml.builder extension)
contains Ruby code that uses the Builder library to generate XML.
Here’s a simple builder template that outputs a list of product names and
prices in XML:

report erratum • discuss

420

•

Chapter 25. Rails’ Dependencies

Download rails32/depot_t/app/views/products/index.xml.builder
xml.div(class: "productlist") do
xml.timestamp(Time.now)
@products.each do |product|
xml.product do
xml.productname(product.title)
xml.price(product.price, currency: "USD")
end
end
end

If this reminds you of the template you created for use with the Atom helper
in Section 12.2, Iteration G2: Atom Feeds, on page 166, that’s because the Atom
helper is built upon the functionality of Builder.
With an appropriate collection of products (passed in from the controller), the
template might produce something such as this:
<div class="productlist">
<timestamp>2011-07-04 08:21:49 -0400</timestamp>
<product>
<productname>CoffeeScript</productname>
<price currency="USD">36.0</price>
</product>
<product>
<productname>Programming Ruby 1.9</productname>
<price currency="USD">49.5</price>
</product>
<product>
<productname>Rails Test Prescriptions</productname>
<price currency="USD">43.75</price>
</product>
</div>

Notice how Builder has taken the names of methods and converted them to
XML tags; when we said xml.price, it created a tag called <price> whose contents
were the first parameter and whose attributes were set from the subsequent
hash. If the name of the tag you want to use conflicts with an existing method
name, you’ll need to use the tag!() method to generate the tag:
xml.tag!("id", product.id)

Builder can generate just about any XML you need. It supports namespaces,
entities, processing instructions, and even XML comments. Take a look at
the Builder documentation for details.

report erratum • discuss

Generating HTML with ERb

•

421

Although HTML looks superficially a lot like XML, it is enough of a different
beast that a different templating engine is generally used to produce HTML.
We cover that next.

25.2 Generating HTML with ERb
At its simplest, an ERb template is just a regular HTML file. If a template
contains no dynamic content, it is simply sent as is to the user’s browser.
The following is a perfectly valid html.erb template:
<h1>Hello, Dave!</h1>
<p>
How are you, today?
</p>

However, applications that just render static templates tend to be a bit boring
to use. We can spice them up using dynamic content:
<h1>Hello, Dave!</h1>
<p>
It's <%= Time.now %>
</p>

If you’re a JSP programmer, you’ll recognize this as an inline expression. Erb
evaluates any code between <%= and %>, converts the results into a string
using to_s(), and finally substitutes that string into the resulting page. The
expression inside the tags can be arbitrary code:
<h1>Hello, Dave!</h1>
<p>
It's <%= require 'date'
DAY_NAMES = %w{ Sunday Monday Tuesday Wednesday
Thursday Friday Saturday }
today = Date.today
DAY_NAMES[today.wday]
%>
</p>

Putting lots of business logic into a template is generally considered to be a
Very Bad Thing, and you’ll risk incurring the wrath of the coding police should
you get caught. We discussed a much better way of handling this with helpers
in Section 21.5, Using Helpers, on page 351.
Sometimes you need code in a template that doesn’t directly generate any
output. If you leave the equals sign off the opening tag, the contents are executed, but nothing is inserted into the template. We could have written the
previous example as follows:

report erratum • discuss

422

•

Chapter 25. Rails’ Dependencies

<% require 'date'
DAY_NAMES = %w{ Sunday Monday Tuesday Wednesday
Thursday Friday Saturday }
today = Date.today
%>
<h1>Hello, Dave!</h1>
<p>
It's <%= DAY_NAMES[today.wday] %>.
Tomorrow is <%= DAY_NAMES[(today + 1).wday] %>.
</p>

In the JSP world, this is called a scriptlet. Again, many folks will chastise you
if they discover you adding code to templates. Ignore them—they’re falling
prey to dogma. There’s nothing wrong with putting code in a template. Just
don’t put too much code in there (and especially don’t put business logic in
a template). As we have already seen, you can use helper methods to successfully resist this temptation.
You can think of the HTML text between code fragments as if each line were
being written by a Ruby program. The <%…%> fragments are added to that
same program. The HTML is interwoven with the explicit code that you write.
As a result, code between <% and %> can affect the output of HTML in the
rest of the template.
For example, consider this template:
<% 3.times do %>
Ho!<br/>
<% end %>

When you insert a value using <%=…%>, the results will be HTML escaped
before being placed directly into the output stream. This is generally what
you want.
If, however, the text you’re substituting contains HTML that you want to be
interpreted, this will cause the HTML tags to be escaped—if you create a string
containing <em>hello</em> and then substitute it into a template, the user will
see <em>hello</em> rather than hello. Rails provides two helpers to address this
case.
The raw() method will cause the string to pass right on through to the output
without escaping. This provides the most amount of flexibility, as well as the
least amount of security.
The sanitize() method offers some protection. It takes a string containing HTML
and cleans up dangerous elements: <form> and <script> tags are escaped, and
on= attributes and links starting javascript: are removed.

report erratum • discuss

Managing Dependencies with Bundler

•

423

The product descriptions in our Depot application were rendered as HTML
(that is, they were marked as safe using the raw() method). This allowed us to
embed formatting information in them. If we allowed people outside our organization to enter these descriptions, it would be prudent to use the sanitize()
method to reduce the risk of our site being attacked successfully.
These two templating engines are just two of the many gems that Rails
depends on. At this point, it makes sense to talk about how such dependencies
are managed.

25.3 Managing Dependencies with Bundler
Dependency management is a deceptively hard problem. During development,
you may choose to install updated versions of gems that you depend on. Once
you do this, you may find yourself not being able to reproduce problems that
occur in production because your runs are picking up different versions of
the gems your application depends on. Or perhaps you see problems that
don’t exist in production.
It turns out that dependencies are every bit as important to manage as your
application source code or database schemas. If you are developing as part
of a team, you want every member of the team to be using the same version
of the dependencies. When you deploy, you want to ensure that the version
of the dependencies that you tested with are installed on the target machine
and are the ones actually used in production.
Bundler1 takes care of this, based on a file named Gemfile that is placed in the
top of your application directory. In this file, you list the dependencies of your
application. Let’s take a closer look at the Gemfile for the Depot application:
Download rails32/depot_u/Gemfile
source 'https://rubygems.org'
gem 'rails', '3.2.0'
# Bundle edge Rails instead:
# gem 'rails', :git => 'git://github.com/rails/rails.git'
gem 'sqlite3'
group :production do
gem 'mysql2'
end

# Gems used only for assets and not required

1.

http://gembundler.com/

report erratum • discuss

424

•

Chapter 25. Rails’ Dependencies

# in production environments by default.
group :assets do
gem 'sass-rails',
'~> 3.2.3'
gem 'coffee-rails', '~> 3.2.1'
# See https://github.com/sstephenson/execjs#readme for more supported runtimes
# gem 'therubyracer'
gem 'uglifier', '>= 1.0.3'
end
gem 'jquery-rails'
# To use ActiveModel has_secure_password
gem 'bcrypt-ruby', '~> 3.0.0'
# To use Jbuilder templates for JSON
# gem 'jbuilder'
# Use unicorn as the web server
# gem 'unicorn'
# Deploy with Capistrano
gem 'capistrano'
# To use debugger
# gem 'ruby-debug19', :require => 'ruby-debug'
gem 'will_paginate', '~> 3.0'

The first line specifies where to find new gems and new versions of existing
gems. Feel free to repeat this line in order to list your own private gem
repositories.
The next line lists what version of Rails to load. Note that it specifies a specific
version. After this is a comment that you could use as an alternative in order
to run the latest version of Rails.
The remaining lines list a few gems that you are using and a few gems that
you might consider using. Some are placed in groups named :development, :test,
or :production and will be made available only in those environments. Others
include an optional :require parameter, which specifies the name to use on a
require statement for the cases where it differs from the gem name.
On the line for sass-rails you see a version specifier that is preceded by a comparison operator. Although Gemfile files support a number of such operators,
only two are commonly used. >= is for the unfortunately all too rare condition
where the author of the Gemfile can be trusted to maintain strict backward

report erratum • discuss

Managing Dependencies with Bundler

•

425

compatibility so all that is needed to be specified is a minimum version
number.
~> is more widely recommended. Essentially all of the parts of the version,

with the exception of the last part, must be matched exactly, and the last
part specifies a minimum. So, ~> 3.1.4 matches any version that starts with
a 3.1 and is not less than 3.1.4. Similarly, ~> 3.0 means any version string that
starts with a 3..
A Gemfile has a companion file, named Gemfile.lock. This second file is generally
updated by one of two commands: bundle install and bundle update. The difference
between the two is rather subtle.
Before proceeding, it is helpful to look at a Gemfile.lock file. Here is a small
excerpt:
GEM
specs:
actionmailer (3.1.0)
actionpack (= 3.1.0)
mail (~> 2.3.0)
actionpack (3.1.0)
activemodel (= 3.1.0)
activesupport (= 3.1.0)
builder (~> 3.0.0)
erubis (~> 2.7.0)
i18n (~> 0.6)
rack (~> 1.3.0)
rack-cache (~> 1.0.1)
rack-mount (~> 0.8.1)
rack-test (~> 0.6.0)
sprockets (~> 2.0.0)
tzinfo (~> 0.3.27)

bundle install will use the Gemfile.lock as a starting point, and it will install only

the versions of the various gems as specified in this file. For this reason, it is
important that this file gets checked into your version control system, because
this will ensure that your colleagues and deployment targets will all be using
the exact same configuration.
bundle update will (unsurprisingly) update one or more named gems and will

update the Gemfile.lock accordingly. If you want to use a specific version of a
particular gem, the workflow would be to edit the Gemfile to express your
constraints and then run bundle update listing the gems that you want to update.
If you don’t specify a list of gems, Bundler will attempt to update all gems—this
is generally not recommended, particular when close to deployment.

report erratum • discuss

426

•

Chapter 25. Rails’ Dependencies

Bundler also has a runtime component that is used to ensure that your
application strictly loads only the versions of the gems listed in Gemfile.lock.
We will explore that further by looking into how the server operates.

25.4 Interfacing with the Web Server with Rack
Rails runs your application in the context of a web server. So far, we have
used two separate web servers: WEBRick, which comes built into the Ruby
language itself, and Phusion Passenger, which integrates with the Apache
HTTP web server. There are a number of other choices available, including
Mongrel, Lighttpd, and Unicorn.
Based on this, you might come to the conclusion that Rails has code that
allows it to plug into each of these web servers. In earlier releases of Rails,
this was true; as of Rails 2.3, this integration was delegated to a gem named
Rack.
So, Rails integrates with Rack, Rack integrates with (for example) Passenger,
and Passenger integrates with Apache httpd.
Although generally this integration is invisible and taken care of for you when
you run the command rails server, a file named config.ru is provided that allows
you to directly start your application under Rack:
Download rails32/depot_u/config.ru
# This file is used by Rack-based servers to start the application.
require ::File.expand_path('../config/environment',
run Depot::Application

__FILE__)

You can use this file to start your Rails server with the following command:
rackup

Starting your server in this way is completely equivalent to running rails server.
To demonstrate the power of what you can do with Rack alone, let’s start over
with a bare-bones Rack application:
Download rails32/depot_u/app/store.rb
require 'builder'
require 'active_record'
ActiveRecord::Base.establish_connection(
adapter: 'sqlite3',
database: 'db/development.sqlite3')
class Product < ActiveRecord::Base
end

report erratum • discuss

Interfacing with the Web Server with Rack

•

427

class StoreApp
def call(env)
x = Builder::XmlMarkup.new :indent=>2
x.declare! :DOCTYPE, :html
x.html do
x.head do
x.title 'Pragmatic Bookshelf'
end
x.body do
x.h1 'Pragmatic Bookshelf'
Product.all.each do |product|
x.h2 product.title
x << "
#{product.description}\n"
x.p product.price
end
end
end
response = Rack::Response.new(x.target!)
response['Content-Type'] = 'text/html'
response.finish
end
end

In this application, we are taking advantage of a number of things we have
learned so far. The first thing we do is to directly require active_record and builder.
Then we establish a connection with our database and define a class for our
Product. We won’t need to do any of this once we integrate this application with
our Rails application, but for now we are going totally bare-bones.
Then comes the application itself. It is a simple class that defines a single
method named call(). This method accepts a single parameter named env that
contains information about the request and is not used by this application.
This application uses Builder to create a simple HTML rendering of a product
list and then builds a response, sets the content type, and calls finish().
By creating a new rackup file, we can run this as a stand-alone application:
Download rails32/depot_u/store.ru
require 'rubygems'
require 'bundler/setup'
require './app/store'
use Rack::ShowExceptions
map '/store' do

report erratum • discuss

428

•

Chapter 25. Rails’ Dependencies

run StoreApp.new
end

The first thing this script does is to initialize Bundler, which will make available the right versions of all of the gems that will be required. Then it requires
the store application.
Next, it pulls one of the standard middleware classes provided with Rack;
this one formats a stack traceback when things go wrong. Middleware in Rack
is like filters in Rails—both can inspect requests and adjust the responses
produced.
You can see the list of middlewares that Rails provides for Rails applications
using the command rake middleware.
Finally, we map the store URI to this application.
We can start this application using the rackup command:
rackup store.ru

By default, this rackup starts servers using port 9292 instead of port 3000.
You can select the port using the -p option.
Visiting this page using your browser results in the rather plain rendering of
the product listings, as shown in Figure 54, A minimal, but workable, product
listing, on page 429.
The disadvantage of a native Rack application as compared to a Rails application is that less is taken care of for it. The primary advantage is that it
therefore is possible to avoid some of the overhead of Rails and therefore
process more requests per second.
In most cases, you won’t want to create a completely stand-alone application
but will want to have portions of your site bypass Rails’ controller processing.
You do this by defining a route:
Download rails32/depot_u/config/routes.rb
➤ require './app/store'
Depot::Application.routes.draw do
➤
match 'store' => StoreApp.new
get 'admin' => 'admin#index'
controller :sessions do
get 'login' => :new
post 'login' => :create
delete 'logout' => :destroy
end
scope '(:locale)' do
resources :users

report erratum • discuss

Automating Tasks with Rake

•

429

Figure 54—A minimal, but workable, product listing

resources :orders do
resources :line_items
end
resources :line_items
resources :carts
resources :products do
get :who_bought, on: :member
end
root to: 'store#index', as: 'store'
end
end

The server is not the only place where Rails components are used. We complete
this chapter with a description of a tool you can use to orchestrate the execution of tasks.

25.5 Automating Tasks with Rake
Rake is a program that often is taken for granted. It is used to automate tasks,
particularly tasks that may have a number of dependencies. The tasks are
defined by the Rakefile that you will find in your application’s root directory.

report erratum • discuss

430

•

Chapter 25. Rails’ Dependencies

db:setup is an example of such a task. To see what subtasks are involved, run

Rake with the --trace and --dry-run options:
$ rake --trace --dry-run db:setup
(in /home/rubys/work/depot)
** Invoke db:setup (first_time)
** Invoke db:create (first_time)
** Invoke db:load_config (first_time)
** Invoke rails_env (first_time)
** Execute (dry run) rails_env
** Execute (dry run) db:load_config
** Execute (dry run) db:create
** Invoke db:schema:load (first_time)
** Invoke environment (first_time)
** Execute (dry run) environment
** Execute (dry run) db:schema:load
** Invoke db:seed (first_time)
** Invoke db:abort_if_pending_migrations (first_time)
** Invoke environment
** Execute (dry run) db:abort_if_pending_migrations
** Execute (dry run) db:seed
** Execute (dry run) db:setup

Executing the right steps in the right order is vital for repeatable deployments;
that’s why this particular task was used in Loading the Database, on page
235.
You can see a list of available tasks using rake --tasks. The tasks that Rails
provides are just a starter set; you are welcome to create more tasks. You do
so simply by creating new files in the lib/tasks directory containing Ruby code.
Here’s an example that will back up the production database:
Download rails32/depot_u/lib/tasks/db_backup.rake
namespace :db do
desc "Backup the production database"
task :backup => :environment do
backup_dir = ENV['DIR'] || File.join(Rails.root, 'db', 'backup')
source = File.join(Rails.root, 'db', "production.db")
dest
= File.join(backup_dir, "production.backup")
makedirs backup_dir, :verbose => true
sh "sqlite3 #{source} .dump > #{dest}"
end
end

report erratum • discuss

Survey of Rails’ Dependencies

•

431

The first line contains a namespace. We put this backup task in the db
namespace.
The second line contains a description. This description will show up when
you list tasks. If you run the rails --tasks command again, you will see that your
new task is included along with the ones that Rails provided.
The next line contains the task as well as any dependencies it might have.
Depending on environment is roughly equivalent to loading everything that rails
console provides.
The block passed to the task is standard Ruby code. In our example, we
determine the source and destination directories (where the destination will
default to db/backup but can be overridden by a DIR parameter on the command
line), then proceed to make the backup directory (if necessary), and finally
execute the sqlite3 dump command.

25.6 Survey of Rails’ Dependencies
A good place to start is by looking back at the Gemfile.lock file. Some of the
names you find in there will be obvious; others will not. To assist with this
exploration, the following is a brief description of the names that you will find
in there.
Of course, as Rails evolves, this list will inevitably change. But by knowing
the name of the component, you have the starting point for further exploration.
A good way to find out more given the name is to go to RubyGems.org,2 enter
the gem name in the search field, select the gem, and then click either the
Documentation or Homepage link.
actionmailer
Part of Rails; see Chapter 13, Task H: Sending Mail, on page 175
actionpack
Part of Rails; see Chapter 20, Action Dispatch and Action Controller, on
page 307
activemodel
Support for Active Record and Active Resource
activerecord
Part of Rails; see Chapter 19, Active Record, on page 269

2.

http://rubygems.org

report erratum • discuss

432

•

Chapter 25. Rails’ Dependencies

activeresource
Part of Rails; see Section 24.3, A Remote Application Using Active Resource,
on page 411
activesupport
Part of Rails; see Section 24.2, A Library Function Using Active Support,
on page 406
rails
Container for the entire framework
railties
Part of Rails; see the bottom of Section 26.3, Finding More at RailsPlugins.org, on page 441 for links to more information on the subject
ansi
Enables ANSI code-based colorization and stylization of output; used by
the turn gem
arel
A relational algebra; used by Active Record
bcrypt-ruby
Secure hash algorithm; used by Active Model
builder
A simple way to create XML markup; see Section 25.1, Generating XML
with Builder, on page 419
capistrano
Welcome to easy deployment; see Section 16.2, Iteration K2: Deploying
Remotely with Capistrano, on page 237
coffee-script
Bridge to the JS CoffeeScript compiler
erubis
The implementation of ERb that Rails uses; see Section 25.2, Generating
HTML with ERb, on page 421
execjs
Lets you run JavaScript code from Ruby; used by coffee-script
highline
IO library for command-line interfaces
hike
Finds files in a set of paths; used by sprockets

report erratum • discuss

Survey of Rails’ Dependencies

•

433

i18n
Internationalization support; see Chapter 15, Task J: Internationalization,
on page 209
jquery-rails
Provides jQuery and the jQuery-ujs driver
mail
Mail support; see Chapter 13, Task H: Sending Mail, on page 175
mime-types
Determine file type based on extension, used by mail
multi-json
Provides swappable JSON backends
mysql
Production database supported by Active Record; see Using MySQL for
the Database, on page 234
net-scp
Copy files securely
net-sftp
Transfer files securely
net-ssh
Connect to remote servers securely
net-ssh-gateway
Tunneling connections over SSH
polyglot
Custom language loaders
rack
Interface between Rails and web servers; see Section 25.4, Interfacing
with the Web Server with Rack, on page 426
rack-cache
HTTP caching for rack
rack-mount
Rack router; see Section 20.1, Dispatching Requests to Controllers, on
page 307
rack-test
Testing API for routes; see Testing Routes, on page 317

report erratum • discuss

434

•

Chapter 25. Rails’ Dependencies

rack-ssl
Middleware to force SSL/TLS
rake
Task automation; see Section 25.5, Automating Tasks with Rake, on page
429
sass
Provides extensions to CSS3
sass-rails
Generator and Asset support for Sass
sprockets
Preprocesses and concatenates JavaScript source files
tilt
Generic interface to multiple Ruby template engines; used by sprockets
turn
Formats Test::Unit results
sqlite3
Development database supported by Active Record
thor
Scripting framework used by the rails command
treetop
Text parsing library, used by mail
tzinfo
Time zone support
uglifier
Compresses JavaScript files

What We Just Did
We explored a small number of Rails’ dependencies and then showed how
dependencies themselves can be managed, integrated with a web server, and
finally orchestrated from the command line. Along the way, we finally found
out what the Rakefile, Gemfile, and Gemfile.lock files are that are in the top of our
application directory.

report erratum • discuss

Survey of Rails’ Dependencies

•

435

Now that we have gone deeper into Rails, the next place to go is to branch
out and to cover external plugins that can be used to extend the base Rails
package that you get when you install Rails.

report erratum • discuss

In this chapter, we’ll see
• adding new classes to your application,
• adding a new templating language, and

CHAPTER 26

Rails Plugins
Since the beginning of this book, we’ve talked incessantly about convention
over configuration in that Rails has sensible defaults for just about everything.
And more recently in the book, we’ve described Rails in terms of the underlying
gems that you get when you install Rails. Now it is time to put those two
thoughts together and reveal that the initial set of gems that Rails provides
you is, itself, a sensible set of defaults—ones that you can both add to and
change.
With Rails 3.1, gems are the primary way in which you plug in new functionality. Instead of describing this in the abstract, we will select a few plugins
and use them to illustrate different aspects of how plugins are installed and
what plugins can do. The fact that many of these plugins turn out to be
immediately useful for your day-to-day work is simply a bonus!
Let’s start with a simple plugin that can literally make you money.

26.1 Credit Card Processing with Active Merchant
In Iteration G1 on page 155 we mentioned that we were temporarily punting
on the handling of credit cards. Being able to actually charge a customer is
clearly an important part of taking an order. Although this functionality isn’t
built into the core of Rails, there is a gem that provides this functionality.
You’ve already seen how you control what gems get loaded by your application:
you do this by editing your Gemfile. Since we are going to cover a number of
such gems in this chapter, let’s go ahead and add all of the ones that we will
cover at once. You can actually add these any place you like; we’ve chosen
to do so immediately under the line adding the dependency on will_paginate.
Download rails32/depot_v/Gemfile
➤ gem 'activemerchant'
➤ gem 'haml', '~> 3.1.1'

report erratum • discuss

438

•

Chapter 26. Rails Plugins

You will note that we follow best practices by specifying a minimum version
and effectively specifying an upper bound on the version number so that this
demo will pick a version that is unlikely to contain an incompatible change.
As for the gems we added, we will cover each in a separate section. This section
will focus on Active Merchant.1
Once you have edited your Gemfile, you can go ahead install these gems, as
well as any gems that they depend on, via bundle install. Additionally, if you
have a Rails server up and running, restart it to pick up these changes. We
won’t be using the server in this section but will shortly. Make sure that the
server is running the Depot application.
To demonstrate this functionality, we will create a small script, which we will
place in the script directory:
Download rails32/depot_v/script/creditcard.rb
credit_card = ActiveMerchant::Billing::CreditCard.new(
number:
'4111111111111111',
month:
'8',
year:
'2009',
first_name: 'Tobias',
last_name: 'Luetke',
verification_value: '123'
)
puts "Is #{credit_card.number} valid?

#{credit_card.valid?}"

There is not much to this script. It creates an instance of an ActiveMerchant::
Billing::CreditCard class and then calls the valid?() on this object. Let’s run it.
$ rails runner script/creditcard.rb
Is 4111111111111111 valid? false

There’s not much to it; it just worked. Note that no require statements were
necessary; simply listing the gem you want in your Gemfile makes the function
available to your application.
At this point, you should be able to see how you could use this functionality
in the Depot application. You know how to add a field to the Orders table via
a migration. You know how to add that field to the view. You know how to
add validation logic to your model, which calls the valid?() method that we used
earlier. If you go to the merchant site, you can even find out how to authorize()
and capture() a payment, though this does require you to have a login and a

1.

http://www.activemerchant.org/

report erratum • discuss

Beautifying Our Markup with Haml

•

439

password with an existing commerce gateway. Once that is set up, you know
how to call this logic from your controller.
Just think: all of that was made possible by the addition of a single line to
your Gemfile.
As we stated at the beginning of this chapter, adding gems to your Gemfile is
the preferred way to extend Rails 3.1. The advantages of doing so are numerous: all of your dependencies are tracked by Bundler, are all preloaded for
immediate use by your application, and can be packed for easy deployment.
At the time of this writing, the instructions for installing ActiveMerchant have
not been updated on their website: they describe three other ways to install
this function, depending on the version of Rails you are using. What we have
described is the method you should use whenever possible.
This was a very simple addition. Let’s move on to something more significant:
something that provides a clear alternative to one of the gems that Rails
depends on.

26.2 Beautifying Our Markup with Haml
Let’s take a look once again at a simple view that we use in the Depot application, in this case, one that presents our storefront:
Download rails32/depot_u/app/views/store/index.html.erb
<% if notice %>
<p id="notice"><%= notice %></p>
<% end %>
<h1><%= t('.title_html') %></h1>
<% @products.each do |product| %>
<div class="entry">
<%= image_tag(product.image_url) %>
<h3><%= product.title %></h3>
<%= sanitize(product.description) %>
<div class="price_line">
<span class="price"><%= number_to_currency(product.price) %></span>
<%= button_to t('.add_html'), line_items_path(product_id: product),
remote: true %>
</div>
</div>
<% end %>

This code gets the job done. It contains the basic HTML, with interspersed
bits of Ruby code enclosed in <% and %> markup. Inside that markup, an

report erratum • discuss

440

•

Chapter 26. Rails Plugins

equals sign is used to indicate that the value of the expression is to be converted to HTML and displayed.
This is not only an adequate solution to the problem at hand; it is also all
that is really needed for a large number of Rails applications. Additionally, it
is an ideal place to start for books—like this one—where some knowledge of
HTML may be presumed, but many of the readers are new to Rails and often
to Ruby itself. The last thing you would want to do in that situation is to
introduce yet another new language.
But now that you are past that learning curve, let’s go ahead and explore a
new language—one that more closely integrates the production of markup
with Ruby code, namely, HTML Abstraction Markup Language (Haml).
To start with, let’s remove the file we just looked at:
$ rm app/views/store/index.html.erb

In its place, let’s create a new file:
Download rails32/depot_v/app/views/store/index.html.haml
- if notice
%p#notice= notice
%h1= t('.title_html')
- @products.each do |product|
.entry
= image_tag(product.image_url)
%h3= product.title
= sanitize(product.description)
.price_line
%span.price= number_to_currency(product.price)
= button_to t('.add_html'), line_items_path(product_id: product),
remote: true

Note the new extension: .html.haml. This indicates that the template is a Haml
template instead of an ERB template.
The first thing you should notice is that the file is considerably smaller. Here’s
a quick overview of what is going on, based on what the first character is on
each line:
• Dashes indicate a Ruby statement that does not produce any output
• Percent signs (%) indicate a HTML element.

report erratum • discuss

Finding More at RailsPlugins.org

•

441

• Equals signs (=) indicate a Ruby expression that does produce output to
be displayed. This can be used on either lines by themselves or following
HTML elements.
• Dots (.) and hash (#) characters may be used to define class and id
attributes, respectively. This can be combined with percent signs or used
stand-alone. When used by itself, a div element is implied.
• A comma at the end of a line containing an expression implies a continuation. In the previous example, the button_to() call is continued across two
lines.
An important thing to note is that indentation is important in Haml. Returning
to the same level of indentation closes the if statement, loop, or tag that is
currently open. In this example, the paragraph is closed before the h1, the h1
is closed before the first div, but the div elements nest, with the first containing
an h3 element and the second containing both a span and a button_to().
As you can also see, all of your familiar helpers are available, things like t(),
image_tag(), and button_to(). In every meaningful way, Haml is as integrated into
your application as ERB is. You can mix and match: you can have some
templates using ERB and others using Haml.
As you have already installed the Haml gem, there truly is nothing more you
need to do. To see this in action, all you need to do is to visit your storefront.
What you should see should match Figure 55, Storefront using Haml, on page
442.
If that looks unremarkable, that’s because it should look exactly like it did
before. And that, if you think about it, is all the more remarkable as the
application layout continues to be implemented as a ERB template and the
index itself is implemented using Haml. Despite this, everything integrates
seamlessly and effortlessly.
Although this clearly is a deeper level of integration than simply adding a
task or a helper, it still is an addition. Next, let’s explore a true replacement.

26.3 Finding More at RailsPlugins.org
At this point, we have covered two plugins. You will find at least two orders
of magnitude more at RailsPlugins.org,2 which at the current time includes
more than 500 plugins, most—but not all—of which work with Rails 3.
Here’s a few more to explore, grouped by categories:
2.

http://www.railsplugins.org/plugins

report erratum • discuss

442

•

Chapter 26. Rails Plugins

Figure 55—Storefront using Haml

• Some plugins implement behavior that was previously in the core of Rails
and has since been moved out. As an example, instead of jQuery, the
Prototype library was the one supported by default by previous versions
of Rails. This has moved into a plugin named prototype-rails.3 Others, like
4
5
acts_as_tree, have thrived as plugins. And still others, like rails_xss, backport
essential functionality from future versions of Rails in order to help with
migration.
• Some plugins actually implement significant pieces of common application
logic and even user interface. The devise6 and authlogic7 plugins implement
user authentication and session management. We implemented these
functions ourselves in Depot, but this is generally something we don’t
recommend. We’ve found that laziness pays: if somebody else has written
a plugin for a function that you need to implement, that’s all the more
time that you can spend on your application.

3.
4.
5.
6.
7.

https://github.com/rails/prototype-rails#readme
https://github.com/rails/acts_as_tree#readme
https://github.com/rails/rails_xss
https://github.com/plataformatec/devise#readme
https://github.com/binarylogic/authlogic#readme

report erratum • discuss

Finding More at RailsPlugins.org

•

443

• Some plugins replace large portions of rails. For example, datamapper8
replaces ActiveRecord. The combination of cucumber,9 rspec,10 and webrat11
can be used separately or together to replace test scripts with plain test
stories, specifications, and browser simulation.
• hoptoad_notifier12 and exception_notification13 will help you monitor errors in your
deployed servers.
Of course, this is but a small fraction of the set of plugins that are available.
And this list is continually growing: there undoubtedly will be many more
available by the time you read this.
Finally, you can obviously create your own plugins. Although doing so is
beyond the scope of this book, you can find out more in the Rails Guides14
and documentation.15

What We Just Did
Although this chapter did cover a few plugins, the purpose of this chapter
wasn’t to cover any particular plugin in depth but to introduce you to some
of the capabilities that plugins can provide.
If we include the gems that we saw in previous chapters, we have seen plugins
that simply add new features (Active Merchant and Capistrano), add some
Rake tasks (Asset Packager), add some view helpers (again, Asset Packager),
add some methods to model objects (will_paginate), add a new templating
language (Haml), interface to a new database (mysql), and even replace the
entire client-side scripting framework (jquery-rails).
If you think about it, there really isn’t all that much that a plugin can’t do.

8.
9.
10.
11.
12.
13.
14.
15.

http://datamapper.org/
http://cukes.info/
http://rspec.info/
https://github.com/brynary/webrat#readme
http://www.hoptoadapp.com/pages/home
https://github.com/rails/exception_notification#readme
http://guides.rubyonrails.org/plugins.html
http://api.rubyonrails.org/classes/Rails/Railtie.html

report erratum • discuss

In this chapter, we’ll see
• reviewing Rails concepts: model, view, controller, configuration, testing, and deployment; and
• links to places for further exploration.

CHAPTER 27

Where to Go from Here
Congratulations! We’ve covered a lot of ground together.
In Part I, you installed Rails, verified the installation using a simple application, got exposed to the architecture of Rails, and got acquainted (or maybe
reacquainted) with the Ruby language.
In Part II, you iteratively built an application, built up test cases along the
way, and ultimately deployed it using Capistrano. We designed this application
to touch on all of the aspects of Rails that every developer needs to be aware
of.
Whereas Parts I and II of this book each served a single purpose, Part III of
this book served a dual role.
For some of you, Part III methodically filled in the gaps and covered enough
for you to get real work done. For others, this will be the first steps of a much
longer journey.
For most of you, the real value is a bit of both. A firm foundation is required
in order for you to be able to explore further. And that’s why we started this
part with a chapter that not only covered the convention and configuration
of Rails but also covered the generation of documentation.
Then we proceeded to devote a chapter each to the model, views, and controller, which are the backbone of the Rails architecture. We covered topics
ranging from database relationships to the REST architecture to HTML forms
and helpers.
We covered migration and caching as essential maintenance and tuning
aspects of a deployed application.
Finally, we split Rails apart and explored the concept of gems from a number
of different perspectives: from making use of individual Rails components

report erratum • discuss

446

•

Chapter 27. Where to Go from Here

separately to making full use of the foundation upon which Rails is built and
finally to building and extending the framework to suit your needs.
At this point, you have the necessary context and background to explore
deeper whatever areas suit your fancy or are needed to solve that vexing
problem you face. We recommend you start by visiting the Ruby on Rails site1
and exploring each of the links across the top of that page. Some of this will
be quick refreshers of materials presented in this book, but you will also find
plenty of links to current information on how report problems, learn more,
and keep up-to-date.
Additionally, please continue to contribute to the wiki and forums mentioned
in the book’s introduction.
Pragmatic Bookshelf has more books on related Ruby and Rails subjects.2
There also are plenty of related categories that go beyond Ruby and Rails,
such as Agile Practices; Testing, Design, and Cloud Computing; and Tools,
Frameworks, Languages. You can find these and other categories at http://
www.pragprog.com/categories.
We hope you have enjoyed learning about Ruby on Rails as much as we have
enjoyed writing this book!

1.
2.

http://rubyonrails.org/
http://www.pragprog.com/categories/ruby_and_rails

report erratum • discuss

APPENDIX 1

Bibliography
[Bur11]

Trevor Burnham. CoffeeScript: Accelerated JavaScript Development. The
Pragmatic Bookshelf, Raleigh, NC and Dallas, TX, 2011.

[TFH08]

David Thomas, Chad Fowler, and Andrew Hunt. Programming Ruby: The
Pragmatic Programmer’s Guide. The Pragmatic Bookshelf, Raleigh, NC and
Dallas, TX, Third, 2008.

report erratum • discuss

Index
SYMBOLS
! suffix, 50
#, 39
#{…}, 40
%r{…}, 42
%{…}, 69
& prefix, 45
/…/, 42
: prefix, 39
<%=…%>, 21
<%=…>, 421
<<, 41
=>, 41
=~, 42
? suffix, 50
[’a’,’b’,’c’], 41
[…], 40, 42
{…}, 41
|, 42
||, 51
||=, 51

A
accepts attribute, 320

ACID properties, 305
action caching, 374, 381
Action Controller, 307, 319–
330
action_name attribute, 319
after_filter, 338
asset_host (config), 358
before_filter, 201, 338
cache_store (config), 378
cache_sweeper method, 380
caches_action method, 375
caches_page method, 375

expire_action, 377
expire_fragment, 384–385
expire_page, 377
flash attribute, 342
fragment_exist?, 383
headers attribute, 319,

327, 330, 342
layout method, 360
logger attribute, 321, 342
method_missing, 319, 324
model method, 331
page_cache_directory (config),

381
page_cache_extension (config),

381
params attribute, 111,

284, 319, 342, 346
perform_caching (config), 376
redirect_to, 122, 322, 328–

329
render, 131, 322, 341,

361, 363
render_to_string, 325
request attributes, 320–

321, 342
respond_to, 313, 316
response attribute, 321,

342
send_data, 259, 326
send_file, 326
session attribute, 321,

331, 342
template_root (config), 322

Action Dispatch, 307–317
Action Mailer, 175–181
delivery_method (config), 175
receive, 182
smtp_settings (config), 176
action methods, 319
Action Pack, 34, 307

:action parameter, 324

Action View, 341–366
base_path attributes, 342
button_to, 123, 356
cache, 382, 384
controller attributes, 342
link_to, 355
link_to_if, 356
link_to_unless, 356
link_to_unless_current, 356
using Action View
helpers, 411
action_name attribute, 319
Active Merchant, 437–439
Active Record, 269–305
after_create method, 295
after_destroy method, 205,
295
after_find method, 295–
296, 299
after_initialize method, 295–
296
after_save method, 295
after_update method, 295
after_validation method, 295
attribute_names, 289
attribute_present?, 289
attributes, 289
average, 287
before_create method, 295
before_destroy method, 295
before_save method, 295
before_update method, 295
before_validation method,
295
belongs_to method, 107,
276–277
count, 287
create, 279, 292
create!, 292

450

•

Index

creating new rows, 278–
280
custom SQL queries, 289
data validation, 77–82,
159
delete, 293
delete_all, 293
deleting rows, 293
destroy, 294, 305
destroy_all, 294
dynamic finders, 281–290
find, 280
find_all_by_, 281
find_by_, 281
find_by_sql, 289–291
find_last_by_, 281
find_or_create_by_, 282
find_or_initialize_by_, 282
group method, 286
has_and_belongs_to_many

method, 277
has_many method, 107,

277
has_one method, 276

hook methods, 205
instance, 301
joins method, 286
lock method, 286
maximum, 287
minimum, 287
object-relational mapping, 33–34
observe, 300
observers (config), 301
offset method, 285
order method, 285
plugin to replace, 443
primary keys, 269, 275
primary_key= method, 275
read_attribute, 273
readonly method, 286
RecordNotFound exception,
120
reload, 290
save, 278, 291–293, 305
save!, 292–293, 303
scopes, 288
select method, 286
set_primary_key method, 275
and SQL, 282–294
in stand-alone applications, 405–406
sum, 287
tables, 269–278
transaction, 302
update, 292
update_all, 292
update_attribute, 292

updating rows, 291–292
write_attribute, 273
Active Resource, 411–417
Active Support libraries, 406–
410
adapters, database, 13
add_column method, 390
add_index method, 398
add_table method, 395
after filters, 338
after_create method, 295
after_destroy method, 205, 295
after_filter method, 338
:except parameter, 338
:only parameter, 338
after_find method, 295–296,
299
after_initialize method, 295–296
after_save method, 295
after_update method, 295
after_validation method, 295
Agile Manifesto, xix
Ajax
coining of, 129
request to application,
137
response from application, 137–138
testing, 148–151
troubleshooting, 139
animate method, 142
Apache web server, 231–233
app/ directory, 256
application.html.erb, 71, 96
applications
analysis and design, 56–
60
basic workflow, 24
creating, 15, 61
deployment, 229–245
directory structure, 257–
258
documentation, 250
exception handling, 119–
122
integration testing, 182–
187
internationalization of,
209–227
monitoring, 243
nonbrowser, 405–417
page caching, 374–381
performance tweaking,
245

reloading code, 23
RESTful, 308
URL of, 19, 24, 92
around filters, 338–339
assert method, 83
assert_generates method, 317
assert_recognizes method, 318
assert_routing method, 318
assert_select method, 102
assertions, 83–84
asset_host (config), 358
assigns method, 112
Atom feeds, 167–170, 358
attachment_fu plugin, 351
attribute_names method, 289
attribute_present? method, 289
attributes, 270–274
accepts (request object),
320
action_name (Action Controller), 319
base_path (Action View),
342
body (request object), 321
content_length (request object), 321
content_type (request object), 321
controller (Action View), 342
domain (request object),
320
env (request object), 320
flash (Action Controller),
342
format (request object),
320
headers (Action Controller),
319, 327, 330, 342
headers (request object),
321
host (request object), 320
host_with_port (request object), 320
logger (Action Controller),
321, 342
method (request object),
320
params (Action Controller),
111, 284, 319, 342,
346
path (request object), 320
port (request object), 320
port_string (request object),
320
protocol (request object),
320

Index
query_string (request ob-

ject), 320
remote_ip (request object),
320
request (Action Controller),
320–321, 342
request_method (request object), 320
response (Action Controller), 342
session (Action Controller),
321, 331, 342
ssl? (request object), 320
url (request object), 320
attributes method, 289
authlogic plugin, 442
auto_discovery_link_tag method,
358
average method, 287

B
:back parameter, 329

bang methods, 50
base_path attributes, 342
:bcc parameter, 357
before filters, 201, 338
before_create method, 295
before_destroy method, 295
before_filter method, 201, 338
:only parameter, 338
before_save method, 295
before_update method, 295
before_validation method, 295
belongs_to method, 107, 276–
277
benchmarker, 262
blind effect, 143
BlueCloth, 355
body attribute, 321
:body parameter, 357
browsers
caching in, 370–371
disabling JavaScript, 139
DOM inspectors, 151
Firefox NoScript plugin,
151
Internet Explorer quirks
mode, 139
reloading pages, 139
:buffer_size parameter, 326
Builder templates, 342, 419
Bundler
for dependency management, 423–426

•

451

installing Capistrano,
239
installing plugins, 170–
171
pack command, 239
update command, 425
button_to method, 123, 356

observers (Active Record),

C

smtp_settings (Action Mail-

cache method, 382, 384
cache_store (config), 378
cache_sweeper method, 380
caches_action method, 375
caches_page method, 375

caching
action caching, 374, 381
client caches, 370–371
expiring fragments, 384
expiring pages, 377, 379–
380
fragment caching, 381–
385
page caching, 374–381
server caches, 371
storage options, 378
sweepers, 379–380
callbacks, 294–300
sequence, 296
Capistrano, 237–243
:cc parameter, 357
change method, 391
change_column method, 394
class methods, 46
classes, 37, 46–47
in Active Record, 270
automatic loading, 266
naming conventions, 264
CoffeeScript, 147–148, 150,
343
:collection parameter, 131, 314,
364
command line
learning, 9
multiple-line commands,
62
tab completion, 9
config.ru, 256, 426
config/ directory, 263
configuration parameters
asset_host (Action Controller), 358
cache_store (Action Controller), 378
delivery_method (Action
Mailer), 175

301
page_cache_directory (Action

Controller), 381
page_cache_extension (Action

Controller), 381
perform_caching (Action

Controller), 376
er), 176
template_root (Action Con-

troller), 322
:confirm parameter, 355

console window, 17
console, Rails, 204, 244,
262, 412
constructors, 38
content_length attributes, 321
content_tag helper, 145
content_type attribute, 321
:content_type parameter, 325
continuous integration system, 9
controller attributes, 342
controllers
accessing request information, 319–321
and Action Controller,
319–330
action methods, 319
default behavior, 19
defined, 30
in Depot application, 248
error logging, 122
filters, 200–202, 337–339
flash data, 336
fragment caching, 381–
385
functional testing, 183
generating, 18
grouping into modules,
266
helper methods, 352–358
layout declaration, 360
model declaration, 49
naming conventions,
265–266
and partial templates,
366
in Rails, 35
redirects, 122, 125, 327–
330
responding to user, 321–
330
returning files, 326
standard location, 21

452

•

Index

convention over configuration, xviii, 249
cookies, 319, 332
count method, 287
create method, 279, 292
create! method, 292
create_table method, 395
credit card processing, 437–
439
cross-site request forgery attacks, 97
CRUD methods, 269, 278
css method, 142
CSS stylesheets
Sassy CSS, 71, 99, 134
selector notation, 102
standard location, 69
tables, 125
currency
converting numbers to,
99, 353
localizing, 218
current_page method, 356
cycle method, 72, 355

D
data types
database columns, 391–
393
databases and migrations, 392
in Ruby, 39–43
SQL to Ruby mappings,
274
data validation
in models, 77–82, 159
unit testing, 83–89
databases, see also Active
Record
adapters for Rails, 13
column types, 391–393
configuration troubleshooting, 235
creating, 62–64
development vs. production, 234
foreign keys, 107, 163,
276, 399–402
importing seed data, 69
join tables, 277
managing tables, 394–
399
model-table mappings,
62, 270–274
object-relational mapping, 32–34

preconfigured by Rails,
88
primary keys, 269, 275
remote manipulation,
411–417
rollback, 206, 402
row locking, 286
supported by Rails, 12–
14
table names, 265, 267,
269
transactions, 301–305
datamapper plugin, 443
DB2, 13
debug method, 342, 354
declarations
after_create (Active Record),
295
after_destroy (Active
Record), 295
after_find (Active Record),
295–296
after_initialize (Active
Record), 295–296
after_save (Active Record),
295
after_update (Active Record),
295
after_validation (Active
Record), 295
before_create (Active
Record), 295
before_destroy (Active
Record), 295
before_save (Active Record),
295
before_update (Active
Record), 295
before_validation (Active
Record), 295
belongs_to (Active Record),
276–277
cache_sweeper (Action Controller), 380
caches_action (Action Controller), 375
caches_page (Action Controller), 375
has_and_belongs_to_many (Active Record), 277
has_many (Active Record),
277
has_one (Active Record),
276
layout (Action Controller),
360
model (Action Controller),
331

primary_key= (Active

Record), 275
set_primary_key (Active

Record), 275
default_url_options, 211–212
delete method, 293
delete? method, 320
delete_all method, 293
delivery_method (config), 175
:dependent parameter, 107

deployment, 229–245
deployment servers, 237–
240
Depot application
access control, 200–203
analysis, 56–60
caching, 370–374
cart design, 59
cart, basic, 105–113,
115–119, 123–127
cart, in sidebar, 130–136
cart, with Ajax, 136–146
catalog display, 91–103
checkout, 153–165
credit card processing,
437–439
data analysis, 57, 60
data validation, 77–82
data, seed, 69
deployment, 229–245
development approach,
55, 60
directory structure, 258
emails, 175–182
error handling, 119–122
functional testing, 100–
103, 124, 148–151,
163–164, 181, 199
integration testing, 182–
187
internationalization of,
209–227
MVC architecture, 247–
249
order creation, 153–165
order reporting, 165
page flows, 57
page layout, 96–99
pagination, 170–173
prices, 59, 99, 126
product listing, 69–73
products database, 62–64
products maintenance
application, 61–73
quantities, 115–119
remote client access,
411–417

Index
unit (model) testing, 82–
89
use cases, 56
users, administering,
190–194, 203–206
users, authenticating,
194–203
users, logging in, 189–
190
destroy method, 294, 305
destroy_all method, 294
development
development database,
88
environment, 9–13
incremental, 55, 61
recover actions, 59
reloading application
code, 23
runtime environment
setting, 264
use cases, 56
devise plugin, 442
directory listing, 16
:disposition parameter, 326
distance_of_time_in_words method,
353
doc/ directory, 259
DOCTYPE header, 139
documentation
application, 250
for Rails, xxiii, 13, 259
DOM inspectors, 151
DOM manipulation, 137
domain attribute, 320
down method, 118, 390
drop_table method, 395
DRY (Don’t Repeat Yourself),
xviii

E
E-TextEditor, 11
editors, 10–12
Emacs, 10
email
creating mailers, 177
delivery method, 175–176
multiple content types,
180
receiving, 182
sending, 177–180
SMTP settings, 176
templates, 178
:encode parameter, 357

encryption, using callback
handler, 297–300
entity names, 210, 216, 222
env attribute, 320
environments, runtime
and caching, 376
custom, 264
development, 23
and email delivery, 175–
176
and Gemfile, 234, 424
purpose of, 263
switching, 250, 264
ERb (Embedded Ruby) templates, 21, 24, 35, 343,
421–423
.erb extension, 21
error messages
comparing to built-in, 89
errors object, 108
logging, in controller, 122
testing, 84
translating, 221–225
using flash, 120, 337
:except parameter, 338
exception handling
in Active Record searches, 281
automatic rollback, 206
in Rails applications,
119–122
rescue statement, 45, 121
in Ruby, 45
excerpt method, 354
execute method, 399
expire_action method, 377
expire_fragment method, 384–
385
expire_page method, 377
expires_in method, 370
expires_now method, 370

F
feeds, 167–170
file_field method, 349
:filename parameter, 326
files
returning, 326
uploading, 348–351
filter method, 338
filters, 200–202, 337–339
skipping, in child controllers, 201, 339

•

453

find method, 280
:group parameter, 286
:order parameter, 285
:select parameter, 286
find_all_by_ method, 281
find_by_ method, 281
find_by_sql method, 289–291
find_last_by_ method, 281
find_or_create_by_ method, 282
find_or_initialize_by_ method, 282

finder methods, dynamic,
281–290
Firebird, 13
fixtures, 85–89
fixtures method, 87
flash attributes, 342
flash data, 336
sending error messages,
120
translating messages,
224
form_for method, 156
form_tag method, 196
:multipart parameter, 349
format attribute, 320
:format parameter, 316
format.atom, 167
forms
data flows, 197
data validation, 159
file_field, 349
form helpers, 156, 343–
346
form_for, 156–157
form_tag, 196, 226
label_tag, 196
login page, 196
password_field_tag, 196
processing submitted data, 346–347
select_tag, 226
submit_tag, 226
text_area, 158
text_field, 156
text_field_tag, 196
translating, 219–221
fragment caching, 381–385
fragment_exist? method, 383
fresh_when method, 372–373

G
gem server, xxiii
Gemfile, 9, 170, 234, 256, 423–

426

454

•

Index

Gemfile.lock, 256

gems, 171, 423–426, 431,
437
generator scripts
controller, 18, 91
integration_test, 183
mailer, 177
migration, 388
model, 388
scaffold, 62, 108
get method, 184
get? method, 320
Git
for deployment, 237–240
for development, 74
.gitignore file, 75
Gmail SMTP settings, 176
:greater_than_or_equal_to parameter, 78
:group parameter, 286

H
Haml, 439–441
handler classes, 296–300
has_and_belongs_to_many method,
277
has_many method, 107, 161,
277
has_one method, 276
has_secure_password method, 190
head? method, 320
headers attribute, 319, 321,
327, 330, 342
helper methods, 26
default, 352
for emailing, 357
for formatting, 353–355
for forms, 343–346
for JavaScript, 358
for linking, 355–357
location of, 144, 258, 352
as modules, 48
writing, 144–145, 352
helpers
auto_discovery_link_tag, 358
current_page, 356
cycle, 72, 355
debug, 342, 354
distance_of_time_in_words, 353
excerpt, 354
highlight, 354
image_tag, 94, 356
j, 138
javascript_include_tag, 358
javascript_link_tag, 357

link_to, 26
mail_to, 357
number_to_currency, 99, 353
number_to_human_size, 353
number_to_percentage, 353
number_to_phone, 353
number_with_delimiter, 353
number_with_precision, 354
pluralize, 354
raw, 422
sanitize, 94, 422
simple_format, 354
strip_tags, 72
stylesheet_link_tag, 97, 357
time_ago_in_words, 353
truncate, 72, 354
highlight method, 354

hook methods, 108, 205
host attribute, 320
host name mapping, 233
host_with_port attribute, 320
HTML Abstraction Markup
Language (Haml), 439–441
HTML entity names, 210,
216, 222
html method, 138
.html.erb files, 21, 130
html_safe, 210
HTTP
Content-Type header, 325
Expires header, 370
file uploading, 348
method selection, 74,
109, 198–199
Not Modified response, 372
redirects, 125, 327–330
Status header, 325
hyperlinks, generate with
link_to, 26

I
I18n module, 210–213

IDEs, 10–11
image_tag method, 94, 356
inflections.rb, 270
:inline parameter, 323
installation, 4–9
instance method, 301
instance methods, 46–47
instance variables, 38, 46
integration testing, 182–187
internationalization, 209–227

J
j method, 138

jEdit, 11
jQuery
alias to $, 138
html, 138
loading, 358
schedule script execution, 147
jQuery-UI library, 140
animate, 142
blind effect, 143
show, 143
JavaScript
and Ajax, 129
helper methods, 358
JSON, 136, 325, 409,
413
RJS templates, 325
javascript_include_tag method,
358
javascript_link_tag method, 357
joins method, 286
.js.erb files, 138
JSON (JavaScript Object Notation), 136, 325, 409, 413

K
keys
foreign, 107, 163, 276,
399–402
primary, 269, 275, 398
Komodo IDE, 12

L
label_tag method, 196

language translation, 209–
227
layout method, 360
:layout parameter, 325, 361
layouts, 96–99, 359–363, 365
lib/ directory, 259
limit method, 285
link_to method, 26, 355
:confirm parameter, 355
:method parameter, 74,
314, 355
link_to_if method, 356
link_to_unless method, 356
link_to_unless_current method,
356
Linux
commands, multiple-line,
62

Index
installing Rails, 6–8
log file viewing, 122
locale files, 214–219
locales
defining, 209
switching, 225, 227
localization, 209–227
lock method, 286
log files
rolling over, 244
standard location, 261
viewing, 122, 244
log/ directory, 261
logger, 321, 342
logging in (users), 189–203

M
Mac OS X
commands, multiple-line,
62
enabling Apache, 231
installing MySQL, 234
installing Rails, 5–6
log file viewing, 122
mail_to method, 357
:bcc parameter, 357
:cc parameter, 357
:encode parameter, 357
mailers, 177–179
maximum method, 287
method attribute, 320
:method parameter, 74, 314,
355
method_missing method, 319,
324
methods (HTTP), 74, 109,
198–199
methods (Ruby), 38–39, 46–
47
private, 47, 106
migrations
add_column, 390
add_index, 398
adding columns, 115,
153
applying, 64, 389
change method, 391, 394
change_column, 394
column types, 391–393
create_table, 395
creating, 388
creating tables, 394–396
custom messages, 402
defined, 63
defining indices, 398

down, 390–391
execute, 399

irreversible, 394
naming convention, 387
and primary keys, 398
remove_column, 390
remove_index, 398
rename_column, 393
rename_table, 396
rolling back, 118, 389,
403
serious problem with,
402
up, 390
up vs. change, 391
using SQL, 399–402
MIME types, 316
minimum method, 287
model method, 331
models
data validation, 77–82
defined, 29
in Depot application, 247
foreign keys, 107, 163,
276
mapping to forms, 156–
157
mapping to tables, 62
marshaling, 49
model object comparison,
276
naming conventions,
265–266
observers, 300
in Rails, 32–34
relationships between,
107, 276–278
scaffolds for, 62–63
standard location, 258
testing, 82–89
translating names, 223
modules, 48
grouping controllers into,
266
mixing in, 48
:multipart parameter, 349
MVC (Model-View-Controller),
29–30
in Depot application,
247–249
MySQL
adapter for, 13
and InnoDB storage engine, 396
installing, 234
loading migrations, 235

•

455

N
naming conventions, 264–266
modifying the inflection
file, 270
NetBeans IDE, 11
:nothing parameter, 325
number_to_currency method, 99,
353
number_to_human_size method,
353
number_to_percentage method,
353
number_to_phone method, 353
number_with_delimiter method,
353
number_with_precision method,
354
numbers
formatting and converting, 99, 353
localizing, 218
precision, 354, 393
random, 410
validating, 78

O
objects, 37
marshaling, 49
observe method, 300
observers (config), 301
:only parameter, 338
Oracle, 13
:order parameter, 285
ORM (Object-Relational Mapping), 32, 269

P
page caching, 374–381
page flows, 57
page layouts, 96–99, 359–363
page_cache_directory (config), 381
page_cache_extension (config), 381
pagination, 170–173
Paperclip plugin, 351
parameters
:action (render), 324
:back (redirect_to), 329
:bcc (mail_to), 357
:body (subject), 357
:buffer_size (send_file), 326
:cc (mail_to), 357
:collection (render), 131,
364
:collection (resources), 314

456

•

Index

:confirm (link_to), 355
:content_type (render), 325
:disposition (send_data), 326
:disposition (send_file), 326
:encode (mail_to), 357
:except (after_filter), 338
:filename (send_data), 326
:filename (send_file), 326
:format (resource), 316
:group (find), 286
:inline (render), 323
:layout (render), 325, 361
:method (link_to), 74, 314,

355
:multipart (form_tag), 349
:nothing (render), 325
:only (after_filter), 338
:only (before_filter), 338
:order (find), 285
:partial (render), 131, 325,

364–365
:select (find), 286
:spacer_template (render),

365
:status (render), 325
:status (send_data), 326
:streaming (send_file), 326
:template (render), 324
:text (render), 323
:type (send_data), 326
:type (send_file), 326
:update (render), 325
:url_based_filename

(send_data), 326
:xml (render), 325
params attribute, 342, 346
params object, 111, 197, 284,

319, 346, 415
:partial parameter, 131, 325,
364–365
partial-page templates, 130–
135, 363–366
with layouts, 366
shared, 365
Passenger, 231
password_field_tag method, 196
passwords
confirmation, 190, 192
obscuring, 346
_path, 26, 109, 125
path attribute, 320
perform_caching (config), 376
performance
benchmarking, 262
caching, 369–385
request profiling, 262

Phusion Passenger, 231
placeholders, 345
plugins, 437–443
finding more, 441
Haml, 439–441
installing, 170–171
standard location, 263
pluralize method, 354
port attribute, 320
port_string attribute, 320
post? method, 320
post_via_redirect method, 185
Postgres, 13
predicate methods, 50
prepend_after_filter method, 338
prepend_before_filter method, 338
:presence parameter, 78
primary_key= method, 275
private methods, 47, 106
production, see deployment
:prompt parameter, 158
protected methods, 47
protocol attribute, 320
Prototype, 442
public attribute, 373
public/ directory, 261
put? method, 320

Q
query_string attribute, 320

R
Rack, 256, 426–429
rackup command, 426, 428
RadRails IDE, 11
Rails
agile practices in, xix
application directory
structure, 16, 257
basic workflow, 24
dependency list, 431–434
documentation, xix, xxiii,
13, 250, 259
editors for, 10–12
IDEs for, 10–11
installing, 4–9
MVC architecture, xvii,
17, 23, 30–35
naming conventions,
264–266
nonbrowser applications,
405–417
origin of, xix

plugins, 170–171, 262,
437–443
README, 256
REST support, 310–314
Ruby version compatibility, 4
test infrastructure, xvii,
68–69
trends in use of, xvii
using Rails methods,
406–410
versions, 8
rails scripts
benchmarker, 262
console, 204, 244, 262,
412
dbconsole, 262
destroy, 262
generate, 262
new, 15
plugin, 262
profiler, 262
runner, 172, 262
server, 17, 262, 264
RAILS_ENV environment variable, 235, 324, 406
rails_xss plugin, 442
RailsInstaller, 4
Rake
documentation for, 261
listing available tasks,
430
Rakefile, 256
writing tasks for, 260,
430
rake commands
db:migrate, 64, 389
db:schema_migrations, 261
db:seed, 69
doc:app, 250
doc:guides, 259
doc:rails, 259
middleware, 428
routes, 310
stats, 250
test, 68
test:functionals, 103
test:units, 83
Rakefile, 429
random numbers, 410
raw method, 422
RDoc, 250
read_attribute method, 273
README_FOR_APP, 250
readonly method, 286
receive method, 182

Index
RecordNotFound exception, 280
RedCloth, 259, 355
redirect_to method, 122, 322,

328–329
:back parameter, 329
redirects (HTTP), 122, 125,
327–330
reload method, 290
:remote parameter, 137
remote_ip attribute, 320
remove_column method, 390
remove_index method, 398
rename_column method, 393
rename_table method, 396
render method, 131, 322, 341,
361, 363
:action parameter, 324
:collection parameter, 131,
364
:content_type parameter,
325
:inline parameter, 323
:layout parameter, 325,
361
:nothing parameter, 325
:partial parameter, 131,
325, 364–365
:spacer_template parameter,
365
:status parameter, 325
:template parameter, 324
:text parameter, 323
:update parameter, 325
:xml parameter, 325
render_to_string method, 325
request attributes
accepts, 320
body, 321
content_length, 321
content_type, 321
delete?, 320
domain, 320
env, 320
format, 320
get?, 320
head?, 320
headers, 321
host, 320
host_with_port, 320
method, 320
path, 320
port, 320
port_string, 320
post?, 320
protocol, 320
put?, 320

query_string, 320
remote_ip, 320
request_method, 320
ssl?, 320
url, 320
xhr?, 320
xml_http_request?, 320

requests
handling, 30–32
processing by controllers,
319–330
response object, 321
routing to applications,
307–317
session object, 321
require, 260
rescue statement, 45, 121
resource method
:collection parameter, 314
:format parameter, 316
resources
controller actions, 311–
314
defined, 309
nested, 315
routes generated, 310
respond_to method, 313, 316
response attribute, 342
response object, 321
REST (Representational State
Transfer), 308
Rails support for, 310–
314
verbs, 309
RJS templates, 325
routes
and locale, 211
editing config/routes.rb, 92,
198, 210
feeds, 168
HTTP method selection,
74, 109, 198–199
MIME types in, 316
nesting, 315
_path, 26, 125
redirect, 122, 125
resource-based, 310–318
selecting data representation, 316
set root URL, 92
testing, 317–318
_url, 125
URL parsing, 24, 31
RSS feeds, 166, 358
Ruby
accessors, 47

•

457

array literals, 40
arrays, 40–42
assignment shortcuts, 51
bang methods, 50
class methods, 46
classes, 46–47
code blocks, 44
collections, 40–42
comments, 39
compound statements,
39
conditional evaluation, 51
control structures, 43–45
data types, 39–43
declarations, 46
do, 44
end, 43
exceptions, 45
expression interpolation,
40
hash literals, 41
hashes, 40–42
idioms and gotchas, 50–
52
if, 44
indentation, 39
installing, 5–7
instance methods, 46–47
instance variables, 46
iterators, 45
lambda, 51
marshaling objects, 49
methods, 39, 46–47
modules, 48
names, 38, 264
nil, 41
object orientation, 37–38
predicate methods, 50
private methods, 47
protected methods, 47
Rails core extensions to,
407–408
RDoc utility, 250
regular expressions, 42
require, 51, 260
rescue statement, 45, 121
scope declaration, 211
self.new, 51
sprintf, 99
statement modifiers, 44
string literals, 39, 69
strings, 39
symbols, 38
unless, 44
until, 44
while, 43
yield statement, 44, 97,
359
RubyGems, xxiii, 3

458

•

Index

RUBYLIB environment variable,

sendmail, 176

406
RubyMine IDE, 12
RVM (Ruby Version Manager),
5–8, 242

session attributes, 342

S
sanitize method, 94, 422
save method, 278, 291–293,

305
save! method, 292–293, 303

scaffolds, 62–63, 108
schemas
manipulating in applications, 403
vs. models, 272
primary keys, 275
updating, 63, 115, 390,
402
scopes
Active Record, 288
Ruby, 211
script/ directory, 261
scriptlets, 422
SCSS (Sassy CSS), 71, 99,
134, 343
security
application access control, 200–203
cross-site request attacks, 97
exception handling, 119–
122
form data validation, 159
Secure Sockets Layer
(SSL), 416
SQL injection attack, 283
user authentication, 189–
203
seeds.rb, 69
:select parameter, 286
select_tag helper, 226
send_data method, 259, 326
:disposition parameter, 326
:filename parameter, 326
:status parameter, 326
:type parameter, 326
:url_based_filename parameter, 326
send_file method, 326
:buffer_size parameter, 326
:disposition parameter, 326
:filename parameter, 326
:streaming parameter, 326
:type parameter, 326

session object, 321, 331

sessions, 330–336
in Active Resource applications, 416
and cookies, 332
expiry and cleanup, 335
flash data storage, 120
login support, 195–199
and model declaration, 49
session object, 321, 331
shopping cart implementation, 105–106
storage options, 331,
334–335
set_primary_key method, 275
show method, 143
simple_format method, 354
skip_before_filter, 201
SMTP, 176
smtp_settings (config), 176
:spacer_template parameter, 365
SQL (Structured Query Language), 282–294, 399–402
data types, mapping to
ruby, 274
SQL Server, 13
SQLite 3
adapter, 14
advantages, 62
limitations, 234
ssl? method, 320
stale? method, 372
:status parameter, 325–326
:streaming parameter, 326
strip_tags method, 72
Struts, xvii
stylesheet_link_tag method, 97,
357
subject method, 357
submit_tag helper, 226
Subversion, 237
sum method, 287
sweepers, 379–380

T
tables
column statistics, 287
columns and migrations,
115, 153, 391–394
columns and models,
270–274
creating, 62–64

creating rows, 278–280
defining indices, 398
deleting rows, 293
derived columns, 290
join tables, 277
managing with migrations, 394–399
names of, 265, 267, 269
object-relational mapping, 32–34
without primary key, 399
primary keys, 275
queries by primary key,
280
reading, 280–290
relationships between,
276–278
renaming, 396
updating rows, 291–292
Tapestry, xvii
tasks/ directory, 260
:template parameter, 324
template_root (config), 322
templates
accessing controller object, 342
Builder, 342, 419
cache method, 382
CoffeeScript, 147–148,
343
and collections, 364
drawbacks of code in,
351
email, 178
environment of, 342
ERb, 21, 24, 35, 343,
421–423
file uploading, 348–351
form helpers, 343–346
fragment caching, 381–
385
Haml, 439–441
HTML, 20, 66–67
layouts, 96–99, 359–363
location of, 341
partial, 130–135, 363–
366
rendering, 322–326, 364–
366
RJS, 325
SCSS, 71, 99, 134, 343
translating, 213–218
XML, 419
test/ directory, 259
Test::Unit framework, 82
testing
assert, 83

Index
assert_generates, 317
assert_recognizes, 318
assert_routing, 318

assertions, 83–84
automatic test generation, 68
benchmarking, 262
in Depot application, 249
fixtures, 85–89
functional tests, 81, 100–
103, 124, 148–151,
199
get, 184
integration tests, 182–
187
model unit tests, 82–89
post_via_redirect, 185
request profiling, 262
routes, 317–318
runtime environment
setting, 176
test database, 88
xml_http_request, 184
:text parameter, 323
text_area method, 158
text_field method, 156
text_field_tag method, 196
TextMate, 10–11
time
calculations and conversions, 353, 410
displaying, 22–23
time_ago_in_words method, 353
tmp/ directory, 262
transaction method, 302
transactions, 301–305
Transport Layer Security
(TLS), 416
truncate method, 72, 354
:type parameter, 326

U
:uniqueness parameter, 78

unit testing, 82–89
up method, 390
update method, 292
:update parameter, 325

update_all method, 292
_url, 311
url attribute, 320

326
URLs
of applications, 19, 24
default_url_options, 211–212
redirect, 122, 125
setting web site root, 92
_url vs. _path, 125
validating, 78
use cases, 56
user authentication, 189–203

V
validates method, 78
vendor/ directory, 263

version control system, 9
Git, 74
views
adding buttons, 108–
110, 123
defined, 29
in Depot application, 248
dynamic page updates,
137–138
HTML forms, 155–160,
196, 343–347
location of, 341
naming conventions, 266
pathnames to, 94
in Rails, 34–35
rendering templates,
322–326
for RESTful actions, 314
standard location, 21
static HTML templates,
20, 66–67
writing helper methods,
144–145
Vim, 10
visual effects
blind effect, 143

459

hide/reveal items, 143–
145
highlight changes, 140–
142

update_attribute method, 292

:url_based_filename parameter,

•

W
Web 2.0, xvii
web server
development vs. production, 231
Rails interface to, 426–
429
restarting, 59
starting, 17, 65, 262
stopping, 17
WEBrick, 17
-e environment option,
264
will_paginate plugin, 170
Windows
commands, multiple-line,
62
Cygwin and MySQL, 236
installing Rails, 4–5
log file viewing, 122
tail command, 122
write_attribute method, 273

X
xhr? method, 320

XML
data format, 414–415
request response types,
316, 415
templates, 419
:xml parameter, 325
xml_http_request method, 184
xml_http_request? method, 320

Y
YAML
defined, 48
for test data, 85–87
for locale files, 215
request response types,
316
tab sensitivity, 237
yield statement, 44, 97, 359

Coding Ain’t Done ’Til All the Tests Run
Start with Test Driven Development, Domain Driven Design, and Acceptance Test Driven
Planning in Ruby. Then add Shoulda, Cucumber, Factory Girl, and Rcov for the ultimate
in Ruby and Rails development.

Behaviour-Driven Development (BDD) gives you the
best of Test Driven Development, Domain Driven Design, and Acceptance Test Driven Planning techniques,
so you can create better software with self-documenting, executable tests that bring users and developers
together with a common language.
Get the most out of BDD in Ruby with The RSpec Book,
written by the lead developer of RSpec, David Chelimsky.
David Chelimsky, Dave Astels, Zach Dennis, Aslak
Hellesøy, Bryan Helmkamp, Dan North
(448 pages) ISBN: 9781934356371. $38.95
http://pragprog.com/titles/achbd

Rails Test Prescriptions is a comprehensive guide to
testing Rails applications, covering Test-Driven Development from both a theoretical perspective (why to
test) and from a practical perspective (how to test effectively). It covers the core Rails testing tools and procedures for Rails 2 and Rails 3, and introduces popular
add-ons, including RSpec, Shoulda, Cucumber, Factory
Girl, and Rcov.
Noel Rappin
(368 pages) ISBN: 9781934356647. $34.95
http://pragprog.com/titles/nrtest

Welcome to the New Web
The world isn’t quite ready for the new web standards, but you can be. Get started with
HTML5, CSS3, and a better JavaScript today.

CoffeeScript is JavaScript done right. It provides all of
JavaScript’s functionality wrapped in a cleaner, more
succinct syntax. In the first book on this exciting new
language, CoffeeScript guru Trevor Burnham shows
you how to hold onto all the power and flexibility of
JavaScript while writing clearer, cleaner, and safer
code.
Trevor Burnham
(160 pages) ISBN: 9781934356784. $29
http://pragprog.com/titles/tbcoffee

HTML5 and CSS3 are the future of web development,
but you don’t have to wait to start using them. Even
though the specification is still in development, many
modern browsers and mobile devices already support
HTML5 and CSS3. This book gets you up to speed on
the new HTML5 elements and CSS3 features you can
use right now, and backwards compatible solutions
ensure that you don’t leave users of older browsers
behind.
Brian P. Hogan
(280 pages) ISBN: 9781934356685. $33
http://pragprog.com/titles/bhh5

Be Agile
Don’t just “do” agile; you want be agile. We’ll show you how.

The best agile book isn’t a book: Agile in a Flash is a
unique deck of index cards that fit neatly in your
pocket. You can tape them to the wall. Spread them
out on your project table. Get stains on them over
lunch. These cards are meant to be used, not just read.
Jeff Langr and Tim Ottinger
(110 pages) ISBN: 9781934356715. $15
http://pragprog.com/titles/olag

Here are three simple truths about software development:
1. You can’t gather all the requirements up front. 2.
The requirements you do gather will change. 3. There
is always more to do than time and money will allow.
Those are the facts of life. But you can deal with those
facts (and more) by becoming a fierce software-delivery
professional, capable of dispatching the most dire of
software projects and the toughest delivery schedules
with ease and grace.
Jonathan Rasmusson
(280 pages) ISBN: 9781934356586. $34.95
http://pragprog.com/titles/jtrap

Advanced Ruby and Rails
What used to be the realm of experts is fast becoming the stuff of day-to-day development.
Jump to the head of the class in Ruby and Rails.

Rails 3 is a huge step forward. You can now easily extend the framework, change its behavior, and replace
whole components to bend it to your will, all without
messy hacks. This pioneering book is the first resource
that deep dives into the new Rails 3 APIs and shows
you how to use them to write better web applications
and make your day-to-day work with Rails more productive.
José Valim
(180 pages) ISBN: 9781934356739. $33
http://pragprog.com/titles/jvrails

As a Ruby programmer, you already know how much
fun it is. Now see how to unleash its power, digging
under the surface and exploring the language’s most
advanced features: a collection of techniques and tricks
known as metaprogramming. Once the domain of expert
Rubyists, metaprogramming is now accessible to programmers of all levels—from beginner to expert.
Metaprogramming Ruby explains metaprogramming
concepts in a down-to-earth style and arms you with
a practical toolbox that will help you write great Ruby
code.
Paolo Perrotta
(240 pages) ISBN: 9781934356470. $32.95
http://pragprog.com/titles/ppmetr

Ruby on the JVM and More Languages
Want to integrate Ruby within your Enterprise JVM environment? JRuby is the answer.
And when you’re ready to expand your horizons, we’ve got seven major languages worthy
of your study.

Now you can bring the best of Ruby into the world of
Java, with Using JRuby. Come to the source for the
JRuby core team’s insights and insider tips. You’ll
learn how to call Java objects seamlessly from Ruby,
and deal with Java idioms such as interfaces and
overloaded functions. Run Ruby code from Java, and
make a Java program scriptable in Ruby. See how to
compile Ruby into .class files that are callable from
Java, Scala, Clojure, or any other JVM language.
Charles O Nutter, Thomas Enebo, Nick Sieger, Ola Bini,
and Ian Dees
(300 pages) ISBN: 9781934356654. $34.95
http://pragprog.com/titles/jruby

You should learn a programming language every year,
as recommended by The Pragmatic Programmer. But
if one per year is good, how about Seven Languages in
Seven Weeks? In this book you’ll get a hands-on tour
of Clojure, Haskell, Io, Prolog, Scala, Erlang, and Ruby.
Whether or not your favorite language is on that list,
you’ll broaden your perspective of programming by
examining these languages side-by-side. You’ll learn
something new from each, and best of all, you’ll learn
how to learn a language quickly.
Bruce A. Tate
(300 pages) ISBN: 9781934356593. $34.95
http://pragprog.com/titles/btlang

Pragmatic Guide Series
If you want to know what lies ahead, ask those who are coming back. Our pragmatic authors
have been there, they’ve done it, and they’ve come back to help guide you along the road.
They’ll get you started quickly, with a minimum of fuss and hand-holding. The Pragmatic
Guide Series features convenient, task-oriented two-page spreads. You’ll find what you need
fast, and get on with your work

Need to learn how to wrap your head around Git, but
don’t need a lot of hand holding? Grab this book if
you’re new to Git, not to the world of programming.
Git tasks displayed on two-page spreads provide all
the context you need, without the extra fluff.
NEW: Part of the new Pragmatic Guide series
Travis Swicegood
(168 pages) ISBN: 9781934356722. $25
http://pragprog.com/titles/pg_git

JavaScript is everywhere. It’s a key component of today’s Web—a powerful, dynamic language with a rich
ecosystem of professional-grade development tools,
infrastructures, frameworks, and toolkits. This book
will get you up to speed quickly and painlessly with
the 35 key JavaScript tasks you need to know.
NEW: Part of the new Pragmatic Guide series
Christophe Porteneuve
(150 pages) ISBN: 9781934356678. $25
http://pragprog.com/titles/pg_js

The Pragmatic Bookshelf
The Pragmatic Bookshelf features books written by developers for developers. The titles
continue the well-known Pragmatic Programmer style and continue to garner awards and
rave reviews. As development gets more and more difficult, the Pragmatic Programmers will
be there with more titles and products to help you stay on top of your game.

Visit Us Online
This Book’s Home Page
http://pragprog.com/titles/rails4

Source code from this book, errata, and other resources. Come give us feedback, too!

Register for Updates
http://pragprog.com/updates

Be notified when updates and new books become available.

Join the Community
http://pragprog.com/community

Read our weblogs, join our online discussions, participate in our mailing list, interact with
our wiki, and benefit from the experience of other Pragmatic Programmers.

New and Noteworthy
http://pragprog.com/news

Check out the latest pragmatic developments, new titles and other offerings.

Buy the Book
If you liked this eBook, perhaps you'd like to have a paper copy of the book. It's available
for purchase at our store: http://pragprog.com/titles/rails4

Contact Us
Online Orders:

http://pragprog.com/catalog

Customer Service:

support@pragprog.com

International Rights: translations@pragprog.com
Academic Use:

academic@pragprog.com

Write for Us:

http://pragprog.com/write-for-us

Or Call:

+1 800-699-7764

